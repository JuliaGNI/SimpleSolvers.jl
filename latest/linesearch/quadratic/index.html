<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quadratic · SimpleSolvers.jl</title><meta name="title" content="Quadratic · SimpleSolvers.jl"/><meta property="og:title" content="Quadratic · SimpleSolvers.jl"/><meta property="twitter:title" content="Quadratic · SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../objectives/">Objectives</a></li><li><a class="tocitem" href="../../gradients/">Gradients</a></li><li><a class="tocitem" href="../../jacobians/">Jacobians</a></li><li><a class="tocitem" href="../../hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="../linesearch/">Line Searches</a></li><li><a class="tocitem" href="../static/">Static</a></li><li><a class="tocitem" href="../sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="../curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="../backtracking/">Backtracking</a></li><li><a class="tocitem" href="../bisections/">Bisections</a></li><li class="is-active"><a class="tocitem" href>Quadratic</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Example-for-Optimization"><span>Example for Optimization</span></a></li><li><a class="tocitem" href="#Example-II"><span>Example II</span></a></li></ul></li><li><a class="tocitem" href="../bierlaire_quadratic/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="../../optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="../../update/">Updates</a></li><li><a class="tocitem" href="../../initialize/">Initialization</a></li><li><a class="tocitem" href="../../linear/linear_solvers/">Linear Solvers</a></li><li><a class="tocitem" href="../../nonlinear_solver_status/">Solver Status</a></li><li><a class="tocitem" href="../../in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Line Search</a></li><li class="is-active"><a href>Quadratic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quadratic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/linesearch/quadratic.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quadratic-Line-Search"><a class="docs-heading-anchor" href="#Quadratic-Line-Search">Quadratic Line Search</a><a id="Quadratic-Line-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Line-Search" title="Permalink"></a></h1><p>Quadratic <a href="../linesearch/#Line-Search">line search</a> is based on making a quadratic approximation to an objective and then pick the minimum of this quadratic approximation as the next iteration of <span>$\alpha$</span>.</p><p>The quadratic polynomial is built the following way<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>:</p><p class="math-container">\[p(\alpha) = f^\mathrm{ls}(0) + (f^\mathrm{ls})&#39;(0)\alpha + p_2\alpha^2,\]</p><p>and we also call <span>$p_0:=f^\mathrm{ls}(0)$</span> and <span>$p_1:=(f^\mathrm{ls})&#39;(0)$</span>. The coefficient <span>$p_2$</span> is then determined the following way:</p><ul><li>take a value <span>$\alpha$</span> (typically initialized as <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>) and compute <span>$y = f^\mathrm{ls}(\alpha)$</span>,</li><li>set <span>$p_2 \gets \frac{(y^2 - p_0 - p_1\alpha)}{\alpha^2}.$</span></li></ul><p>After the polynomial is found we then take its minimum (analogously to the <a href="../bierlaire_quadratic/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic line search</a>) and check if it satisfies the <a href="../sufficient_decrease_condition/#The-Sufficient-Decrease-Condition">sufficient decrease condition</a>. If it does not satisfy this condition we repeat the process, but with the current <span>$\alph$</span> as the starting point for the line search (instead of the initial <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>).</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here we treat the following problem:</p><pre><code class="language-julia hljs">f(x::Union{T, Vector{T}}) where {T&lt;:Number} = exp.(x) .* (x .^ 3 - 5x + 2x) .+ 2one(T)
f!(y::AbstractVector{T}, x::AbstractVector{T}) where {T} = y .= f.(x)
F!(y::AbstractVector{T}, x::AbstractVector{T}, params) where {T} = f!(y, x)</code></pre><p><img src="../f.png" alt/></p><p>We now want to use quadratic line search to find the root of this function starting at <span>$x = 0$</span>. We compute the Jacobian of <span>$f$</span> and initialize a <a href="../linesearch/#Line-Search-Objective">line search objective</a>:</p><pre><code class="language-julia hljs">using SimpleSolvers

J!(j::AbstractMatrix{T}, x::AbstractVector{T}, params) where {T} = SimpleSolvers.ForwardDiff.jacobian!(j, f, x)
x = [0.]
# allocate solver
solver = NewtonSolver(x, f(x); F = F!)
# initialize solver
params = nothing
update!(solver, x, params)
compute_jacobian!(solver, x, J!, params; mode = :function)

# compute rhs
F!(cache(solver).rhs, x, params)
rmul!(cache(solver).rhs, -1)

# multiply rhs with jacobian
factorize!(linearsolver(solver), jacobian(solver))
ldiv!(direction(cache(solver)), linearsolver(solver), cache(solver).rhs)
nls = NonlinearSystem(F!, x, f(x))
ls_obj = linesearch_objective(nls, cache(solver), params)
fˡˢ = ls_obj.F
∂fˡˢ∂α = ls_obj.D</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: This function should not be called! Instead call `compute_jacobian!(s, x, params)`.
└ @ SimpleSolvers ~/work/SimpleSolvers.jl/SimpleSolvers.jl/src/nonlinear/newton_solver.jl:187</code></pre><p><img src="../f_ls.png" alt/></p><p>The first two coefficient of the polynomial <span>$p$</span> (i.e. <span>$p_1$</span> and <span>$p_2$</span>) are easy to compute:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(0.)
p₁ = ∂fˡˢ∂α(0.)</code></pre><h3 id="Initializing-\\alpha"><a class="docs-heading-anchor" href="#Initializing-\\alpha">Initializing <span>$\alpha$</span></a><a id="Initializing-\\alpha-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-\\alpha" title="Permalink"></a></h3><p>In order to compute <span>$p_2$</span> we first have to initialize <span>$\alpha$</span>. We start by <em>guessing</em> an initial <span>$\alpha$</span> as <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>. If this initial alpha does not satisfy the <a href="../../#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a>, i.e. it holds that <span>$f^\mathrm{ls}(\alpha_0) &gt; f^\mathrm{ls}(0)$</span>, we call <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> (similarly to calling <a href="../../#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> for <a href="../bisections/#Bracketing">standard bracketing</a>). </p><p>Looking at <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>, we see that the <a href="../../#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> is not satisfied:</p><p><img src="../f_ls_daa.png" alt/></p><p>We therefore see that calling <a href="../../#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a> returns a different <span>$\alpha$</span> (the result of calling <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a>):</p><pre><code class="language-julia hljs">α₀ = determine_initial_α(ls_obj, SimpleSolvers.DEFAULT_ARMIJO_α₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.28</code></pre><p><img src="../f_ls_a0.png" alt/></p><p>We can now finally compute <span>$p_2$</span> and determine the minimum of the polynomial:</p><pre><code class="language-julia hljs">y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
αₜ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5141386947276962</code></pre><p>When using <a href="../../#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a> we in addition call <a href="../../#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a>:</p><pre><code class="language-julia hljs">α₁ = adjust_α(αₜ, α₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5141386947276962</code></pre><p><img src="../f_ls1.png" alt/></p><p>We now check wether <span>$\alpha_1$</span> satisfies the <a href="../sufficient_decrease_condition/#The-Sufficient-Decrease-Condition">sufficient decrease condition</a>:</p><pre><code class="language-julia hljs">sdc = SufficientDecreaseCondition(DEFAULT_WOLFE_c₁, 0., fˡˢ(0.), derivative(ls_obj, 0.), 1., ls_obj)
sdc(α₁)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We now move the original <span>$x$</span> in the Newton direction with step length <span>$\alpha_1$</span> by using <a href="../../#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a>:</p><pre><code class="language-julia hljs">x .= compute_new_iterate(x, α₁, direction(cache(solver)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.3427591298184641</code></pre><p><img src="../f_with_iterate.png" alt/></p><p>And we see that we already very close to the root.</p><h2 id="Example-for-Optimization"><a class="docs-heading-anchor" href="#Example-for-Optimization">Example for Optimization</a><a id="Example-for-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-for-Optimization" title="Permalink"></a></h2><p>We look again at the same example as before, but this time we want to find a minimum and not a root. We hence use <a href="../../#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>SimpleSolvers.linesearch_objective</code></a> not for a <a href="../../#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>, but for an <a href="../../#SimpleSolvers.Optimizer"><code>Optimizer</code></a>:</p><pre><code class="language-julia hljs">using SimpleSolvers: NewtonOptimizerCache, initialize!, gradient

x₀, x₁ = [0.], x
obj = MultivariateObjective(sum∘f, x₀)
gradient!(obj, x₀)
value!(obj, x₀)
_cache = NewtonOptimizerCache(x₀)
hess = Hessian(obj, x₀; mode = :autodiff)
update!(hess, x₀)
update!(_cache, x₀, gradient(obj), hess)
gradient!(obj, x₁)
value!(obj, x₁)
update!(hess, x₁)
update!(_cache, x₁, gradient(obj), hess)
ls_obj = linesearch_objective(obj, _cache)

fˡˢ = ls_obj.F
∂fˡˢ∂α = ls_obj.D</code></pre><p><img src="../f_ls_optimizer.png" alt/></p><div class="admonition is-info" id="Info-d1630f89c4076fd0"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-d1630f89c4076fd0" title="Permalink"></a></header><div class="admonition-body"><p>Note the different shape of the line search objective in the case of the optimizer, especially that the line search objective can take negative values in this case!</p></div></div><p>We now again want to find the minimum with quadratic line search and repeat the procedure above:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6080642672555336</code></pre><pre><code class="language-julia hljs">p₁ = ∂fˡˢ∂α(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.405693326634148</code></pre><pre><code class="language-julia hljs">α₀ = determine_initial_α(ls_obj, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
αₜ = -p₁ / (2p₂)
α₁ = adjust_α(αₜ, α₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-1.275</code></pre><p><img src="../f_ls_opt1.png" alt/></p><p>What we see here is that we do not use <span>$\alpha_t = -p_1 / (2p_2)$</span> as <a href="../../#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a> instead picks the left point in the interval <span>$[\sigma_0\alpha_0, \sigma_1\alpha_0]$</span> as the change computed with <span>$\alpha_t$</span> would be too small.</p><p>We now again move the original <span>$x$</span> in the Newton direction with step length <span>$\alpha_1$</span>:</p><pre><code class="language-julia hljs">x .= compute_new_iterate(x, α₁, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 1.4394773498026217</code></pre><p><img src="../f_with_iterate_opt.png" alt/></p><p>We make another iteration:</p><pre><code class="language-julia hljs">gradient!(obj, x)
value!(obj, x)
update!(hess, x)
update!(_cache, x, gradient(obj), hess)
ls_obj = linesearch_objective(obj, _cache)

fˡˢ = ls_obj.F
∂fˡˢ∂α = ls_obj.D
p₀ = fˡˢ(0.)
p₁ = ∂fˡˢ∂α(0.)
α₀⁽²⁾ = determine_initial_α(ls_obj, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀⁽²⁾) / α₀⁽²⁾^2
p(α) = p₀ + p₁ * α + p₂ * α^2
αₜ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0682684767171837</code></pre><pre><code class="language-julia hljs">α₂ = adjust_α(αₜ, α₀⁽²⁾)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0682684767171837</code></pre><p>We see that for <span>$\alpha_2$</span> (as opposed to <span>$\alpha_1$</span>) we have <span>$\alpha_2 = \alpha_t$</span> as <span>$\alpha_t$</span> is in (this is what <a href="../../#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a> checks for):</p><pre><code class="language-julia hljs">(DEFAULT_ARMIJO_σ₀ * α₀⁽²⁾, DEFAULT_ARMIJO_σ₁ * α₀⁽²⁾)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.512, 2.56)</code></pre><pre><code class="language-julia hljs">x .= compute_new_iterate(x, α₂, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 1.2931972894162747</code></pre><p><img src="../f_with_iterate_opt2.png" alt/></p><p>We finally compute a third iterate:</p><pre><code class="language-julia hljs">gradient!(obj, x)
value!(obj, x)
update!(hess, x)
update!(_cache, x, gradient(obj), hess)
ls_obj = linesearch_objective(obj, _cache)

fˡˢ = ls_obj.F
∂fˡˢ∂α = ls_obj.D
p₀ = fˡˢ(0.)
p₁ = ∂fˡˢ∂α(0.)
α₀⁽³⁾ = determine_initial_α(ls_obj, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀⁽³⁾) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
αₜ = -p₁ / (2p₂)
α₃ = adjust_α(αₜ, α₀⁽³⁾)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3759474782302077</code></pre><pre><code class="language-julia hljs">x .= compute_new_iterate(x, α₃, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 1.281997845228676</code></pre><p><img src="../f_with_iterate_opt3.png" alt/></p><h2 id="Example-II"><a class="docs-heading-anchor" href="#Example-II">Example II</a><a id="Example-II-1"></a><a class="docs-heading-anchor-permalink" href="#Example-II" title="Permalink"></a></h2><p>Here we consider the same example as when discussing the <a href="../bierlaire_quadratic/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic line search</a>.</p><pre><code class="language-julia hljs">ls_obj = linesearch_objective(nls, cache(solver), params)
fˡˢ = ls_obj.F
∂fˡˢ∂α = ls_obj.D</code></pre><p>We now try to find a minimum of <span>$f^\mathrm{ls}$</span> with quadratic line search. For this we first need to find a bracket; we again do this with <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>:</p><pre><code class="language-julia hljs">(a, b) = SimpleSolvers.bracket_minimum_with_fixed_point(fˡˢ, 0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 5.12)</code></pre><p>We plot the bracket:</p><pre><code class="language-julia hljs">using CairoMakie
mred = RGBf(214 / 256, 39 / 256, 40 / 256)
mpurple = RGBf(148 / 256, 103 / 256, 189 / 256)
mgreen = RGBf(44 / 256, 160 / 256, 44 / 256)
mblue = RGBf(31 / 256, 119 / 256, 180 / 256)
morange = RGBf(255 / 256, 127 / 256, 14 / 256)

fig = Figure()
ax = Axis(fig[1, 1])
alpha = -2.5:.01:3.
lines!(ax, alpha, fˡˢ.(alpha); label = L&quot;f^\mathrm{ls}(\alpha)&quot;)
scatter!(ax, a, fˡˢ(a); color = mred, label = L&quot;a&quot;)
scatter!(ax, b, fˡˢ(b); color = mpurple, label = L&quot;b&quot;)
ylims!(ax, (-1., 6.))
axislegend(ax)
save(&quot;f_ls_1.png&quot;, fig)</code></pre><p><img src="../f_ls_1.png" alt/></p><p>We now build the polynomial:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(a)
p₁ = ∂fˡˢ∂α(a)
y = fˡˢ(b)
p₂ = (y - p₀ - p₁*b) / b^2
p(α) = p₀ + p₁ * α + p₂ * α^2</code></pre><p>and compute its minimum:</p><pre><code class="language-julia hljs">αₜ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.446514989327422</code></pre><pre><code class="language-julia hljs">lines!(ax, alpha, p.(alpha); label = L&quot;p(\alpha)&quot;)
scatter!(ax, αₜ, p(αₜ); label = L&quot;\alpha_t&quot;)
ylims!(ax, (-1., 6.))
axislegend(ax)
save(&quot;f_ls_2.png&quot;, fig)</code></pre><p><img src="../f_ls_2.png" alt/></p><p>We now set <span>$a \gets \alpha_t$</span> and perform another iteration:</p><pre><code class="language-julia hljs">(a, b) = SimpleSolvers.bracket_minimum_with_fixed_point(fˡˢ, αₜ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-0.1034850106725782, 2.4565149893274216)</code></pre><p>We again build the polynomial:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(a)
p₁ = ∂fˡˢ∂α(a)
y = fˡˢ(b)
p₂ = (y - p₀ - p₁*(b-a)) / (b-a)^2
p(α) = p₀ + p₁ * (α-a) + p₂ * (α-a)^2</code></pre><p>and compute its minimum:</p><pre><code class="language-julia hljs">αₜ = -p₁ / (2p₂) + a</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.285313587994457</code></pre><p><img src="../f_ls_3.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This is different from the <a href="../bierlaire_quadratic/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic polynomial</a> described in [<a href="../../references/#bierlaire2015optimization">2</a>].</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Here we use <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> directly instead of using <a href="../../#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bisections/">« Bisections</a><a class="docs-footer-nextpage" href="../bierlaire_quadratic/">Bierlaire Quadratic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 3 July 2025 16:37">Thursday 3 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
