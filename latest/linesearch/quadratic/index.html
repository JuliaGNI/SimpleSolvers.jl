<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quadratic · SimpleSolvers.jl</title><meta name="title" content="Quadratic · SimpleSolvers.jl"/><meta property="og:title" content="Quadratic · SimpleSolvers.jl"/><meta property="twitter:title" content="Quadratic · SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/linesearch/quadratic/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../optimizer_problems/">Optimizer Problems</a></li><li><a class="tocitem" href="../../gradients/">Gradients</a></li><li><a class="tocitem" href="../../jacobians/">Jacobians</a></li><li><a class="tocitem" href="../../hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="../linesearch/">Line Searches</a></li><li><a class="tocitem" href="../static/">Static</a></li><li><a class="tocitem" href="../sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="../curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="../backtracking/">Backtracking</a></li><li><a class="tocitem" href="../bisections/">Bisections</a></li><li class="is-active"><a class="tocitem" href>Quadratic</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Example-for-Optimization"><span>Example for Optimization</span></a></li><li><a class="tocitem" href="#Example-II"><span>Example II</span></a></li></ul></li><li><a class="tocitem" href="../quadratic_bierlaire/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="../../optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="../../update/">Updates</a></li><li><a class="tocitem" href="../../initialize/">Initialization</a></li><li><a class="tocitem" href="../../linear/linear_solvers/">Linear Solvers</a></li><li><a class="tocitem" href="../../nonlinear_solver_status/">Solver Status</a></li><li><a class="tocitem" href="../../in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Line Search</a></li><li class="is-active"><a href>Quadratic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quadratic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/linesearch/quadratic.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quadratic-Line-Search"><a class="docs-heading-anchor" href="#Quadratic-Line-Search">Quadratic Line Search</a><a id="Quadratic-Line-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Line-Search" title="Permalink"></a></h1><p>Quadratic <a href="../linesearch/#Line-Search">line search</a> is based on making a quadratic approximation to an optimizer problem and then pick the minimum of this quadratic approximation as the next iteration of <span>$\alpha$</span>.</p><p>The quadratic polynomial is built the following way<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>:</p><p class="math-container">\[p(\alpha) = f^\mathrm{ls}(0) + (f^\mathrm{ls})&#39;(0)\alpha + p_2\alpha^2,\]</p><p>and we also call <span>$p_0:=f^\mathrm{ls}(0)$</span> and <span>$p_1:=(f^\mathrm{ls})&#39;(0)$</span>. The coefficient <span>$p_2$</span> is then determined the following way:</p><ul><li>take a value <span>$\alpha$</span> (typically initialized as <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>) and compute <span>$y = f^\mathrm{ls}(\alpha)$</span>,</li><li>set <span>$p_2 \gets \frac{(y - p_0 - p_1\alpha)}{\alpha^2}.$</span></li></ul><p>After the polynomial is found we then take its minimum (analogously to the <a href="../quadratic_bierlaire/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic line search</a>) and check if it satisfies the <a href="../sufficient_decrease_condition/#The-Sufficient-Decrease-Condition">sufficient decrease condition</a>. If it does not satisfy this condition we repeat the process, but with the current <span>$\alpha$</span> as the starting point for the line search (instead of the initial <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>).</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here we treat the following problem:</p><pre><code class="language-julia hljs">f(x::Union{T, Vector{T}}) where {T&lt;:Number} = exp.(x) .* (x .^ 3 - 5x + 2x) .+ 2one(T)
f!(y::AbstractVector{T}, x::AbstractVector{T}) where {T} = y .= f.(x)
F!(y::AbstractVector{T}, x::AbstractVector{T}, params) where {T} = f!(y, x)</code></pre><p><img src="../f.png" alt/></p><p>We now want to use quadratic line search to find the root of this function starting at <span>$x = 0$</span>. We compute the Jacobian of <span>$f$</span> and initialize a <a href="../linesearch/#Line-Search-Problem">line search problem</a>:</p><pre><code class="language-julia hljs">using SimpleSolvers

function J!(j::AbstractMatrix{T}, x::AbstractVector{T}, params) where {T}
    SimpleSolvers.ForwardDiff.jacobian!(j, f, x)
end

# allocate solver
solver = NewtonSolver(x, f(x); F = F!, DF! = J!)
# initialize solver
params = NullParameters()
state = NonlinearSolverState(x)
jacobian!(solver, x, params)

# compute rhs
F!(cache(solver).rhs, x, params)
rmul!(cache(solver).rhs, -1)

# multiply rhs with jacobian
factorize!(linearsolver(solver), jacobianmatrix(solver))
ldiv!(direction(cache(solver)), linearsolver(solver), cache(solver).rhs)
nlp = NonlinearProblem(F!, J!, x, f(x))
state = NonlinearSolverState(x)
params = (x = state.x, parameters = NullParameters())
update!(state, x, f(x))
ls_obj = linesearch_problem(nlp, jacobian(solver), cache(solver))
fˡˢ(alpha) = ls_obj.F(alpha, params)
∂fˡˢ∂α(alpha) = ls_obj.D(alpha, params)</code></pre><p><img src="../f_ls.png" alt/></p><div class="admonition is-info" id="Info-428860fe5b4870f5"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-428860fe5b4870f5" title="Permalink"></a></header><div class="admonition-body"><p>The second plot shows the optimization problem for the ideal step length, where we start from <span>$x_0$</span> and proceed in the Newton direction. In the following we want to determine its minimum by fitting a quadratic polynomial, i.e. fitting <span>$p$</span>.</p></div></div><p>The first two coefficient of the polynomial <span>$p$</span> (i.e. <span>$p_1$</span> and <span>$p_2$</span>) are easy to compute:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.0</code></pre><pre><code class="language-julia hljs">p₁ = ∂fˡˢ∂α(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-8.0</code></pre><h3 id="Initializing-\\alpha"><a class="docs-heading-anchor" href="#Initializing-\\alpha">Initializing <span>$\alpha$</span></a><a id="Initializing-\\alpha-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-\\alpha" title="Permalink"></a></h3><p>In order to compute <span>$p_2$</span> we first have to initialize <span>$\alpha$</span>. We start by <em>guessing</em> an initial <span>$\alpha$</span> as <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>. If this initial alpha does not satisfy the <a href="../../#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a>, i.e. it holds that <span>$f^\mathrm{ls}(\alpha_0) &gt; f^\mathrm{ls}(0)$</span>, we call <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T, Integer}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> (similarly to calling <a href="../../#SimpleSolvers.bracket_minimum-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}, Tuple{Union{Function, Type}, T, T, T}, Tuple{Union{Function, Type}, T, T, T, Integer}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> for <a href="../bisections/#Bracketing">standard bracketing</a>). </p><p>Looking at <a href="../../#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a>, we see that the <a href="../../#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> is not satisfied:</p><p><img src="../f_ls_daa.png" alt/></p><p>We therefore see that calling <a href="../../#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{LinesearchProblem, Any, T}, Tuple{LinesearchProblem, Any, T, T}, Tuple{LinesearchProblem, Any, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a> returns a different <span>$\alpha$</span> (the result of calling <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T, Integer}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a>):</p><pre><code class="language-julia hljs">state = NonlinearSolverState(x)
update!(state, x, f(x))
params = (x = state.x, parameters = NullParameters())
α₀ = determine_initial_α(ls_obj, params, SimpleSolvers.DEFAULT_ARMIJO_α₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.28</code></pre><p><img src="../f_ls_a0.png" alt/></p><p>We can now finally compute <span>$p_2$</span> and determine the minimum of the polynomial:</p><pre><code class="language-julia hljs">y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
α₁ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5141386947276962</code></pre><p><img src="../f_ls1.png" alt/></p><p>We now check wether <span>$\alpha_1$</span> satisfies the <a href="../sufficient_decrease_condition/#The-Sufficient-Decrease-Condition">sufficient decrease condition</a>:</p><pre><code class="language-julia hljs">sdc = SufficientDecreaseCondition(DEFAULT_WOLFE_c₁, fˡˢ(0.), ∂fˡˢ∂α(0.), fˡˢ)
sdc(α₁)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We now move the original <span>$x$</span> in the Newton direction with step length <span>$\alpha_1$</span> by using <a href="../../#SimpleSolvers.compute_new_iterate!-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate!</code></a>:</p><pre><code class="language-julia hljs">compute_new_iterate!(x, α₁, direction(cache(solver)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.3427591298184641</code></pre><p><img src="../f_with_iterate.png" alt/></p><p>And we see that we already very close to the root.</p><h2 id="Example-for-Optimization"><a class="docs-heading-anchor" href="#Example-for-Optimization">Example for Optimization</a><a id="Example-for-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-for-Optimization" title="Permalink"></a></h2><p>We look again at the same example as before, but this time we want to find a minimum and not a root. We hence use <a href="../../#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver}"><code>SimpleSolvers.linesearch_problem</code></a> not for a <a href="../../#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>, but for an <a href="../../#SimpleSolvers.Optimizer"><code>Optimizer</code></a>:</p><pre><code class="language-julia hljs">using SimpleSolvers: NewtonOptimizerCache, initialize!, gradient

x₀, x₁ = [0.], x
obj = OptimizerProblem(sum∘f, x₀)
grad = GradientAutodiff{Float64}(obj.F, length(x))
_cache = NewtonOptimizerCache(x₀)
state = NewtonOptimizerState(x₀)
params = (x = state.x̄,)
hess = HessianAutodiff(obj, x₀)
H = SimpleSolvers.alloc_h(x)
hess(H, x₀)
update!(_cache, state, grad, hess, x₀)
hess(H, x₁)
update!(_cache, state, grad, hess, x₁)
ls_obj = linesearch_problem(obj, grad, _cache)

fˡˢ(alpha) = ls_obj.F(alpha, params)
∂fˡˢ∂α(alpha) = ls_obj.D(alpha, params)</code></pre><p><img src="../f_ls_optimizer.png" alt/></p><div class="admonition is-info" id="Info-cc9ee563512fec8f"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-cc9ee563512fec8f" title="Permalink"></a></header><div class="admonition-body"><p>Note the different shape of the line search problem in the case of the optimizer, especially that the line search problem can take negative values in this case!</p></div></div><p>We now again want to find the minimum with quadratic line search and repeat the procedure above:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.0</code></pre><pre><code class="language-julia hljs">p₁ = ∂fˡˢ∂α(0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.580513458786253</code></pre><pre><code class="language-julia hljs">params = (x = state.x̄, parameters = NullParameters())
α₀ = determine_initial_α(ls_obj, params, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
α₁ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.1988165696410768</code></pre><p><img src="../f_ls_opt1.png" alt/></p><p>We now again move the original <span>$x$</span> in the Newton direction with step length <span>$\alpha_1$</span>:</p><pre><code class="language-julia hljs">compute_new_iterate!(x, α₁, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.5137754077479685</code></pre><p><img src="../f_with_iterate_opt.png" alt/></p><p>We make another iteration:</p><pre><code class="language-julia hljs">hess(H, x)
update!(_cache, state, grad, hess, x)
ls_obj = linesearch_problem(obj, grad, _cache)
fˡˢ(alpha) = ls_obj.F(alpha, params)
∂fˡˢ∂α(alpha) = ls_obj.D(alpha, params)
p₀ = fˡˢ(0.)
p₁ = ∂fˡˢ∂α(0.)
params = (x = state.x̄, parameters = NullParameters())
α₀⁽²⁾ = determine_initial_α(ls_obj, params, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀⁽²⁾) / α₀⁽²⁾^2
p(α) = p₀ + p₁ * α + p₂ * α^2
α₂ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.003921611731926922</code></pre><p><img src="../f_ls_opt2.png" alt/></p><p>We now update <span>$x$</span>:</p><pre><code class="language-julia hljs">using SimpleSolvers: compute_new_iterate
x .= compute_new_iterate(x, α₂, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.5189490483419136</code></pre><p><img src="../f_with_iterate_opt2.png" alt/></p><p>We finally compute a third iterate:</p><pre><code class="language-julia hljs">hess(H, x)
update!(_cache, state, grad, hess, x)
ls_obj = linesearch_problem(obj, grad, _cache)

fˡˢ(alpha) = ls_obj.F(alpha, params)
∂fˡˢ∂α(alpha) = ls_obj.D(alpha, params)
p₀ = fˡˢ(0.)
p₁ = ∂fˡˢ∂α(0.)
params = (x = state.x̄, parameters = NullParameters())
α₀⁽³⁾ = determine_initial_α(ls_obj, params, SimpleSolvers.DEFAULT_ARMIJO_α₀)
y = fˡˢ(α₀)
p₂ = (y - p₀ - p₁*α₀⁽³⁾) / α₀^2
p(α) = p₀ + p₁ * α + p₂ * α^2
α₃ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.014195098040992104</code></pre><pre><code class="language-julia hljs">x .= compute_new_iterate(x, α₃, direction(_cache))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 0.5380119559453095</code></pre><p><img src="../f_with_iterate_opt3.png" alt/></p><h2 id="Example-II"><a class="docs-heading-anchor" href="#Example-II">Example II</a><a id="Example-II-1"></a><a class="docs-heading-anchor-permalink" href="#Example-II" title="Permalink"></a></h2><p>Here we consider the same example as when discussing the <a href="../quadratic_bierlaire/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic line search</a>.</p><pre><code class="language-julia hljs">state = NonlinearSolverState(x)
update!(state, x, f(x))
params = (x = state.x, parameters = NullParameters())
ls_obj = linesearch_problem(nlp, JacobianFunction{Float64}(F!, J!), cache(solver))
fˡˢ(alpha) = ls_obj.F(alpha, params)
∂fˡˢ∂α(alpha) = ls_obj.D(alpha, params)</code></pre><p>We now try to find a minimum of <span>$f^\mathrm{ls}$</span> with quadratic line search. For this we first need to find a bracket; we again do this with <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T, Integer}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup>:</p><pre><code class="language-julia hljs">(a, b) = SimpleSolvers.bracket_minimum_with_fixed_point(fˡˢ, ∂fˡˢ∂α, 0.)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 1.28)</code></pre><p>We plot the bracket:</p><pre><code class="language-julia hljs">using CairoMakie
mred = RGBf(214 / 256, 39 / 256, 40 / 256)
mpurple = RGBf(148 / 256, 103 / 256, 189 / 256)
mgreen = RGBf(44 / 256, 160 / 256, 44 / 256)
mblue = RGBf(31 / 256, 119 / 256, 180 / 256)
morange = RGBf(255 / 256, 127 / 256, 14 / 256)

fig = Figure()
ax = Axis(fig[1, 1])
alpha = -2:.01:6.
lines!(ax, alpha, fˡˢ.(alpha); label = L&quot;f^\mathrm{ls}(\alpha)&quot;)
scatter!(ax, a, fˡˢ(a); color = mred, label = L&quot;a&quot;)
scatter!(ax, b, fˡˢ(b); color = mpurple, label = L&quot;b&quot;)
axislegend(ax)
save(&quot;f_ls_1.png&quot;, fig)</code></pre><p><img src="../f_ls_1.png" alt/></p><p>We now build the polynomial:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(a)
p₁ = ∂fˡˢ∂α(a)
y = fˡˢ(b)
p₂ = (y - p₀ - p₁*b) / b^2
p(α) = p₀ + p₁ * α + p₂ * α^2</code></pre><p>and compute its minimum:</p><pre><code class="language-julia hljs">αₜ = -p₁ / (2p₂)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0063463859825368</code></pre><pre><code class="language-julia hljs">lines!(ax, alpha, p.(alpha); label = L&quot;p(\alpha)&quot;)
scatter!(ax, αₜ, p(αₜ); label = L&quot;\alpha_t&quot;)
axislegend(ax)
save(&quot;f_ls_2.png&quot;, fig)</code></pre><p><img src="../f_ls_2.png" alt/></p><p>We now set <span>$a \gets \alpha_t$</span> and perform another iteration:</p><pre><code class="language-julia hljs">(a, b) = SimpleSolvers.bracket_minimum_with_fixed_point(fˡˢ, ∂fˡˢ∂α, αₜ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.9363463859825367, 1.0163463859825368)</code></pre><p>We again build the polynomial:</p><pre><code class="language-julia hljs">p₀ = fˡˢ(a)
p₁ = ∂fˡˢ∂α(a)
y = fˡˢ(b)
p₂ = (y - p₀ - p₁*(b-a)) / (b-a)^2
p(α) = p₀ + p₁ * (α-a) + p₂ * (α-a)^2</code></pre><p>and compute its minimum:</p><pre><code class="language-julia hljs">αₜ = -p₁ / (2p₂) + a</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9726800175181818</code></pre><p><img src="../f_ls_3.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This is different from the <a href="../quadratic_bierlaire/#Bierlaire-Quadratic-Line-Search">Bierlaire quadratic polynomial</a> described in [<a href="../../references/#bierlaire2015optimization">2</a>].</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Here we use <a href="../../#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T}, Tuple{Union{Function, Type}, Union{Function, Type}, T, T, T, Integer}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> directly instead of using <a href="../../#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{LinesearchProblem, Any, T}, Tuple{LinesearchProblem, Any, T, T}, Tuple{LinesearchProblem, Any, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bisections/">« Bisections</a><a class="docs-footer-nextpage" href="../quadratic_bierlaire/">Bierlaire Quadratic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 15:58">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
