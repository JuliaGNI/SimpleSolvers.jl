<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SimpleSolvers.jl</title><meta name="title" content="Home · SimpleSolvers.jl"/><meta property="og:title" content="Home · SimpleSolvers.jl"/><meta property="twitter:title" content="Home · SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="optimizer_problems/">Optimizer Problems</a></li><li><a class="tocitem" href="gradients/">Gradients</a></li><li><a class="tocitem" href="jacobians/">Jacobians</a></li><li><a class="tocitem" href="hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="linesearch/linesearch/">Line Searches</a></li><li><a class="tocitem" href="linesearch/static/">Static</a></li><li><a class="tocitem" href="linesearch/sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="linesearch/curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="linesearch/backtracking/">Backtracking</a></li><li><a class="tocitem" href="linesearch/bisections/">Bisections</a></li><li><a class="tocitem" href="linesearch/quadratic/">Quadratic</a></li><li><a class="tocitem" href="linesearch/bierlaire_quadratic/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="update/">Updates</a></li><li><a class="tocitem" href="initialize/">Initialization</a></li><li><a class="tocitem" href="linear/linear_solvers/">Linear Solvers</a></li><li><a class="tocitem" href="nonlinear_solver_status/">Solver Status</a></li><li><a class="tocitem" href="in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SimpleSolvers"><a class="docs-heading-anchor" href="#SimpleSolvers">SimpleSolvers</a><a id="SimpleSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleSolvers" title="Permalink"></a></h1><ul><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a></li><li><a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a></li><li><a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a></li><li><a href="#SimpleSolvers.DEFAULT_WOLFE_c₂"><code>SimpleSolvers.DEFAULT_WOLFE_c₂</code></a></li><li><a href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a></li><li><a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a></li><li><a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a></li><li><a href="#SimpleSolvers.AbstractLinearProblem"><code>SimpleSolvers.AbstractLinearProblem</code></a></li><li><a href="#SimpleSolvers.AbstractNonlinearSolverCache"><code>SimpleSolvers.AbstractNonlinearSolverCache</code></a></li><li><a href="#SimpleSolvers.AbstractOptimizerProblem"><code>SimpleSolvers.AbstractOptimizerProblem</code></a></li><li><a href="#SimpleSolvers.BFGS"><code>SimpleSolvers.BFGS</code></a></li><li><a href="#SimpleSolvers.BFGSCache"><code>SimpleSolvers.BFGSCache</code></a></li><li><a href="#SimpleSolvers.BFGSState"><code>SimpleSolvers.BFGSState</code></a></li><li><a href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a></li><li><a href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a></li><li><a href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a></li><li><a href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a></li><li><a href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a></li><li><a href="#SimpleSolvers.DFP"><code>SimpleSolvers.DFP</code></a></li><li><a href="#SimpleSolvers.DFPCache"><code>SimpleSolvers.DFPCache</code></a></li><li><a href="#SimpleSolvers.DFPState"><code>SimpleSolvers.DFPState</code></a></li><li><a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.FixedPointIterator</code></a></li><li><a href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a></li><li><a href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a></li><li><a href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a></li><li><a href="#SimpleSolvers.IterativeHessian"><code>SimpleSolvers.IterativeHessian</code></a></li><li><a href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a></li><li><a href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a></li><li><a href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a></li><li><a href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a></li><li><a href="#SimpleSolvers.LinearProblem"><code>SimpleSolvers.LinearProblem</code></a></li><li><a href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a></li><li><a href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a></li><li><a href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a></li><li><a href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a></li><li><a href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a></li><li><a href="#SimpleSolvers.LinesearchProblem"><code>SimpleSolvers.LinesearchProblem</code></a></li><li><a href="#SimpleSolvers.NewtonMethod"><code>SimpleSolvers.NewtonMethod</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a></li><li><a href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NoLinearProblem"><code>SimpleSolvers.NoLinearProblem</code></a></li><li><a href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a></li><li><a href="#SimpleSolvers.NonlinearProblem"><code>SimpleSolvers.NonlinearProblem</code></a></li><li><a href="#SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearProblem</code></a></li><li><a href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverCache"><code>SimpleSolvers.NonlinearSolverCache</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverState"><code>SimpleSolvers.NonlinearSolverState</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a></li><li><a href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a></li><li><a href="#SimpleSolvers.OptimizerCache"><code>SimpleSolvers.OptimizerCache</code></a></li><li><a href="#SimpleSolvers.OptimizerMethod"><code>SimpleSolvers.OptimizerMethod</code></a></li><li><a href="#SimpleSolvers.OptimizerProblem"><code>SimpleSolvers.OptimizerProblem</code></a></li><li><a href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a></li><li><a href="#SimpleSolvers.OptimizerState"><code>SimpleSolvers.OptimizerState</code></a></li><li><a href="#SimpleSolvers.OptimizerStatus-Union{Tuple{OCT}, Tuple{OST}, Tuple{T}, Tuple{OST, OCT, T}} where {T, OST&lt;:OptimizerState{T}, OCT&lt;:SimpleSolvers.OptimizerCache{T}}"><code>SimpleSolvers.OptimizerStatus</code></a></li><li><a href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a></li><li><a href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a></li><li><a href="#SimpleSolvers.PicardMethod"><code>SimpleSolvers.PicardMethod</code></a></li><li><a href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a></li><li><a href="#SimpleSolvers.QuasiNewtonOptimizerMethod"><code>SimpleSolvers.QuasiNewtonOptimizerMethod</code></a></li><li><a href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a></li><li><a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a></li><li><a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.BFGSCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.DFPCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{NewtonOptimizerState, Gradient, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, Gradient, Hessian, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{NewtonSolver{T} where T, NonlinearSolverState, AbstractArray, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{Optimizer, OptimizerState, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a></li><li><a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a></li><li><a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a></li><li><a href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a></li><li><a href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a></li><li><a href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a></li><li><a href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a></li><li><a href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a></li><li><a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>SimpleSolvers.assess_convergence</code></a></li><li><a href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a></li><li><a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a></li><li><a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a></li><li><a href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a></li><li><a href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a></li><li><a href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a></li><li><a href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.compute_new_iterate!-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate!</code></a></li><li><a href="#SimpleSolvers.convergence_measures-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.convergence_measures</code></a></li><li><a href="#SimpleSolvers.default_precision"><code>SimpleSolvers.default_precision</code></a></li><li><a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a></li><li><a href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{NonlinearSolverState}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.isaOptimizerState-Tuple{Any}"><code>SimpleSolvers.isaOptimizerState</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.jacobianmatrix-Tuple{NonlinearSolver}"><code>SimpleSolvers.jacobianmatrix</code></a></li><li><a href="#SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><code>SimpleSolvers.linearsolver</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T}, Jacobian{T}, SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T}, Gradient, SimpleSolvers.OptimizerCache{T}, OptimizerState}} where T"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options, Integer}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a></li><li><a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a></li><li><a href="#SimpleSolvers.nonlinearproblem-Tuple{NonlinearSolver}"><code>SimpleSolvers.nonlinearproblem</code></a></li><li><a href="#SimpleSolvers.print_status-Tuple{NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a></li><li><a href="#SimpleSolvers.residuals-Tuple{NonlinearSolverState}"><code>SimpleSolvers.residuals</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NonlinearSolverCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_χ_to_avoid_stalling</code></a></li><li><a href="#SimpleSolvers.solve-Union{Tuple{ALG}, Tuple{T}, Tuple{LinesearchProblem{T}, Linesearch{T, ALG, OPT} where OPT&lt;:Options{T}}} where {T, ALG&lt;:LinesearchMethod{T}}"><code>SimpleSolvers.solve</code></a></li><li><a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, OptimizerState, Optimizer}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, OptimizerState, Optimizer}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a></li><li><a href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{AbstractArray{T}, NonlinearProblem{T}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.value!</code></a></li></ul><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_p"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_p</code></pre><p>Constant used in <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL29-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_α₀"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_α₀</code></pre><p>The default starting value for <span>$\alpha$</span> used in <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> (also see <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a> and <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>). Its value is 1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_σ₀"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₀</code></pre><p>Constant used in <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>.</p><p>It is meant to <em>safeguard against stagnation</em> when performing line searches (see [<a href="references/#kelley1995iterative">1</a>]).</p><p>Its value is 0.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL10-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_σ₁"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₁</code></pre><p>Constant used in <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL21-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BIERLAIRE_ε"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ε</code></pre><p>A constant that determines the <em>precision</em> in <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. The constant recommended in [<a href="references/#bierlaire2015optimization">2</a>] is <code>1E-3</code>.</p><p>Note that this constant may also depend on whether we deal with optimizers or solvers.</p><div class="admonition is-warning" id="Warning-1f1dbc7b18051cfc"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1f1dbc7b18051cfc" title="Permalink"></a></header><div class="admonition-body"><p>We have deactivated the use of this constant for the moment and are only using <code>eps(T)</code> in <code>BierlaireQuadratic</code>. This is because solvers and optimizers should rely on different choices of this constant.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bierlaire_quadratic.jl#LL1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ξ</code></pre><p>A constant on basis of which the <code>b</code> in <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a> is perturbed in order &quot;to avoid stalling&quot; (see [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1]; in this reference the author recommends <span>$10^{-7}$</span> as a value). Its value is 2.384185791015625e-7.</p><div class="admonition is-warning" id="Warning-1f1dbc7b18051cfc"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1f1dbc7b18051cfc" title="Permalink"></a></header><div class="admonition-body"><p>We have deactivated the use of this constant for the moment and are only using <code>eps(T)</code> in <code>BierlaireQuadratic</code>. This is because solvers and optimizers should rely on different choices of this constant.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bierlaire_quadratic.jl#LL13-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_k"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_k</code></pre><p>Gives the default ratio by which the bracket is increased if bracketing was not successful. See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_nmax"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Default constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_s"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_s</code></pre><p>Gives the default width of the interval (the bracket). See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_GRADIENT_ϵ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">DEFAULT_GRADIENT_ϵ</code></pre><p>A constant on whose basis finite differences are computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>The default number of iterations before the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is refactored in the <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/methods.jl#LL18-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">DEFAULT_JACOBIAN_ϵ</code></pre><p>A constant used for computing the finite difference Jacobian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_WOLFE_c₁"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_WOLFE_c₁</code></pre><p>A constant <span>$\epsilon$</span> on which a finite difference approximation of the derivative of the problem is computed. This is then used in the following stopping criterion:</p><p class="math-container">\[\frac{f(\alpha) - f(\alpha_0)}{\epsilon} &lt; \alpha\cdot{}f&#39;(\alpha_0).\]</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL37-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_WOLFE_c₂"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_WOLFE_c₂"><code>SimpleSolvers.DEFAULT_WOLFE_c₂</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DEFAULT_WOLFE_c₂</code></pre><p>The constant used in the second Wolfe condition (the <a href="#SimpleSolvers.CurvatureCondition"><code>CurvatureCondition</code></a>). According to [<a href="references/#nocedal2006numerical">3</a>, <a href="references/#kochenderfer2019algorithms">4</a>] we should have</p><p class="math-container">\[c_2 \in (c_1, 1).\]</p><p>Furthermore [<a href="references/#nocedal2006numerical">3</a>] recommend <span>$c_2 = 0.9$</span> and [<a href="references/#kochenderfer2019algorithms">4</a>] write that &quot;it is common to set [<span>$c_2=0.1$</span>] when approximate line search is used with the conjugate gradient method and to 0.9 when used with Newton&#39;s method.&quot; We also use <span>$c_2 =$</span>DEFAULT_WOLFE_c₂ here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL52-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_s_REDUCTION"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A factor by which <code>s</code> is reduced in each bracketing iteration (see <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/quadratic.jl#LL28-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><a class="docstring-binding" href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>This constant is used for <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> and <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/quadratic.jl#LL18-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.N_STATIC_THRESHOLD"><a class="docstring-binding" href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Threshold for the maximum size a static matrix should have.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL59-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.AbstractLinearProblem"><a class="docstring-binding" href="#SimpleSolvers.AbstractLinearProblem"><code>SimpleSolvers.AbstractLinearProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Encompasses the <a href="#SimpleSolvers.NoLinearProblem"><code>NoLinearProblem</code></a> and the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.AbstractNonlinearSolverCache"><a class="docstring-binding" href="#SimpleSolvers.AbstractNonlinearSolverCache"><code>SimpleSolvers.AbstractNonlinearSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNonlinearSolverCache</code></pre><p>An abstract type that comprises e.g. the <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_cache.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.AbstractOptimizerProblem"><a class="docstring-binding" href="#SimpleSolvers.AbstractOptimizerProblem"><code>SimpleSolvers.AbstractOptimizerProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractOptimizerProblem</code></pre><p>An <em>optimizer problem</em> is a quantity to has to be made zero by a solver or minimized by an optimizer.</p><p>See <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> and <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_problems.jl#LL1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BFGS"><a class="docstring-binding" href="#SimpleSolvers.BFGS"><code>SimpleSolvers.BFGS</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Algorithm taken from [<a href="references/#nocedal2006numerical">3</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/optimizer_methods.jl#LL22-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BFGSCache"><a class="docstring-binding" href="#SimpleSolvers.BFGSCache"><code>SimpleSolvers.BFGSCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BFGSCache</code></pre><p>The <a href="#SimpleSolvers.OptimizerCache"><code>OptimizerCache</code></a> for the <a href="#SimpleSolvers.BFGS"><code>BFGS</code></a> algorithm. Also see <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::BFGSCache, ::OptimizerState, ::AbstractVector, ::AbstractVector</code>)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_cache.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BFGSState"><a class="docstring-binding" href="#SimpleSolvers.BFGSState"><code>SimpleSolvers.BFGSState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BFGSState &lt;: OptimizerState</code></pre><p>The <a href="#SimpleSolvers.OptimizerState"><code>OptimizerState</code></a> corresponding to the <a href="#SimpleSolvers.BFGS"><code>BFGS</code></a> method.</p><p><strong>Keys</strong></p><ul><li><code>x̄</code></li><li><code>ḡ</code></li><li><code>f̄</code></li><li><code>Q</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_state.jl#LL1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Backtracking"><a class="docstring-binding" href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Backtracking &lt;: LinesearchMethod</code></pre><p><strong>Keys</strong></p><p>The keys are:</p><ul><li><code>α₀</code>:</li><li><code>ϵ=$(DEFAULT_WOLFE_c₁)</code>: a default step size on whose basis we compute a finite difference approximation of the derivative of the problem. Also see <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a>.</li><li><code>p=$(DEFAULT_ARMIJO_p)</code>: a parameter with which <span>$\alpha$</span> is decreased in every step until the stopping criterion is satisfied.</li></ul><p><strong>Functor</strong></p><p>The functor is used the following way:</p><pre><code class="language-julia hljs">ls(obj, α = ls.α₀)</code></pre><p><strong>Implementation</strong></p><p>The algorithm starts by setting:</p><p class="math-container">\[x_0 \gets 0,
y_0 \gets f(x_0),
d_0 \gets f&#39;(x_0),
\alpha \gets \alpha_0,\]</p><p>where <span>$f$</span> is the <em>univariate optimizer problem</em> (of type <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a>) and <span>$\alpha_0$</span> is stored in <code>ls</code>. It then repeatedly does <span>$\alpha \gets \alpha\cdot{}p$</span> until either (i) the maximum number of iterations is reached (the <code>max_iterations</code> keyword in <a href="#SimpleSolvers.Options"><code>Options</code></a>) or (ii) the following holds:</p><p class="math-container">\[    f(\alpha) &lt; y_0 + \epsilon \cdot \alpha \cdot d_0,\]</p><p>where <span>$\epsilon$</span> is stored in <code>ls</code>.</p><div class="admonition is-info" id="Info-f45ea34c7d883f1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f45ea34c7d883f1" title="Permalink"></a></header><div class="admonition-body"><p>The algorithm allocates an instance of <code>SufficientDecreaseCondition</code> by calling <code>SufficientDecreaseCondition(ls.ϵ, x₀, y₀, d₀, one(α), obj)</code>, here we take the <em>value one</em> for the search direction <span>$p$</span>, this is because we already have the search direction encoded into the line search problem.</p></div></div><p><strong>Extended help</strong></p><p>The backtracking algorithm starts by setting <span>$y_0 \gets f(0)$</span> and <span>$d_0 \gets \nabla_0f$</span>.</p><p>The algorithm is executed by calling the functor of <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>.</p><p>The following is then repeated until the stopping criterion is satisfied or <code>config.max_iterations</code> (1000 by default) is reached:</p><pre><code class="language-julia hljs">if value(obj, α) ≥ y₀ + ls.ϵ * α * d₀
    α *= ls.p
else
    break
end</code></pre><p>The stopping criterion as an equation can be written as:</p><p class="math-container">\[f(lpha) &lt; y_0 + psilon lpha 
abla_0f = y_0 + psilon (lpha - 0)
abla_0f.\]</p><p>Note that if the stopping criterion is not reached, <span>$lpha$</span> is multiplied with <span>$p$</span> and the process continues.</p><p><a href="https://en.wikipedia.org/wiki/Backtracking_line_search">Sometimes</a> the parameters <span>$p$</span> and <span>$psilon$</span> have different names such as <span>$au$</span> and <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/backtracking.jl#LL64-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BacktrackingCondition"><a class="docstring-binding" href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BacktrackingCondition</code></pre><p>Abstract type comprising the conditions that are used for checking step sizes for the backtracking line search (see <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/condition.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BierlaireQuadratic"><a class="docstring-binding" href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BierlaireQuadratic &lt;: Linesearch</code></pre><p>Algorithm taken from [<a href="references/#bierlaire2015optimization">2</a>].</p><p><strong>Extended help</strong></p><p>Note that the performance of <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a> may heavily depend on the choice of <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>DEFAULT_BIERLAIRE_ε</code></a> (i.e. the precision) and <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>DEFAULT_BIERLAIRE_ξ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bierlaire_quadratic.jl#LL71-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Bisection"><a class="docstring-binding" href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Bisection &lt;: Linesearch</code></pre><p>See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> for the implementation of the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bisection.jl#LL86-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BracketMinimumCriterion"><a class="docstring-binding" href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BracketMinimumCriterion &lt;: BracketingCriterion</code></pre><p>The criterion used for <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><p><strong>Functor</strong></p><pre><code class="language-julia hljs">bc(yb, yc)</code></pre><p>This checks whether <code>yc</code> is bigger than <code>yb</code>, i.e. whether <code>c</code> is <em>past the minimum</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL19-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.CurvatureCondition"><a class="docstring-binding" href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurvatureCondition &lt;: LinesearchCondition</code></pre><p>The second of the Wolfe conditions [<a href="references/#nocedal2006numerical">3</a>]. The first one is the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a>.</p><p>This encompasses the <em>standard curvature condition</em> and the <em>strong curvature condition</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CurvatureCondition(c, xₖ, gradₖ, pₖ, obj, grad; mode)</code></pre><p>Here <code>grad</code> has to be a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>obj</code> an <a href="#SimpleSolvers.AbstractOptimizerProblem"><code>AbstractOptimizerProblem</code></a>. The other inputs are either arrays or numbers.</p><p><strong>Implementation</strong></p><p>For computational reasons <code>CurvatureCondition</code> also has a field <code>gradₖ₊₁</code> in which the temporary new gradient is saved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/curvature_condition.jl#LL1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DFP"><a class="docstring-binding" href="#SimpleSolvers.DFP"><code>SimpleSolvers.DFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Algorithm taken from [<a href="references/#nocedal2006numerical">3</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/optimizer_methods.jl#LL17-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DFPCache"><a class="docstring-binding" href="#SimpleSolvers.DFPCache"><code>SimpleSolvers.DFPCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DFPCache &lt;: OptimizerCache</code></pre><p>The <a href="#SimpleSolvers.OptimizerCache"><code>OptimizerCache</code></a> corresponding to the <a href="#SimpleSolvers.DFP"><code>DFP</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_cache.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DFPState"><a class="docstring-binding" href="#SimpleSolvers.DFPState"><code>SimpleSolvers.DFPState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DFPState</code></pre><p>This is equivalent to <a href="#SimpleSolvers.BFGSState"><code>BFGSState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_state.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.FixedPointIterator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FixedPointIterator(x, F)</code></pre><p><strong>Keywords</strong></p><ul><li><code>options_kwargs</code>: see <a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/fixed_point_iterator.jl#LL10-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Gradient"><a class="docstring-binding" href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Gradient</code></pre><p>Abstract type. <code>struct</code>s that are derived from this need an associated functor that computes the gradient of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Gradient</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">(grad::Gradient)(g::AbstractVector, x::AbstractVector)</code></pre><p>There is also an out-of place version for convenience:</p><pre><code class="language-julia hljs">(grad::Gradient)(x::AbstractVector)</code></pre><p>This is using <a href="#SimpleSolvers.alloc_g"><code>alloc_g</code></a> to allocate the array <code>g</code> for the gradient.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.GradientFunction"><code>GradientFunction</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL8-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientAutodiff"><a class="docstring-binding" href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GradientAutodiff &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>∇config</code>: result of applying <code>ForwardDiff.GradientConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GradientAutodiff(F, x::AbstractVector)
GradientAutodiff{T}(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = ForwardDiff.gradient!(g, grad.F, x, grad.∇config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL118-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientFiniteDifferences"><a class="docstring-binding" href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GradientFiniteDifferences &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>e</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">GradientFiniteDifferences{T}(F, nx::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>DEFAULT_GRADIENT_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x,g)
    ϵⱼ = grad.ϵ * x[j] + grad.ϵ
    fill!(grad.e, 0)
    grad.e[j] = 1
    grad.tx .= x .- ϵⱼ .* grad.e
    f1 = grad.F(grad.tx)
    grad.tx .= x .+ ϵⱼ .* grad.e
    f2 = grad.F(grad.tx)
    g[j] = (f2 - f1) / (2ϵⱼ)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL162-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientFunction"><a class="docstring-binding" href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GradientFunction &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>∇F!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = grad.∇F!(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL81-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Hessian"><a class="docstring-binding" href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Hessian</code></pre><p>Abstract type. <code>struct</code>s derived from this need an associated functor that computes the Hessian of a function (in-place).</p><p>Also see <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Implementation</strong></p><p>When a custom <code>Hessian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (hessian::Hessian)(h::AbstractMatrix, x::AbstractVector) end</code></pre><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.HessianFunction"><code>HessianFunction</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>HessianDFP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/hessian.jl#LL1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianAutodiff"><a class="docstring-binding" href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HessianAutodiff &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes <a href="update/#Hessian"><code>Hessian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>H</code>: a matrix in which the (updated) <a href="update/#Hessian"><code>Hessian</code></a> is stored. </li><li><code>Hconfig</code>: result of applying <code>ForwardDiff.HessianConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HessianAutodiff(F, x::AbstractVector)
HessianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(g, x) = ForwardDiff.hessian!(hes.H, hes.F, x, grad.Hconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/hessian.jl#LL90-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianBFGS"><a class="docstring-binding" href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HessianBFGS &lt;: Hessian</code></pre><p>A <code>struct</code> derived from <a href="update/#Hessian"><code>Hessian</code></a> to be used for an <a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/hessian_bfgs.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianDFP"><a class="docstring-binding" href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HessianDFP &lt;: Hessian</code></pre><p>The <a href="update/#Hessian"><code>Hessian</code></a> corresponding to the <a href="#SimpleSolvers.DFP"><code>DFP</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/hessian_dfp.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianFunction"><a class="docstring-binding" href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HessianFunction &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes a <a href="update/#Hessian"><code>Hessian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>H!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(H, x) = hes.H!(H, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/hessian.jl#LL60-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.IterativeHessian"><a class="docstring-binding" href="#SimpleSolvers.IterativeHessian"><code>SimpleSolvers.IterativeHessian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterativeHessian &lt;: Hessian</code></pre><p>An abstract type derived from <a href="update/#Hessian"><code>Hessian</code></a>. Its main purpose is defining a supertype that encompasses <a href="#SimpleSolvers.HessianBFGS"><code>HessianBFGS</code></a> and <a href="#SimpleSolvers.HessianDFP"><code>HessianDFP</code></a> for dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/iterative_hessians.jl#LL1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Jacobian"><a class="docstring-binding" href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Jacobian</code></pre><p>Abstract type. <code>struct</code>s that are derived from this need an associated functor that computes the Jacobian of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Jacobian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (j::Jacobian)(g::AbstractMatrix, x::AbstractVector) end</code></pre><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.JacobianFunction"><code>JacobianFunction</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>JacobianFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL8-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianAutodiff"><a class="docstring-binding" href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JacobianAutodiff &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>Jconfig</code>: result of applying <code>ForwardDiff.JacobianConfig</code>.</li><li><code>ty</code>: vector that is used for evaluating <code>ForwardDiff.jacobian!</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">JacobianAutodiff(F, y::AbstractVector)
JacobianAutodiff{T}(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(J, x) = ForwardDiff.jacobian!(J, jac.ty, x, grad.Jconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL85-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianFiniteDifferences"><a class="docstring-binding" href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JacobianFiniteDifferences &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>f1</code>:</li><li><code>f2</code>:</li><li><code>e1</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>e2</code>:</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">JacobianFiniteDifferences{T}(F, nx::Integer, ny::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>DEFAULT_JACOBIAN_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x)
    ϵⱼ = jac.ϵ * x[j] + jac.ϵ
    fill!(jac.e, 0)
    jac.e[j] = 1
    jac.tx .= x .- ϵⱼ .* jac.e
    f(jac.f1, jac.tx)
    jac.tx .= x .+ ϵⱼ .* jac.e
    f(jac.f2, jac.tx)
    for i in eachindex(x)
        J[i,j] = (jac.f2[i] - jac.f1[i]) / (2ϵⱼ)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL143-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianFunction"><a class="docstring-binding" href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JacobianFunction &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by explicitly supplying a function taken from the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>.</p><p><strong>Functor</strong></p><p>There is no functor associated to <code>JacobianFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL57-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LU"><a class="docstring-binding" href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LU &lt;: DirectMethod</code></pre><p>A custom implementation of an LU solver, meant to solve a <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>.</p><p>Routines that use the LU solver include <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>, <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> and <a href="#SimpleSolvers.solve!"><code>solve!</code></a>. In practice the <code>LU</code> solver is used by calling the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> constructor and <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> or <a href="#SimpleSolvers.solve!"><code>solve!</code></a>, or with an instance of <code>LU</code> as an argument directly, as shown in the <em>Example section</em> of this docstring.</p><p><strong>constructor</strong></p><p>The constructor is called with either no argument:</p><pre><code class="language-julia hljs">LU()

# output

LU{Missing}(missing, true)</code></pre><p>or with <code>pivot</code> and <code>static</code> as optional booleans:</p><pre><code class="language-julia hljs">LU(; pivot=true, static=true)

# output

LU{Bool}(true, true)</code></pre><p>Note that if we do not supply an explicit keyword <code>static</code>, the corresponding field is <code>missing</code> (as in the first case). Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p><p><strong>Example</strong></p><p>We use the <code>LU</code> together with <a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>solve</code></a> to solve a linear system:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
v = rand(3)
ls = LinearProblem(A, v)
update!(ls, A, v)

lu = LU()

solve(lu, ls) ≈ inv(A) * v

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL1-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LUSolverCache"><a class="docstring-binding" href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LUSolverCache &lt;: LinearSolverCache</code></pre><p><strong>Keys</strong></p><ul><li><code>A</code>: the factorized matrix <code>A</code>,</li><li><code>pivots</code>:</li><li><code>perms</code>:</li><li><code>info</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL73-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LUSolverLAPACK"><a class="docstring-binding" href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LUSolverLAPACK &lt;: LinearSolver</code></pre><p>The LU Solver taken from <code>LinearAlgebra.BLAS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver_lapack.jl#LL4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearProblem"><a class="docstring-binding" href="#SimpleSolvers.LinearProblem"><code>SimpleSolvers.LinearProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearProblem</code></pre><p>A <code>LinearProblem</code> describes <span>$Ax = y$</span>, where we want to solve for <span>$x$</span>.</p><p><strong>Keys</strong></p><ul><li><code>A</code></li><li><code>y</code></li></ul><p><strong>Constructors</strong></p><p>A <code>LinearProblem</code> can be allocated by calling:</p><pre><code class="language-julia hljs">LinearProblem(A, y)
LinearProblem(A)
LinearProblem(y)
LinearProblem{T}(n, m)
LinearProblem{T}(n)</code></pre><p>Note that in any case the allocated system is initialized with <code>NaN</code>s:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 4. 5. 6.; 7. 8. 9.]
y = [1., 2., 3.]
ls = LinearProblem(A, y)

# output

LinearProblem{Float64, Vector{Float64}, Matrix{Float64}}([NaN NaN NaN; NaN NaN NaN; NaN NaN NaN], [NaN, NaN, NaN])</code></pre><p>In order to initialize the system with values, we have to call <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!</code></a>:</p><pre><code class="language-julia hljs">update!(ls, A, y)

# output

LinearProblem{Float64, Vector{Float64}, Matrix{Float64}}([1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0], [1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL11-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolver"><a class="docstring-binding" href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearSolver &lt;: AbstractSolver</code></pre><p>A struct that stores <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>s and <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>s. <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s are used to solve <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>s.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LinearSolver(method, cache)
LinearSolver(method, A)
LinearSolver(method, ls::LinearProblem)
LinearSolver(method, x)</code></pre><div class="admonition is-info" id="Info-ba84fd979e3e35af"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-ba84fd979e3e35af" title="Permalink"></a></header><div class="admonition-body"><p>We note that the constructors do not call the function <code>factorize</code>, so only allocate a new matrix. The factorization needs to be done manually.</p></div></div><p>You can manually factorize by either calling <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a> or <a href="#SimpleSolvers.solve!"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL5-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolverCache"><a class="docstring-binding" href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearSolverCache</code></pre><p>An abstract type that summarizes all the caches used for <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s. See e.g. <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solver_cache.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolverMethod"><a class="docstring-binding" href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearSolverMethod &lt;: SolverMethod</code></pre><p>Summarizes all the methods used for solving <em>linear systems of equations</em> such as the <a href="#SimpleSolvers.LU"><code>LU</code></a> method.</p><p><strong>Extended help</strong></p><p>The abstract type <code>SolverMethod</code> was imported from <code>GeometricBase</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solver_method.jl#LL1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Linesearch"><a class="docstring-binding" href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Linesearch</code></pre><p>A <code>struct</code> that stores the <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a> and <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul><p><strong>Constructors</strong></p><p>The following constructors can be used:</p><pre><code class="language-julia hljs">Linesearch(alg, config)
Linesearch(; algorithm, config, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/linesearch.jl#LL4-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinesearchMethod"><a class="docstring-binding" href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinesearchMethod</code></pre><p>Examples include <a href="#SimpleSolvers.Static"><code>Static</code></a>, <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>, <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a> and <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. See these examples for specific information on linesearch algorithms.</p><p><strong>Extended help</strong></p><p>A <code>LinesearchMethod</code> always has to be used together in <a href="#SimpleSolvers.Linesearch"><code>Linesearch</code></a> (or with <a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>solve</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/methods.jl#LL1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinesearchProblem"><a class="docstring-binding" href="#SimpleSolvers.LinesearchProblem"><code>SimpleSolvers.LinesearchProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinesearchProblem &lt;: AbstractOptimizerProblem</code></pre><p>Doesn&#39;t store <code>f</code>, <code>d</code>, <code>x_f</code> and <code>x_d</code>.</p><p>In practice <code>LinesearchProblem</code>s are allocated by calling <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>.</p><p><strong>Constructors</strong></p><div class="admonition is-warning" id="Calling-line-search-problems-bfa6d2dc34b76f76"><header class="admonition-header">Calling line search problems<a class="admonition-anchor" href="#Calling-line-search-problems-bfa6d2dc34b76f76" title="Permalink"></a></header><div class="admonition-body"><p>Below we show a few constructors that can be used to allocate <code>LinesearchProblem</code>s. Note however that in practice one probably should not do that and instead call <code>linesearch_problem</code>.</p></div></div><pre><code class="language-julia hljs">f(x) = x^2 - 1
g(x) = 2x
δx(x) = - g(x) / 2
x₀ = 3.
_f(α) = f(compute_new_iterate(x₀, α, δx(x₀)))
_d(α) = g(compute_new_iterate(x₀, α, δx(x₀)))
ls_obj = LinesearchProblem{typeof(x₀)}(_f, _d)

# output

LinesearchProblem{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Alternatively one can also do:</p><pre><code class="language-julia hljs">ls_obj = LinesearchProblem(_f, _d, x₀)

# output

LinesearchProblem{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Here we wrote <code>ls_obj</code> to mean <em>line search problem</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_problems.jl#LL21-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonMethod"><a class="docstring-binding" href="#SimpleSolvers.NewtonMethod"><code>SimpleSolvers.NewtonMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonMethod(refactorize)</code></pre><p>Make an instance of a <em>quasi Newton solver</em> based on an integer <em>refactorize</em> that determines how often the rhs is refactored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/methods.jl#LL7-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonOptimizerCache"><a class="docstring-binding" href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonOptimizerCache</code></pre><p><strong>Keys</strong></p><ul><li><code>x</code>: current iterate (this stores the guess called by the functions generated with <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>),</li><li><code>δ</code>: direction of optimization step (difference between <code>x</code> and <code>x̄</code>); this is obtained by multiplying <code>rhs</code> with the inverse of the Hessian,</li><li><code>g</code>: gradient value (this stores the gradient associated with <code>x</code> called by the <em>derivative part</em> of <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>),</li><li><code>rhs</code>: the right hand side used to compute the update.</li></ul><p>To understand how these are used in practice see e.g. <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>.</p><p>Also compare this to <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonOptimizerState"><a class="docstring-binding" href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonOptimizerState &lt;: OptimizerState</code></pre><p>The optimizer state is needed to update the <a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a>. This is different to <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> and <a href="update/#OptimizerResult"><code>OptimizerResult</code></a> which serve as diagnostic tools.</p><p>Note that this is also used for the <a href="#SimpleSolvers.BFGS"><code>BFGS</code></a> and the <a href="#SimpleSolvers.DFP"><code>DFP</code></a> optimizer.</p><p><strong>Keys</strong></p><ul><li><code>x̄</code></li><li><code>ḡ</code></li><li><code>f̄</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_state.jl#LL1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonSolver"><a class="docstring-binding" href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonSolver</code></pre><p>A <code>const</code> derived from <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a></p><p><strong>Constructors</strong></p><p>The <code>NewtonSolver</code> can be called with an <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> or with a <code>Callable</code>. Note however that the latter will probably be deprecated in the future.</p><p>What is shown here is the status of the <code>NewtonSolver</code>, i.e. an instance of <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>nonlinearproblem::</code><a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>: the system that has to be solved. This can be accessed by calling <a href="#SimpleSolvers.nonlinearproblem-Tuple{NonlinearSolver}"><code>nonlinearproblem</code></a>,</li><li><code>jacobian::</code><a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a></li><li><code>linear::</code><a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>: the linear solver is used to compute the <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.BFGSCache}"><code>direction</code></a> of the solver step (see <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>solver_step!</code></a>). This can be accessed by calling <a href="#SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><code>linearsolver</code></a>,</li><li><code>linesearch::</code><a href="#SimpleSolvers.Linesearch"><code>Linesearch</code></a></li><li><code>refactorize::Int</code>: determines after how many steps the Jacobian is updated and refactored (see <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>). If we have <code>refactorize &gt; 1</code>, then we speak of a <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a>,</li><li><code>cache::</code><a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/newton_solver.jl#LL1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NewtonSolver(x, F, y)</code></pre><p><strong>Keywords</strong></p><ul><li><code>linear_solver_method</code></li><li><code>DF!</code></li><li><code>linesearch</code></li><li><code>mode</code></li><li><code>options_kwargs</code>: see <a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/newton_solver.jl#LL40-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NoLinearProblem"><a class="docstring-binding" href="#SimpleSolvers.NoLinearProblem"><code>SimpleSolvers.NoLinearProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A <em>dummy linear system</em> used for the <em>fixed point iterator</em> (<a href="#SimpleSolvers.PicardMethod"><code>PicardMethod</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL6-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearMethod"><a class="docstring-binding" href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A supertype collecting all nonlinear methods, including <code>NewtonMethod</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/methods.jl#LL1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearProblem"><a class="docstring-binding" href="#SimpleSolvers.NonlinearProblem"><code>SimpleSolvers.NonlinearProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearProblem</code></pre><p>A <code>NonlinearProblem</code> describes <span>$F(x) = y$</span>, where we want to solve for <span>$x$</span> and <span>$F$</span> is in nonlinear in general (also compare this to <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> and <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>).</p><div class="admonition is-info" id="Info-314478d54e386025"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-314478d54e386025" title="Permalink"></a></header><div class="admonition-body"><p><code>NonlinearProblem</code>s are used for <em>solvers</em> whereas <code>OptimizerProblem</code>s are their equivalent for <em>optimizers</em>.</p></div></div><p><strong>Keys</strong></p><ul><li><code>F</code>: accessed by calling <code>Function(nlp)</code>,</li><li><code>J::Union{Callable, Missing}</code>: accessed by calling <code>jacobian(nlp)</code>,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_problem.jl#LL1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NonlinearProblem(F, x, f)</code></pre><p>Set <code>jacobian</code> <span>$\gets$</span> <code>missing</code> and call the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_problem.jl#LL26-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolver"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearSolver</code></pre><p>A <code>struct</code> that comprises <em>Newton solvers</em> (see <a href="#SimpleSolvers.NewtonMethod"><code>NewtonMethod</code></a>) and the <em>fixed point iterator</em> (see <a href="#SimpleSolvers.PicardMethod"><code>PicardMethod</code></a>).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NonlinearSolver(x, nlp, ls, linearsolver, linesearch, cache; method)</code></pre><p>The <code>NonlinearSolver</code> can be called with an <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> or with a <code>Callable</code>. Note however that the latter will probably be deprecated in the future. See <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> for examples (as well as <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>).</p><p>It&#39;s arguments are:</p><ul><li><code>nlp::</code><a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>: the system that has to be solved. This can be accessed by calling <a href="#SimpleSolvers.nonlinearproblem-Tuple{NonlinearSolver}"><code>nonlinearproblem</code></a>,</li><li><code>ls::</code><a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>,</li><li><code>linearsolver::</code><a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>: the linear solver is used to compute the <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.BFGSCache}"><code>direction</code></a> of the solver step (see <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>solver_step!</code></a>). This can be accessed by calling <a href="#SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><code>linearsolver</code></a>,</li><li><code>linesearch::</code><a href="#SimpleSolvers.Linesearch"><code>Linesearch</code></a></li><li><code>cache::</code><a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolverCache"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolverCache"><code>SimpleSolvers.NonlinearSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearSolverCache</code></pre><p>Stores <code>x</code>, <code>Δx</code>, <code>rhs</code>, <code>y</code>, and <code>J</code>.</p><p>Compare this to <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>x</code>: the next iterate (or <em>guess</em> thereof). The <em>guess</em> is computed when calling the functions created by <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>,</li><li><code>Δx</code>: search direction. This is updated when calling <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>solver_step!</code></a> via the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> stored in the <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>,</li><li><code>rhs</code>: the right-hand-side (this can be accessed by calling <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.BFGSCache}"><code>rhs</code></a>),</li><li><code>y</code>: the problem evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>,</li><li><code>j::AbstractMatrix</code>: the Jacobian evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>linesearch_problem</code></a>. Note that this is not of type <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a>!</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NonlinearSolverCache(x, y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_cache.jl#LL8-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolverState"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolverState"><code>SimpleSolvers.NonlinearSolverState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearSolverState(x, y)
NonlinearSolverState(x)
NonlinearSolverState{T}(n, m)
NonlinearSolverState{T}(n)</code></pre><p>The <code>NonlinearSolverState</code> to be used together with a <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a>.</p><div class="admonition is-category-warn" id="Warn-c0f51149e42fc5f3"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-c0f51149e42fc5f3" title="Permalink"></a></header><div class="admonition-body"><p>Note the difference to the <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a> and the <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_state.jl#LL1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolverStatus"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearSolverStatus</code></pre><p>Stores absolute, relative and successive residuals for <code>x</code> and <code>f</code>. It is used as a diagnostic tool in <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>iteration</code>: number of iterations</li><li><code>rxₛ</code>: successive residual in <code>x</code>,</li><li><code>rfₐ</code>: absolute residual in <code>f</code>,</li><li><code>rfₛ</code>: successive residual in <code>f</code>,</li><li><code>x_converged::Bool</code></li><li><code>f_converged::Bool</code></li><li><code>f_increased::Bool</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = [1., 2., 3., 4.]
state = NonlinearSolverState(x)
cache = NonlinearSolverCache(x, x)
config = Options()
NonlinearSolverStatus(state, config)

# output

i=   0,
rxₛ= NaN,
rfₐ= NaN,
rfₛ= NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_status.jl#LL1-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Optimizer"><a class="docstring-binding" href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Optimizer</code></pre><p>The optimizer that stores all the information needed for an optimization problem. This problem can be solved by calling <a href="#SimpleSolvers.solve!"><code>solve!(::AbstractVector, ::Optimizer)</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.OptimizerState"><code>OptimizerState</code></a>,</li><li><code>problem::</code><a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>,</li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a>,</li><li><code>state::</code><a href="#SimpleSolvers.OptimizerState"><code>OptimizerState</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer.jl#LL4-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerCache"><a class="docstring-binding" href="#SimpleSolvers.OptimizerCache"><code>SimpleSolvers.OptimizerCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerCache</code></pre><p>See <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> and <a href="#SimpleSolvers.BFGSCache"><code>BFGSCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_cache.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerMethod"><a class="docstring-binding" href="#SimpleSolvers.OptimizerMethod"><code>SimpleSolvers.OptimizerMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerMethod &lt;: SolverMethod</code></pre><p>The <code>OptimizerMethod</code> is used in <a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a> and determines the algorithm that is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/optimizer_methods.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerProblem"><a class="docstring-binding" href="#SimpleSolvers.OptimizerProblem"><code>SimpleSolvers.OptimizerProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerProblem &lt;: AbstractOptimizerProblem</code></pre><p>Stores <em>gradients</em>. Also compare this to <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>.</p><p>The type of the <em>stored gradient</em> has to be a subtype of <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Functor</strong></p><p>If <code>OptimizerProblem</code> is called on a single function, the gradient is generated with <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_problems.jl#LL71-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerResult"><a class="docstring-binding" href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerResult</code></pre><p>Stores <code>x</code>, <code>f</code> and <code>g</code> (as keys).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_result.jl#LL2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerState"><a class="docstring-binding" href="#SimpleSolvers.OptimizerState"><code>SimpleSolvers.OptimizerState</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An <code>OptimizerState</code> is a data structure that is used to dispatch on different algorithms.</p><p>It needs to implement three methods,</p><pre><code class="language-julia hljs">initialize!(alg::OptimizerState, ::AbstractVector)
update!(alg::OptimizerState, ::AbstractVector)
solver_step!(::AbstractVector, alg::OptimizerState)</code></pre><p>that initialize and update the state of the algorithm and perform an actual optimization step.</p><p>Further the following convenience methods should be implemented,</p><pre><code class="language-julia hljs">problem(alg::OptimizerState)
gradient(alg::OptimizerState)
hessian(alg::OptimizerState)
linesearch(alg::OptimizerState)</code></pre><p>which return the problem to optimize, its gradient and (approximate) Hessian as well as the linesearch algorithm used in conjunction with the optimization algorithm if any.</p><p>See <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> for a <code>struct</code> that was derived from <code>OptimizerState</code>.</p><div class="admonition is-info" id="Info-a16008e40022193"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-a16008e40022193" title="Permalink"></a></header><div class="admonition-body"><p>Note that a <code>OptimizerState</code> is not necessarily a <code>NewtonOptimizerState</code> as we can also have other optimizers, <em>Adam</em> for example.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_state.jl#LL1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerStatus"><a class="docstring-binding" href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizerStatus</code></pre><p>Contains residuals (relative and absolute) and various convergence properties.</p><p>See <a href="update/#OptimizerResult"><code>OptimizerResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_status.jl#LL1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerStatus-Union{Tuple{OCT}, Tuple{OST}, Tuple{T}, Tuple{OST, OCT, T}} where {T, OST&lt;:OptimizerState{T}, OCT&lt;:SimpleSolvers.OptimizerCache{T}}"><a class="docstring-binding" href="#SimpleSolvers.OptimizerStatus-Union{Tuple{OCT}, Tuple{OST}, Tuple{T}, Tuple{OST, OCT, T}} where {T, OST&lt;:OptimizerState{T}, OCT&lt;:SimpleSolvers.OptimizerCache{T}}"><code>SimpleSolvers.OptimizerStatus</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">residual!(status, state, cache, f)</code></pre><p>Compute the residual based on previous iterates (<code>x̄</code>, <code>f̄</code>, <code>ḡ</code>) (stored in e.g. <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a>) and current iterates (<code>x</code>, <code>f</code>, <code>g</code>) (partly stored in e.g. <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>).</p><p>Also <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_status.jl#LL38-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Options"><a class="docstring-binding" href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Options</code></pre><p><strong>Keys</strong></p><p>Configurable options with defaults (values 0 and NaN indicate unlimited):</p><ul><li><code>x_abstol = 2eps(T)</code>: absolute tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a> and <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>,</li><li><code>x_reltol = 2eps(T)</code>: relative tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>,</li><li><code>x_suctol = 2eps(T)</code>: succesive tolerance for <code>x</code>. Used in e.g. <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>,</li><li><code>f_abstol = zero(T)</code>: absolute tolerance for how close the function value should be to zero. See <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>. Used in e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>,</li><li><code>f_reltol = 2eps(T)</code>: relative tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>,</li><li><code>f_suctol = 2eps(T)</code>: succesive tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>,</li><li><code>f_mindec = T(10)^-4</code>: minimum value by which the function has to decrease (also see <a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>minimum_decrease_threshold</code></a>),</li><li><code>g_restol = 2eps(T)</code>: tolerance for the residual (?) of the gradient,</li><li><code>x_abstol_break = -Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>x_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_abstol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>.,</li><li><code>g_restol_break = Inf</code>,</li><li><code>allow_f_increases = true</code>,</li><li><code>min_iterations = 0</code>,</li><li><code>max_iterations = 1000</code>: the maximum number of iterations used in an alorithm, e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and the functor for <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>,</li><li><code>warn_iterations = 1000</code>,</li><li><code>show_trace = false</code>,</li><li><code>store_trace = false</code>,</li><li><code>extended_trace = false</code>,</li><li><code>show_every = 1</code>,</li><li><code>verbosity = 1</code></li><li><code>linesearch_nan_max_iterations = 10</code></li><li><code>linesearch_nan_factor = 0.5</code></li></ul><p>Some of the constants are defined by the functions <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> and <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/options.jl#LL107-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.PicardMethod"><a class="docstring-binding" href="#SimpleSolvers.PicardMethod"><code>SimpleSolvers.PicardMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PicardMethod()</code></pre><p>Make an instance of a <em>Picard solver</em> (fixed point iterator).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/methods.jl#LL25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Quadratic"><a class="docstring-binding" href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Quadratic &lt;: LinesearchMethod</code></pre><p>Quadratic Polynomial line search. Performs multiple iterations in which all parameters <span>$p_0$</span>, <span>$p_1$</span> and <span>$p_2$</span> are changed. This is different from the old <code>Quadratic</code> (taken from [<a href="references/#kelley1995iterative">1</a>]), where only <span>$p_2$</span> is changed. We further do not check the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> but rather whether the derivative is <em>small enough</em>.</p><div class="admonition is-warning" id="Warning-fe9aeb0dc5100d84"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-fe9aeb0dc5100d84" title="Permalink"></a></header><div class="admonition-body"><p>The old <code>Quadratic</code> was deprecated!</p></div></div><p>This algorithm repeatedly builds new quadratic polynomials until a minimum is found (to sufficient accuracy). The iteration may also stop after we reaches the maximum number of iterations (see <a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a>).</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>ε</code>: A constant that checks the <em>precision</em>/<em>tolerance</em>.</li><li><code>s</code>: A constant that determines the initial interval for bracketing. By default this is <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a>.</li><li><code>s_reduction:</code> A constant that determines the factor by which <code>s</code> is decreased in each new <em>bracketing iteration</em>.</li></ul><p><strong>Extended help</strong></p><p>The <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. The algorithm is adjusted from [<a href="references/#kelley1995iterative">1</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/quadratic.jl#LL33-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.QuasiNewtonOptimizerMethod"><a class="docstring-binding" href="#SimpleSolvers.QuasiNewtonOptimizerMethod"><code>SimpleSolvers.QuasiNewtonOptimizerMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuasiNewtonOptimizerMethod &lt;: OptimizerMethod</code></pre><p>Includes <a href="#SimpleSolvers.BFGS"><code>BFGS</code></a> and <a href="#SimpleSolvers.DFP"><code>DFP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/optimizer_methods.jl#LL8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Static"><a class="docstring-binding" href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Static &lt;: LinesearchMethod</code></pre><p>The <em>static</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Static(α)</code></pre><p><strong>Keys</strong></p><p>Keys include: -<code>α</code>: equivalent to a step size. The default is <code>1</code>.</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/static.jl#LL1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.SufficientDecreaseCondition"><a class="docstring-binding" href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SufficientDecreaseCondition &lt;: LinesearchCondition</code></pre><p>The condition that determines if <span>$\alpha_k$</span> is <em>big enough</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SufficientDecreaseCondition(c₁, xₖ, fₖ, gradₖ, pₖ, obj)</code></pre><p><strong>Functors</strong></p><pre><code class="language-julia hljs">sdc(xₖ₊₁, αₖ)
sdc(αₖ)</code></pre><p>The second functor is shorthand for <code>sdc(compute_new_iterate(sdc.xₖ, αₖ, sdc.pₖ), T(αₖ))</code>, also see <a href="#SimpleSolvers.compute_new_iterate!-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, VT, T, TVT}} where {T, VT, TVT}"><code>compute_new_iterate!</code></a>.</p><p><strong>Extended help</strong></p><p>We call the constant that pertains to the sufficient decrease condition <span>$c$</span>. This is typically called <span>$c_1$</span> in the literature [<a href="references/#nocedal2006numerical">3</a>]. See <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a> for the relevant constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/sufficient_decrease_condition.jl#LL1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(iterator, x, params)</code></pre><p>Update the <code>solver::</code><a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>FixedPointIterator</code></a> based on <code>x</code>. This updates the cache (instance of type <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>) and the status (instance of type <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>). In course of updating the latter, we also update the <code>nonlinear</code> stored in <code>iterator</code> (and <code>status(iterator)</code>).</p><div class="admonition is-info" id="Info-be10b41090faf66b"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-be10b41090faf66b" title="Permalink"></a></header><div class="admonition-body"><p>At the moment this is neither used in <code>solver_step!</code> nor <code>solve!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/fixed_point_iterator.jl#LL40-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{NewtonOptimizerState, Gradient, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{NewtonOptimizerState, Gradient, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(state::NewtonOptimizerState, gradient, x)</code></pre><p>Update an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> based on <code>x</code>, <code>g</code> and <code>hes</code>, where <code>g</code> can either be an <code>AbstractVector</code> or a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>hes</code> is a <a href="update/#Hessian"><code>Hessian</code></a>. This updates the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> contained in the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> by calling <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NewtonOptimizerCache, ::AbstractVector, ::Union{AbstractVector, Gradient}, ::Hessian)</code></a>.</p><p><strong>Examples</strong></p><p>We show that after initializing, update has to be called together with a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and a <a href="update/#Hessian"><code>Hessian</code></a>:</p><p>If we only call <code>update!</code> once there are still <code>NaN</code>s in the ...</p><pre><code class="language-julia hljs">f(x) = sum(x.^2)
x = [1., 2.]
state = NewtonOptimizerState(x)
grad = GradientAutodiff{Float64}(f, length(x))
update!(state, grad, x)

# output

NewtonOptimizerState{Float64, Vector{Float64}, Vector{Float64}}([1.0, 2.0], [2.0, 4.0], 0.0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_state.jl#LL39-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{NewtonSolver{T} where T, NonlinearSolverState, AbstractArray, Any}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{NewtonSolver{T} where T, NonlinearSolverState, AbstractArray, Any}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(solver, x, params)</code></pre><p>Update the <code>solver::</code><a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> based on <code>x</code>. This updates the cache (instance of type <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>) and the status (instance of type <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>). In course of updating the latter, we also update the <code>nonlinear</code> stored in <code>solver</code> (and <code>status(solver)</code>).</p><div class="admonition is-info" id="Info-be10b41090faf66b"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-be10b41090faf66b" title="Permalink"></a></header><div class="admonition-body"><p>At the moment this is neither used in <code>solver_step!</code> nor <code>solve!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/newton_solver.jl#LL103-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{Optimizer, OptimizerState, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{Optimizer, OptimizerState, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(opt, x)</code></pre><p>Compute problem and gradient at new solution.</p><p>This first calls <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a> and then <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NewtonOptimizerState, ::AbstractVector)</code></a>. We note that the <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> (unlike the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a>) is updated when calling <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer.jl#LL77-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(cache, x, g)</code></pre><p>Update the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code> and <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, Gradient, Hessian, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, OptimizerState, Gradient, Hessian, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(cache::NewtonOptimizerCache, x, g, hes)</code></pre><p>Update an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code>.</p><p>This is used in <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::OptimizerState, ::AbstractVector)</code></a>.</p><p>This sets:</p><p class="math-container">\[\bar{x}^\mathtt{cache} \gets x,
x^\mathtt{cache} \gets x,
g^\mathtt{cache} \gets g,
\mathrm{rhs}^\mathtt{cache} \gets -g,
\delta^\mathtt{cache} \gets H^{-1}\mathrm{rhs}^\mathtt{cache},\]</p><p>where we wrote <span>$H$</span> for the Hessian (i.e. the input argument <code>hes</code>).</p><p>Also see <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NonlinearSolverCache, ::AbstractVector)</code></a>.</p><div class="admonition is-warning" id="Warning-c2ea1ca399f3b263"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c2ea1ca399f3b263" title="Permalink"></a></header><div class="admonition-body"><p>Note that this is not updating the Hessian <code>hes</code>. For this call <code>update!</code> on the <code>Hessian</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL83-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(hessian, x)</code></pre><p>Update the <a href="update/#Hessian"><code>Hessian</code></a> based on the vector <code>x</code>. For an explicit example see e.g. <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::HessianAutodiff)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/hessian.jl#LL53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(ls, A, y)</code></pre><p>Set the <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.BFGSCache}"><code>rhs</code></a> vector to <code>y</code> and the matrix stored in <code>ls</code> to <code>A</code>.</p><div class="admonition is-info" id="Info-3962d3cc26bd7dbf"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-3962d3cc26bd7dbf" title="Permalink"></a></header><div class="admonition-body"><p>Calling <code>update!</code> doesn&#39;t solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>, you still have to call <code>solve!</code> in combination with a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL80-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.BFGSCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.BFGSCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(cache, x, g)</code></pre><p>Update the <a href="#SimpleSolvers.BFGSCache"><code>BFGSCache</code></a> based on <code>x</code> and <code>g</code>.</p><p><strong>Extended help</strong></p><p>The update rule used here can be found in [<a href="references/#kochenderfer2019algorithms">4</a>] and [<a href="references/#nocedal2006numerical">3</a>]:</p><p>What this is doing is:</p><p class="math-container">\[\begin{aligned}
\delta &amp; \gets x^{(k)} - x^{(k-1)}, \\
\gamma &amp; \gets \nabla{}f^{(k)} - \nabla{}f^{(k-1)}, \\
T_1 &amp; \gets \delta\gamma^TQ, \\
T_2 &amp; \gets Q\gamma\delta^T, \\
T_3 &amp; \gets (1 + \frac{gamma^TQ\gamma}{\delta^\gamma})\delta\delta^T,
Q &amp; \gets Q - (T_1 + T_2 - T_3)/{\delta^T\gamma}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_cache.jl#LL62-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.DFPCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.DFPCache{T}, SimpleSolvers.BFGSState{T, AT, GT, MT} where {AT&lt;:(AbstractArray{T}), GT&lt;:(AbstractArray{T}), MT&lt;:AbstractMatrix{T}}, AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(cache, x, g)</code></pre><p>Update the <a href="#SimpleSolvers.DFPCache"><code>DFPCache</code></a> based on <code>x</code> and <code>g</code>.</p><p><strong>Extended help</strong></p><p>The update rule used here can be found in [<a href="references/#kochenderfer2019algorithms">4</a>] and [<a href="references/#nocedal2006numerical">3</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_cache.jl#LL61-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><a class="docstring-binding" href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">value(obj::AbstractOptimizerProblem, x)</code></pre><p>Evaluates the value at <code>x</code> (i.e. computes <code>obj.F(x)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_problems.jl#LL12-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><a class="docstring-binding" href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ldiv!(x, lu, b)</code></pre><p>Compute <code>inv(cache(lsolver).A) * b</code> by utilizing the factorization of the lu solver (see <a href="#SimpleSolvers.LU"><code>LU</code></a> and <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) and store the result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL253-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.QuasiNewtonSolver-Tuple"><a class="docstring-binding" href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuasiNewtonSolver</code></pre><p>A convenience constructor for <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a>.</p><p>Calling <code>QuasiNewtonSolver</code> hence produces an instance of <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> with the difference that <code>refactorize ≠ 1</code>. The <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is thus not evaluated and refactored in every step.</p><p><strong>Implementation</strong></p><p>It does:</p><pre><code class="language-julia hljs">QuasiNewtonSolver(args...; kwargs...) = NewtonSolver(args...; refactorize=DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/newton_solver.jl#LL82-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers._static-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_static(A)</code></pre><p>Determine whether to allocate a <code>StaticArray</code> or simply copy the input array. This is used when calling <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> on <a href="#SimpleSolvers.LU"><code>LU</code></a>. Every matrix that is smaller or equal to <a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>N_STATIC_THRESHOLD</code></a> is turned into a <code>StaticArray</code> as a consequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL64-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">absolute_tolerance(T)</code></pre><p>Determine the absolute tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p>In comparison to <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>, this should return a very small number, close to zero (i.e. not just machine precision).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">absolute_tolerance(Float64)

# output

0.0</code></pre><pre><code class="language-julia hljs">absolute_tolerance(Float32)

# output

0.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/options.jl#LL36-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_d"><a class="docstring-binding" href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alloc_d(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the derivative of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/utils.jl#LL15-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_f"><a class="docstring-binding" href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alloc_f(x)</code></pre><p>Allocate <code>NaN</code>s of the size the size of <code>f</code> (evaluated at <code>x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/utils.jl#LL8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_g"><a class="docstring-binding" href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alloc_g(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the gradient of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/utils.jl#LL24-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_h"><a class="docstring-binding" href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alloc_h(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the Hessian of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/utils.jl#LL33-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_x"><a class="docstring-binding" href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alloc_x(x)</code></pre><p>Allocate <code>NaN</code>s of the size of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/utils.jl#LL1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><a class="docstring-binding" href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>SimpleSolvers.assess_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assess_convergence(rxₛ, rfₐ, rfₛ, config, cache, state)</code></pre><p>Check if one of the following is true for <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><ul><li><code>rxₛ ≤ config.x_suctol</code>,</li><li><code>rfₐ ≤ config.f_abstol</code>,</li><li><code>rfₛ ≤ config.f_suctol</code>.</li></ul><p>Also see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>. The tolerances are by default determined with <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_status.jl#LL61-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bisection-Tuple{Any, Number}"><a class="docstring-binding" href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bisection(f, x)</code></pre><p>Use <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> to find a starting interval and then do bisections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bisection.jl#LL79-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bisection(f, xmin, xmax; config)</code></pre><p>Perform bisection of <code>f</code> in the interval [<code>xmin</code>, <code>xmax</code>] with <a href="#SimpleSolvers.Options"><code>Options</code></a> <code>config</code>.</p><p>The algorithm is repeated until a root is found (up to tolerance <code>config.f_abstol</code> which is determined by <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> by default).</p><p><strong>implementation</strong></p><p>When calling <code>bisection</code> it first checks if <span>$x_\mathrm{min} &lt; x_\mathrm{max}$</span> and else flips the two entries.</p><p><strong>Extended help</strong></p><p>The bisection algorithm divides an interval into equal halves until a root is found (up to a desired accuracy).</p><p>We first initialize:</p><p class="math-container">\[\begin{aligned}
x_0 \gets &amp; x_\mathrm{min},
x_1 \gets &amp; x_\mathrm{max},
\end{aligned}\]</p><p>and then repeat:</p><p class="math-container">\[\begin{aligned}
&amp; x \gets \frac{x_0 + x_1}{2}, \\
&amp; \text{if $f(x_0)f(x) &gt; 0$} \\
&amp; \qquad x_0 \gets x, \\
&amp; \text{else} \\
&amp; \qquad x_1 \gets x, \\
&amp; \text{end}
\end{aligned}\]</p><p>So the algorithm checks in each step where the sign change occurred and moves the <span>$x_0$</span> or <span>$x_1$</span> accordingly. The loop is terminated (and errors) if <code>config.max_iterations</code> is reached (by default1000 and the <a href="#SimpleSolvers.Options"><code>Options</code></a> struct).</p><div class="admonition is-warning" id="Warning-71c199606f789e27"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-71c199606f789e27" title="Permalink"></a></header><div class="admonition-body"><p>The obvious danger with using bisections is that the supplied interval can have multiple roots (or no roots). One should be careful to avoid this when fixing the interval.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bisection.jl#LL1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bracket_minimum(f, x)</code></pre><p>Move a bracket successively in the search direction (starting at <code>x</code>) and increase its size until a local minimum of <code>f</code> is found.  This is used for performing <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>s when only one <code>x</code> is given (and not an entire interval).  This bracketing algorithm is taken from [<a href="references/#kochenderfer2019algorithms">4</a>]. Also compare it to <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>s::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a></li><li><code>k::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a></li><li><code>nmax::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a></li></ul><p><strong>Extended help</strong></p><p>For bracketing we need two constants <span>$s$</span> and <span>$k$</span> (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>). </p><p>Before we start the algorithm we <em>initialize</em> it, i.e. we check that we indeed have a descent direction:</p><p class="math-container">\[\begin{aligned}
&amp; a \gets x, \\
&amp; b \gets a + s, \\
&amp; \mathrm{if} \quad f(b) &gt; f(a)\\
&amp; \qquad\text{Flip $a$ and $b$ and set $s\gets-s$.}\\
&amp; \mathrm{end}
\end{aligned}\]</p><p>The algorithm then successively computes:</p><p class="math-container">\[c \gets b + s,\]</p><p>and then checks whether <span>$f(c) &gt; f(b)$</span>. If this is true it returns <span>$(a, c)$</span> or <span>$(c, a)$</span>, depending on whether <span>$a&lt;c$</span> or <span>$c&lt;a$</span> respectively. If this is not satisfied <span>$a,$</span> <span>$b$</span> and <span>$s$</span> are updated:</p><p class="math-container">\[\begin{aligned}
a \gets &amp; b, \\
b \gets &amp; c, \\
s \gets &amp; sk, 
\end{aligned}\]</p><p>and the algorithm is continued. If we have not found a sign chance after <span>$n_\mathrm{max}$</span> iterations (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a>) the algorithm is terminated and returns an error. The interval that is returned by <code>bracket_minimum</code> is then typically used as a starting point for <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p><div class="admonition is-info" id="Info-ca26305065bc9a9f"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-ca26305065bc9a9f" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>bracket_root</code> is equivalent to <code>bracket_minimum</code> with the only difference that the criterion we check for is:</p><p class="math-container">\[f(c)f(b) &lt; 0,\]</p><p>i.e. that a sign change in the function occurs.</p></div></div><p>See <a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_root</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL64-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bracket_minimum_with_fixed_point(f, x)</code></pre><p>Find a bracket while keeping the left side (i.e. <code>x</code>) fixed.  The algorithm is similar to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> (also based on <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>) with the difference that for the latter the left side is also moving.</p><p>The function <code>bracket_minimum_with_fixed_point</code> is used as a starting point for <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), as the minimum of the polynomial approximation is:</p><p class="math-container">\[p_2 = \frac{f(b) - f(a) - f&#39;(0)b}{b^2},\]</p><p>where <span>$b = \mathtt{bracket\_minimum\_with\_fixed\_point}(a)$</span>. We check that <span>$f(b) &gt; f(a)$</span> in order to ensure that the curvature of the polynomial (i.e. <span>$p_2$</span> is positive) and we have a minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL140-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bracket_root(f, x)</code></pre><p>Make a bracket for the function based on <code>x</code> (for root finding).</p><p>This is largely equivalent to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>. See the end of that docstring for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/bracket_minimum.jl#LL192-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.cache-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cache(ls)</code></pre><p>Return the cache (of type <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_gradient-Tuple{AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_gradient(g)</code></pre><p>Check norm, maximum value and minimum value of a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

g = [1., 1., 1., 2., 0.9, 3.]
SimpleSolvers.check_gradient(g; digits=3)

# output

norm(Gradient):               4.1
minimum(|Gradient|):          0.9
maximum(|Gradient|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/gradient.jl#LL48-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_hessian(H)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="update/#Hessian"><code>Hessian</code></a> <code>H</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

H = [1. √2.; √2. 3.]
SimpleSolvers.check_hessian(H)

# output

Condition Number of Hessian: 13.9282
Determinant of Hessian:      1.0
minimum(|Hessian|):          1.0
maximum(|Hessian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/hessian.jl#LL26-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_jacobian(J)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> <code>J</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

J = [1. √2.; √2. 3.]
SimpleSolvers.check_jacobian(J)

# output

Condition Number of Jacobian: 13.9282
Determinant of Jacobian:      1.0
minimum(|Jacobian|):          1.0
maximum(|Jacobian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/jacobian.jl#LL30-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><a class="docstring-binding" href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clear!(ls)</code></pre><p>Write <code>NaN</code>s into <code>Matrix(ls)</code> and <code>Vector(ls)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><a class="docstring-binding" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clear!(result)</code></pre><p>Clear all the information contained in <code>result::</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>. This also calls <a href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>clear!(::OptimizerStatus)</code></a>.</p><div class="admonition is-info" id="Info-f780c4b3a2e3124"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f780c4b3a2e3124" title="Permalink"></a></header><div class="admonition-body"></div></div><p>Calling <code>initialize!</code> on an <code>OptimizerResult</code> calls <code>clear!</code> internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_result.jl#LL19-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_new_iterate!-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, VT, T, TVT}} where {T, VT, TVT}"><a class="docstring-binding" href="#SimpleSolvers.compute_new_iterate!-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_new_iterate!(xₖ₊₁, xₖ, αₖ, pₖ)</code></pre><p>Compute <code>xₖ₊₁</code> based on a <em>direction</em> <code>pₖ</code> and a <em>step length</em> <code>αₖ</code>.</p><p><strong>Extended help</strong></p><p>In the case of vector spaces this function simply does:</p><pre><code class="language-julia hljs">xₖ = xₖ + αₖ * pₖ</code></pre><p>For manifolds we instead perform a <em>retraction</em> [<a href="references/#absil2008optimization">5</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/backtracking/condition.jl#LL10-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.convergence_measures-Tuple{SimpleSolvers.OptimizerStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.convergence_measures-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.convergence_measures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convergence_measures(status, config)</code></pre><p>Checks if the optimizer converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_status.jl#LL90-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.default_precision"><a class="docstring-binding" href="#SimpleSolvers.default_precision"><code>SimpleSolvers.default_precision</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_precision(T)</code></pre><p>Compute the default precision used for <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. Compare this to the <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> used in <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">default_precision(Float64)

# output

1.7763568394002505e-15</code></pre><pre><code class="language-julia hljs">default_precision(Float32)

# output

9.536743f-7</code></pre><pre><code class="language-julia hljs">default_precision(Float16)

# output

ERROR: No default precision defined for Float16.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bierlaire_quadratic.jl#LL24-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_tolerance(T)</code></pre><p>Determine the default tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">default_tolerance(Float64)

# output

4.440892098500626e-16</code></pre><pre><code class="language-julia hljs">default_tolerance(Float32)

# output

2.3841858f-7</code></pre><pre><code class="language-julia hljs">default_tolerance(Float16)

# output

Float16(0.001953)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/options.jl#LL1-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">determine_initial_α(y₀, obj, α₀)</code></pre><p>Check whether <code>α₀</code> satisfies the <a href="#SimpleSolvers.BracketMinimumCriterion"><code>BracketMinimumCriterion</code></a> for <code>obj</code>. If the criterion is not satisfied we call <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}}, Tuple{Union{Function, Type}, Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>. This is used as a starting point for using the functor of <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> and makes sure that <code>α</code> describes <em>a point past the minimum</em>.</p><div class="admonition is-warning" id="Warning-68e088a3e766d83c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-68e088a3e766d83c" title="Permalink"></a></header><div class="admonition-body"><p>This was used for the old <code>Quadratic</code> line search and seems to be not used anymore for <code>Quadratic</code> and other line searches.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/quadratic.jl#LL1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.direction-Tuple{SimpleSolvers.BFGSCache}"><a class="docstring-binding" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.direction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direction(cache)</code></pre><p>Return the direction of the gradient step (i.e. <code>δ</code>) of an instance of <a href="#SimpleSolvers.BFGSCache"><code>BFGSCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_cache.jl#LL45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.direction-Tuple{SimpleSolvers.DFPCache}"><a class="docstring-binding" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.direction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direction(cache)</code></pre><p>Return the direction of the gradient step (i.e. <code>δ</code>) of an instance of <a href="#SimpleSolvers.DFPCache"><code>DFPCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_cache.jl#LL44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">direction(::NewtonOptimizerCache)</code></pre><p>Return the direction of the gradient step (i.e. <code>Δx</code>) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL54-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.factorize!-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factorize!(lsolver)</code></pre><p>Factorize the matrix stored in the <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> in <code>lsolver</code>.</p><p>See <a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>factorize!(::LinearSolver{T, LUT}) where {T, LUT &lt;: LU}</code></a> for a concrete example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL31-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><a class="docstring-binding" href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">factorize!(lsolver::LinearSolver, A)</code></pre><p>Factorize the matrix <code>A</code> and store the result in <code>cache(lsolver).A</code>. Note that calling <code>cache</code> on <code>lsolver</code> returns the instance of <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a> stored in <code>lsolver</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]
x = similar(y)

lsolver = LinearSolver(LU(; static=false), x)
factorize!(lsolver, A)
cache(lsolver).A

# output

3×3 Matrix{Float64}:
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Here <code>cache(lsolver).A</code> stores the factorized matrix. If we call <code>factorize!</code> with two input arguments as above, the method first copies the matrix <code>A</code> into the <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>. We can equivalently also do:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]

lsolver = LinearSolver(LU(), A)
factorize!(lsolver)
cache(lsolver).A

# output

3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Also note the difference between the output types of the two refactorized matrices. This is because we set the keyword <code>static</code> to false when calling <a href="#SimpleSolvers.LU"><code>LU</code></a>. Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL141-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_maximum_value(v, k)</code></pre><p>Find the maximum value of vector <code>v</code> starting from the index <code>k</code>. This is used for <em>pivoting</em> in <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/lu_solver.jl#LL234-L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{SimpleSolvers.BFGSCache}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(cache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="#SimpleSolvers.BFGSCache"><code>BFGSCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_cache.jl#LL38-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{SimpleSolvers.DFPCache}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(cache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="#SimpleSolvers.DFPCache"><code>DFPCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_cache.jl#LL37-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(::NewtonOptimizerCache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL47-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.increase_iteration_number!-Tuple{NonlinearSolverState}"><a class="docstring-binding" href="#SimpleSolvers.increase_iteration_number!-Tuple{NonlinearSolverState}"><code>SimpleSolvers.increase_iteration_number!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">increase_iteration_number!(s)</code></pre><p>To be used together with <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_state.jl#LL42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(ls, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>ls</code>. See <a href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>clear!(::LinearProblem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_problem.jl#LL108-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(cache, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a> based on <code>x</code>.</p><p><strong>Implementation</strong></p><p>This calls <a href="#SimpleSolvers.alloc_x"><code>alloc_x</code></a> to do all the initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_cache.jl#LL58-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.isaOptimizerState-Tuple{Any}"><a class="docstring-binding" href="#SimpleSolvers.isaOptimizerState-Tuple{Any}"><code>SimpleSolvers.isaOptimizerState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isaOptimizerState(alg)</code></pre><p>Verify if an object implements the <a href="#SimpleSolvers.OptimizerState"><code>OptimizerState</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_state.jl#LL31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian(nlp::NonlinearProblem)</code></pre><p>Return the <em>Jacobian function</em> stored in <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_problem.jl#LL46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobianmatrix-Tuple{NonlinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.jacobianmatrix-Tuple{NonlinearSolver}"><code>SimpleSolvers.jacobianmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobianmatrix(solver::NewtonSolver)</code></pre><p>Return the evaluated Jacobian (a matrix) stored in the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> of <code>solver</code>.</p><p>Also see <a href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>jacobian(::NonlinearProblem)</code></a> and <a href="#SimpleSolvers.Jacobian"><code>Jacobian(::NonlinearProblem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL67-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><code>SimpleSolvers.linearsolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linearsolver(solver)</code></pre><p>Return the linear part (i.e. a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) of an <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = rand(3)
y = rand(3)
F(x) = tanh.(x)
F!(y, x, params) = y .= F(x)
s = NewtonSolver(x, y; F = F!)
linearsolver(s)

# output

LinearSolver{Float64, LU{Missing}, SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}}(LU{Missing}(missing, true), SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], [0, 0, 0], [0, 0, 0], 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL76-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, AbstractVector, Any}"><code>SimpleSolvers.linesearch_problem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linesearch_problem(nl::NonlinearSolver, state, params)</code></pre><p>Build a line search problem based on a <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a> (almost always a <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> in practice).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/linesearch_problem.jl#LL31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T}, Jacobian{T}, SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T}, Jacobian{T}, SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_problem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linesearch_problem(nlp, cache, params)</code></pre><p>Make a line search problem for a <em>Newton solver</em> (the <code>cache</code> here is an instance of <a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>).</p><p><strong>Implementation</strong></p><div class="admonition is-info" id="Producing-a-single-valued-output-ff084cc97d187aae"><header class="admonition-header">Producing a single-valued output<a class="admonition-anchor" href="#Producing-a-single-valued-output-ff084cc97d187aae" title="Permalink"></a></header><div class="admonition-body"><p>Different from the <code>linesearch_problem</code> for <code>NewtonOptimizerCache</code>s, we apply <code>L2norm</code> to the output of <code>problem!</code>. This is because the solver operates on an optimizer problem with multiple outputs from which we have to find roots, whereas an optimizer operates on an optimizer problem with a single output of which we should find a minimum.</p></div></div><p>Also see <a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T}, Gradient, SimpleSolvers.OptimizerCache{T}, OptimizerState}} where T"><code>linesearch_problem(::OptimizerProblem{T}, ::Gradient, ::OptimizerCache{T}, ::OptimizerState) where {T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/linesearch_problem.jl#LL1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T}, Gradient, SimpleSolvers.OptimizerCache{T}, OptimizerState}} where T"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T}, Gradient, SimpleSolvers.OptimizerCache{T}, OptimizerState}} where T"><code>SimpleSolvers.linesearch_problem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linesearch_problem(problem, cache)</code></pre><p>Create <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> for linesearch algorithm. The variable on which this problem depends is <span>$\alpha$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = [1, 0., 0.]
f = x -&gt; sum(x .^ 3 / 6 + x .^ 2 / 2)
obj = OptimizerProblem(f, x)
grad = GradientAutodiff{Float64}(obj.F, length(x))
cache = NewtonOptimizerCache(x)
state = NewtonOptimizerState(x)
state.x̄ .= x
hess = HessianAutodiff(obj, x)
update!(cache, state, grad, hess, x)
x₂ = [.9, 0., 0.]
update!(cache, state, grad, hess, x₂)
ls_obj = linesearch_problem(obj, grad, cache, state)
α = .1
(ls_obj.F(α), ls_obj.D(α))
x = [1, 0., 0.]
f = x -&gt; sum(x .^ 3 / 6 + x .^ 2 / 2)
obj = OptimizerProblem(f, x)
grad = GradientAutodiff{Float64}(obj.F, length(x))
cache = NewtonOptimizerCache(x)
state = NewtonOptimizerState(x)
state.x̄ .= x
hess = HessianAutodiff(obj, x)
update!(cache, state, grad, hess, x)
x₂ = [.9, 0., 0.]
update!(cache, state, grad, hess, x₂)
ls_obj = linesearch_problem(obj, grad, cache, state)
α = .1
(ls_obj.F(α), ls_obj.D(α))

# output

(0.5683038684544637, -0.9375328383328476)</code></pre><p>In the example above we have to apply <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!</code></a> twice on the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> because it needs to store the current <em>and</em> the previous iterate.</p><p><strong>Implementation</strong></p><p>Calling the function and derivative stored in the <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> created with <code>linesearch_problem</code> does not allocate a new array, but uses the one stored in the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_linesearch_problem.jl#LL1-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><a class="docstring-binding" href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Determines whether the iteration stops based on the current <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><div class="admonition is-warning" id="Warning-f98151b4cabbc3aa"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f98151b4cabbc3aa" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>meets_stopping_criteria</code> may return <code>true</code> even if the solver has not converged. To check convergence, call <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a> (with the same input arguments).</p></div></div><p>The function <code>meets_stopping_criteria</code> returns <code>true</code> if one of the following is satisfied:</p><ul><li>the <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> is converged (checked with <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>) and <code>iteration_number(status) ≥ config.min_iterations</code>,</li><li><code>status.f_increased</code> and <code>config.allow_f_increases = false</code> (i.e. <code>f</code> increased even though we do not allow it),</li><li><code>iteration_number(status) ≥ config.max_iterations</code>,</li><li>if any component in <code>solution(status)</code> is <code>NaN</code>,</li><li>if any component in <code>status.f</code> is <code>NaN</code>,</li><li><code>status.rxₐ &gt; config.x_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li><li><code>status.rfₐ &gt; config.f_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li></ul><p>So convergence is only one possible criterion for which <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{NonlinearSolverState, Options}"><code>meets_stopping_criteria</code></a>. We may also satisfy a stopping criterion without having convergence!</p><p><strong>Examples</strong></p><p>In the following example we show that <code>meets_stopping_criteria</code> evaluates to true when used on a freshly allocated <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><pre><code class="language-julia hljs">config = Options(verbosity=0)
x = [NaN, 2., 3.]
cache = NonlinearSolverCache(x, copy(x))
state = NonlinearSolverState(x)
status = NonlinearSolverStatus(state, config)
meets_stopping_criteria(state, config)

# output

false</code></pre><p>This obviously has not converged. To check convergence we can use <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_status.jl#LL109-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options, Integer}"><a class="docstring-binding" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options, Integer}"><code>SimpleSolvers.meets_stopping_criteria</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config, iterations)</code></pre><p>Check if the optimizer has converged.</p><p><strong>Implementation</strong></p><p><code>meets_stopping_criteria</code> checks if one of the following is true:</p><ul><li><code>converged</code> (the output of <a href="#SimpleSolvers.assess_convergence-Tuple{Number, Number, Number, Options, NonlinearSolverState}"><code>assess_convergence</code></a>) is <code>true</code> and <code>iterations</code> <span>$\geq$</span> <code>config.min_iterations</code>,</li><li>if <code>config.allow_f_increases</code> is <code>false</code>: <code>status.f_increased</code> is <code>true</code>,</li><li><code>iterations</code> <span>$\geq$</span> <code>config.max_iterations</code>,</li><li><code>status.rxₐ</code> <span>$&gt;$</span> <code>config.x_abstol_break</code></li><li><code>status.rxᵣ</code> <span>$&gt;$</span> <code>config.x_reltol_break</code></li><li><code>status.rfₐ</code> <span>$&gt;$</span> <code>config.f_abstol_break</code></li><li><code>status.rfᵣ</code> <span>$&gt;$</span> <code>config.f_reltol_break</code></li><li><code>status.rg</code>  <span>$&gt;$</span> <code>config.g_restol_break</code></li><li><code>status.x_isnan</code></li><li><code>status.f_isnan</code></li><li><code>status.g_isnan</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer_status.jl#LL109-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.method-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">method(ls)</code></pre><p>Return the method (of type <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL49-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimum_decrease_threshold(T)</code></pre><p>The minimum value by which a function <span>$f$</span> should decrease during an iteration.</p><p>The default value of <span>$10^-4$</span> is often used in the literature [bierlaire2015optimization], nocedal2006numerical(@cite).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">minimum_decrease_threshold(Float64)

# output

0.0001</code></pre><pre><code class="language-julia hljs">minimum_decrease_threshold(Float32)

# output

0.0001f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/base/options.jl#LL65-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.nonlinearproblem-Tuple{NonlinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.nonlinearproblem-Tuple{NonlinearSolver}"><code>SimpleSolvers.nonlinearproblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nonlinearproblem(solver)</code></pre><p>Return the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> contained in the <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a>. Compare this to <a href="#SimpleSolvers.linearsolver-Tuple{NonlinearSolver}"><code>linearsolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL58-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.print_status-Tuple{NonlinearSolverStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.print_status-Tuple{NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_status(status, config)</code></pre><p>Print the solver status if:</p><ol><li>The following three are satisfied: (i) <code>config.verbosity</code> <span>$\geq1$</span> (ii) <code>assess_convergence!(status, config)</code> is <code>false</code> (iii) <code>iteration_number(status) &gt; config.max_iterations</code></li><li><code>config.verbosity &gt; 1</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_status.jl#LL93-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.residuals-Tuple{NonlinearSolverState}"><a class="docstring-binding" href="#SimpleSolvers.residuals-Tuple{NonlinearSolverState}"><code>SimpleSolvers.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">residuals(cache, state)</code></pre><p>Compute the residuals for <code>cache::</code><a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>. The computed residuals are the following:</p><ul><li><code>rxₛ</code> : successive residual (the norm of <span>$\delta$</span>),</li><li><code>rfₐ</code>: absolute residual in <span>$f$</span>,</li><li><code>rfₛ</code> : successive residual (the norm of <span>$\Delta{}y$</span>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_status.jl#LL44-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.BFGSCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.BFGSCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="#SimpleSolvers.BFGSCache"><code>BFGSCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/bfgs/bfgs_cache.jl#LL31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.DFPCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.DFPCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="#SimpleSolvers.DFPCache"><code>DFPCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/iterative_hessians/dfp/dfp_cache.jl#LL30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/newton_optimizer/newton_optimizer_cache.jl#LL40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NonlinearSolverCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NonlinearSolverCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right-hand side of the equation, stored in <code>cache::</code><a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver_cache.jl#LL51-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_χ_to_avoid_stalling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shift_χ_to_avoid_stalling(χ, a, b, c, ε)</code></pre><p>Check whether <code>b</code> is closer to <code>a</code> or <code>c</code> and shift <code>χ</code> accordingly. This is taken from [<a href="references/#bierlaire2015optimization">2</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/bierlaire_quadratic.jl#LL105-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!"><a class="docstring-binding" href="#SimpleSolvers.solve!"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, s)</code></pre><p><strong>Extended help</strong></p><div class="admonition is-info" id="Info-b9c961a5b4c5910e"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-b9c961a5b4c5910e" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>update!</code> calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{NonlinearSolverState}"><code>increase_iteration_number!</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL131-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, A, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$A$</span> and <span>$b$</span> are provided as an input arguments.</p><p><strong>implementation</strong></p><p>Note that, compared to <a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>solve(::LinearSolver, ::AbstractVector)</code></a> this method involves an additional <em>factorization</em> of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL104-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$b$</span> is provided as an input argument and the factorized <span>$A$</span> is stored in the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> (respectively its <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL91-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, lsys::LinearProblem)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>lsys</code> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> and store the result in <code>x</code>. Also see <a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>solve!(::LinearSolver, ::LinearProblem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL72-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, OptimizerState, Optimizer}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, OptimizerState, Optimizer}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, state, opt)</code></pre><p>Solve the optimization problem described by <code>opt::</code><a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a> and store the result in <code>x</code>.</p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())
state = NewtonOptimizerState(x)

solve!(x, state, opt)

# output

SimpleSolvers.OptimizerResult{Float32, Float32, Vector{Float32}, SimpleSolvers.OptimizerStatus{Float32, Float32}}(
 * Convergence measures

    |x - x&#39;|               = 7.82e-03
    |x - x&#39;|/|x&#39;|          = 2.56e+02
    |f(x) - f(x&#39;)|         = 9.31e-10
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 1.00e+00
    |g(x) - g(x&#39;)|         = 1.57e-02
    |g(x)|                 = 6.10e-05

, Float32[4.6478817f-8, 3.0517578f-5], 9.313341f-10)</code></pre><p>We can also check how many iterations it took:</p><pre><code class="language-julia hljs">iteration_number(state)

# output

4</code></pre><p>Too see the value of <code>x</code> after one iteration confer the docstring of <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>solver_step!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer.jl#LL143-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(ls::LinearSolver, args...)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solvers.jl#LL82-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><a class="docstring-binding" href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(ls, method)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>ls</code> with the <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a> <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linear/linear_solver_method.jl#LL15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve-Union{Tuple{ALG}, Tuple{T}, Tuple{LinesearchProblem{T}, Linesearch{T, ALG, OPT} where OPT&lt;:Options{T}}} where {T, ALG&lt;:LinesearchMethod{T}}"><a class="docstring-binding" href="#SimpleSolvers.solve-Union{Tuple{ALG}, Tuple{T}, Tuple{LinesearchProblem{T}, Linesearch{T, ALG, OPT} where OPT&lt;:Options{T}}} where {T, ALG&lt;:LinesearchMethod{T}}"><code>SimpleSolvers.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(ls_prob, ls)
solve(ls_prob, ls_method)</code></pre><p>Minimize the <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> with the <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a> <code>ls_method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/linesearch/linesearch.jl#LL28-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{AbstractVector{T}, NonlinearSolver{T, MT, AT, NLST, LST, JT, LSoT, LiSeT, CT} where {MT&lt;:SimpleSolvers.NonlinearSolverMethod, AT, NLST&lt;:(NonlinearProblem{T}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:(Linesearch{T, ALG, OPT} where {ALG&lt;:LinesearchMethod{T}, OPT&lt;:Options{T}}), CT&lt;:(SimpleSolvers.NonlinearSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}})}, NonlinearSolverState{T, XT, YT} where {XT&lt;:AbstractVector{T}, YT&lt;:AbstractVector{T}}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solver_step!(x, s, state, params)</code></pre><p>Solve the problem stored in an instance <code>s</code> of <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_solver.jl#LL105-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, OptimizerState, Optimizer}} where VT&lt;:(AbstractVector)"><a class="docstring-binding" href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, OptimizerState, Optimizer}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solver_step!(x, state)</code></pre><p>Compute a full iterate for an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> <code>state</code>.</p><p>This also performs a line search.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())
state = NewtonOptimizerState(x)

solver_step!(x, state, opt)

# output

2-element Vector{Float32}:
 0.25
 0.6666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/optimization/optimizer.jl#LL91-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">triple_point_finder(f, x)</code></pre><p>Find three points <code>a &gt; b &gt; c</code> s.t. <code>f(a) &gt; f(b)</code> and <code>f(c) &gt; f(b)</code>. This is used for performing a quadratic line search (see <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>).</p><p><strong>Implementation</strong></p><p>For <code>δ</code> we take <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> as default. For <code>nmax we take [</code>DEFAULT<em>BRACKETING</em>nmax`](@ref) as default.</p><p><strong>Extended help</strong></p><p>The algorithm is taken from [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/bracketing/triple_point_finder.jl#LL3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.value!-Union{Tuple{T}, Tuple{AbstractArray{T}, NonlinearProblem{T}, AbstractArray{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{AbstractArray{T}, NonlinearProblem{T}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.value!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">value!(y, x, params)</code></pre><p>Evaluate the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/579fe7458b095b136dd9ac1c87060695b2910815/src/nonlinear/nonlinear_problem.jl#LL35-L39">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="optimizer_problems/">Optimizer Problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 22:20">Thursday 29 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
