<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SimpleSolvers.jl</title><meta name="title" content="Home · SimpleSolvers.jl"/><meta property="og:title" content="Home · SimpleSolvers.jl"/><meta property="twitter:title" content="Home · SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="objectives/">Objectives</a></li><li><a class="tocitem" href="gradients/">Gradients</a></li><li><a class="tocitem" href="jacobians/">Jacobians</a></li><li><a class="tocitem" href="hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="linesearch/linesearch/">Line Searches</a></li><li><a class="tocitem" href="linesearch/static/">Static</a></li><li><a class="tocitem" href="linesearch/sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="linesearch/curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="linesearch/backtracking/">Backtracking</a></li><li><a class="tocitem" href="linesearch/bisections/">Bisections</a></li><li><a class="tocitem" href="linesearch/quadratic/">Quadratic</a></li><li><a class="tocitem" href="linesearch/bierlaire_quadratic/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="update/">Updates</a></li><li><a class="tocitem" href="initialize/">Initialization</a></li><li><a class="tocitem" href="in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SimpleSolvers"><a class="docs-heading-anchor" href="#SimpleSolvers">SimpleSolvers</a><a id="SimpleSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleSolvers" title="Permalink"></a></h1><ul><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a></li><li><a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a></li><li><a href="#SimpleSolvers.F_ABSTOL"><code>SimpleSolvers.F_ABSTOL</code></a></li><li><a href="#SimpleSolvers.F_MINDEC"><code>SimpleSolvers.F_MINDEC</code></a></li><li><a href="#SimpleSolvers.F_RELTOL"><code>SimpleSolvers.F_RELTOL</code></a></li><li><a href="#SimpleSolvers.F_SUCTOL"><code>SimpleSolvers.F_SUCTOL</code></a></li><li><a href="#SimpleSolvers.G_RESTOL"><code>SimpleSolvers.G_RESTOL</code></a></li><li><a href="#SimpleSolvers.MAX_ITERATIONS"><code>SimpleSolvers.MAX_ITERATIONS</code></a></li><li><a href="#SimpleSolvers.X_ABSTOL"><code>SimpleSolvers.X_ABSTOL</code></a></li><li><a href="#SimpleSolvers.X_RELTOL"><code>SimpleSolvers.X_RELTOL</code></a></li><li><a href="#SimpleSolvers.X_SUCTOL"><code>SimpleSolvers.X_SUCTOL</code></a></li><li><a href="#SimpleSolvers.AbstractNewtonSolver"><code>SimpleSolvers.AbstractNewtonSolver</code></a></li><li><a href="#SimpleSolvers.AbstractObjective"><code>SimpleSolvers.AbstractObjective</code></a></li><li><a href="#SimpleSolvers.AbstractUnivariateObjective"><code>SimpleSolvers.AbstractUnivariateObjective</code></a></li><li><a href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a></li><li><a href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a></li><li><a href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a></li><li><a href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a></li><li><a href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a></li><li><a href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a></li><li><a href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a></li><li><a href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a></li><li><a href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a></li><li><a href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a></li><li><a href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a></li><li><a href="#SimpleSolvers.LUSolver"><code>SimpleSolvers.LUSolver</code></a></li><li><a href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a></li><li><a href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a></li><li><a href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a></li><li><a href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a></li><li><a href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a></li><li><a href="#SimpleSolvers.MultivariateObjective"><code>SimpleSolvers.MultivariateObjective</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a></li><li><a href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a></li><li><a href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a></li><li><a href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a></li><li><a href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a></li><li><a href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a></li><li><a href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a></li><li><a href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a></li><li><a href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a></li><li><a href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a></li><li><a href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a></li><li><a href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a></li><li><a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a></li><li><a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>SimpleSolvers.TemporaryUnivariateObjective</code></a></li><li><a href="#SimpleSolvers.UnivariateObjective"><code>SimpleSolvers.UnivariateObjective</code></a></li><li><a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_α</code></a></li><li><a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a></li><li><a href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a></li><li><a href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a></li><li><a href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a></li><li><a href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a></li><li><a href="#SimpleSolvers.alloc_j"><code>SimpleSolvers.alloc_j</code></a></li><li><a href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a></li><li><a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a></li><li><a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a></li><li><a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a></li><li><a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a></li><li><a href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a></li><li><a href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a></li><li><a href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a></li><li><a href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a></li><li><a href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative</code></a></li><li><a href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!</code></a></li><li><a href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!!</code></a></li><li><a href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.factorize!-Union{Tuple{T}, Tuple{LUSolver{T}, AbstractMatrix{T}}} where T"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{MultivariateObjective}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a></li><li><a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a></li><li><a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, SimpleSolvers.AbstractObjective}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{AbstractNewtonSolver}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.linearsolver-Tuple{AbstractNewtonSolver}"><code>SimpleSolvers.linearsolver</code></a></li><li><a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_objective</code></a></li><li><a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractObjective, Jacobian, SimpleSolvers.NewtonSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}}} where T"><code>SimpleSolvers.linesearch_objective</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.next_iteration!</code></a></li><li><a href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, Optimizer}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, T}, SimpleSolvers.AbstractObjective, Any, NewtonSolver{T, AT, OT, JT, TJ, TL, TLS, TST} where {AT, OT&lt;:SimpleSolvers.AbstractObjective, JT, TJ&lt;:Jacobian, TL, TLS&lt;:SimpleSolvers.LinesearchState, TST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}}} where T"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, SimpleSolvers.NewtonOptimizerState}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, Union{Function, Type}}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}"><code>SimpleSolvers.update!</code></a></li><li><a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a></li><li><a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>SimpleSolvers.value!!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_p" href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_p</code></pre><p>Constant used in <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_α₀" href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_α₀</code></pre><p>The default starting value for <span>$\alpha$</span> used in <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> (also see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). Its value is 1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_σ₀" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₀</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>.</p><p>It is meant to <em>safeguard against stagnation</em> when performing line searches (see [<a href="references/#kelley1995iterative">1</a>]).</p><p>Its value is 0.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_σ₁" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₁</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BIERLAIRE_ε" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ε</code></pre><p>A constant that determines the <em>precision</em> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. This constant is taken from [<a href="references/#bierlaire2015optimization">2</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bierlaire_quadratic.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BIERLAIRE_ξ" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ξ</code></pre><p>A constant on basis of which the <code>b</code> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a> is perturbed in order &quot;to avoid stalling&quot; (see [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1]). Its value is 1.0e-6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bierlaire_quadratic.jl#LL8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_k" href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_k</code></pre><p>Gives the default ratio by which the bracket is increased if bracketing was not successful. See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_nmax" href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Default constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_s" href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_s</code></pre><p>Gives the default width of the interval (the bracket). See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_GRADIENT_ϵ" href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_GRADIENT_ϵ</code></pre><p>A constant on whose basis finite differences are computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_JACOBIAN_ϵ" href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_JACOBIAN_ϵ</code></pre><p>A constant used for computing the finite difference Jacobian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_WOLFE_c₁" href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_WOLFE_c₁</code></pre><p>A constant <span>$\epsilon$</span> on which a finite difference approximation of the derivative of the objective is computed. This is then used in the following stopping criterion:</p><p class="math-container">\[\frac{f(\alpha) - f(\alpha_0)}{\epsilon} &lt; \alpha\cdot{}f&#39;(\alpha_0).\]</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL37-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.F_ABSTOL" href="#SimpleSolvers.F_ABSTOL"><code>SimpleSolvers.F_ABSTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Absolute tolerance for how close the function value should be to zero. Used in e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.F_MINDEC" href="#SimpleSolvers.F_MINDEC"><code>SimpleSolvers.F_MINDEC</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>minimum value by which the function has to decrease.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.F_RELTOL" href="#SimpleSolvers.F_RELTOL"><code>SimpleSolvers.F_RELTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>relative tolerance for the function value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.F_SUCTOL" href="#SimpleSolvers.F_SUCTOL"><code>SimpleSolvers.F_SUCTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>succesive tolerance for the function value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.G_RESTOL" href="#SimpleSolvers.G_RESTOL"><code>SimpleSolvers.G_RESTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>tolerance for the residual (?) of the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.MAX_ITERATIONS" href="#SimpleSolvers.MAX_ITERATIONS"><code>SimpleSolvers.MAX_ITERATIONS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The maximum number of iterations used in an alorithm, e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and the functor for <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.X_ABSTOL" href="#SimpleSolvers.X_ABSTOL"><code>SimpleSolvers.X_ABSTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>absolute tolerance for <code>x</code> (the function argument).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.X_RELTOL" href="#SimpleSolvers.X_RELTOL"><code>SimpleSolvers.X_RELTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>relative tolerance for <code>x</code> (the function argument).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.X_SUCTOL" href="#SimpleSolvers.X_SUCTOL"><code>SimpleSolvers.X_SUCTOL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>succesive tolerance for `x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.AbstractNewtonSolver" href="#SimpleSolvers.AbstractNewtonSolver"><code>SimpleSolvers.AbstractNewtonSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractNewtonSolver &lt;: NonlinearSolver</code></pre><p>A supertype that comprises e.g. <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.AbstractObjective" href="#SimpleSolvers.AbstractObjective"><code>SimpleSolvers.AbstractObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractObjective</code></pre><p>An <em>objective</em> is a quantity to has to be made zero by a solver or minimized by an optimizer.</p><p>See <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> and <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.AbstractUnivariateObjective" href="#SimpleSolvers.AbstractUnivariateObjective"><code>SimpleSolvers.AbstractUnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractUnivariateObjective &lt;: AbstractObjective</code></pre><p>A subtype of <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a> that only depends on one variable. See <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Backtracking" href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Backtracking &lt;: LinesearchMethod</code></pre><p>The <em>backtracking</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Backtracking()</code></pre><p><strong>Extended help</strong></p><p>The backtracking algorithm starts by setting <span>$y_0 \gets f(0)$</span> and <span>$d_0 \gets \nabla_0f$</span>.</p><p>The algorithm is executed by calling the functor of <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>.</p><p>The following is then repeated until the stopping criterion is satisfied or <code>config.max_iterations</code> (<a href="#SimpleSolvers.MAX_ITERATIONS"><code>MAX_ITERATIONS</code></a> by default) is reached:</p><pre><code class="language-julia hljs">if value!(obj, α) ≥ y₀ + ls.ϵ * α * d₀
    α *= ls.p
else
    break
end</code></pre><p>The stopping criterion as an equation can be written as:</p><p class="math-container">\[f(\alpha) &lt; y_0 + \epsilon \alpha \nabla_0f = y_0 + \epsilon (\alpha - 0)\nabla_0f.\]</p><p>Note that if the stopping criterion is not reached, <span>$\alpha$</span> is multiplied with <span>$p$</span> and the process continues.</p><p><a href="https://en.wikipedia.org/wiki/Backtracking_line_search">Sometimes</a> the parameters <span>$p$</span> and <span>$\epsilon$</span> have different names such as <span>$\tau$</span> and <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL18-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BacktrackingCondition" href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BacktrackingCondition</code></pre><p>Abstract type comprising the conditions that are used for checking step sizes for the backtracking line search (see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/condition.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BacktrackingState" href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BacktrackingState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>.</p><p><strong>Keys</strong></p><p>The keys are:</p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>α₀</code>: </li><li><code>ϵ=$(DEFAULT_WOLFE_c₁)</code>: a default step size on whose basis we compute a finite difference approximation of the derivative of the objective. Also see <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a>.</li><li><code>p=$(DEFAULT_ARMIJO_p)</code>: a parameter with which <span>$\alpha$</span> is decreased in every step until the stopping criterion is satisfied.</li></ul><p><strong>Functor</strong></p><p>The functor is used the following way:</p><pre><code class="language-julia hljs">ls(obj, α = ls.α₀)</code></pre><p><strong>Implementation</strong></p><p>The algorithm starts by setting:</p><p class="math-container">\[x_0 \gets 0,
y_0 \gets f(x_0),
d_0 \gets f&#39;(x_0),
\alpha \gets \alpha_0,\]</p><p>where <span>$f$</span> is the <em>univariate objective</em> (of type <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>) and <span>$\alpha_0$</span> is stored in <code>ls</code>. It then repeatedly does <span>$\alpha \gets \alpha\cdot{}p$</span> until either (i) the maximum number of iterations is reached (the <code>max_iterations</code> keyword in <a href="#SimpleSolvers.Options"><code>Options</code></a>) or (ii) the following holds:</p><p class="math-container">\[    f(\alpha) &lt; y_0 + \epsilon \cdot \alpha \cdot d_0,\]</p><p>where <span>$\epsilon$</span> is stored in <code>ls</code>.</p><div class="admonition is-info" id="Info-72fed8c52c6e36b1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-72fed8c52c6e36b1" title="Permalink"></a></header><div class="admonition-body"><p>The algorithm allocates an instance of <code>SufficientDecreaseCondition</code> by calling <code>SufficientDecreaseCondition(ls.ϵ, x₀, y₀, d₀, one(α), obj)</code>, here we take the <em>value one</em> for the search direction <span>$p$</span>, this is because we already have the search direction encoded into the line search objective.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/backtracking.jl#LL52-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BierlaireQuadratic" href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BierlaireQuadratic &lt;: LinesearchMethod</code></pre><p>Algorithm taken from [<a href="references/#bierlaire2015optimization">2</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BierlaireQuadraticState" href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BierlaireQuadraticState &lt;: LinesearchState</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bierlaire_quadratic.jl#LL16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Bisection" href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bisection &lt;: LinesearchMethod</code></pre><p>The <em>bisection</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Bisection()</code></pre><p><strong>Extended help</strong></p><p>The bisection algorithm starts with an interval and successively bisects it into smaller intervals until a root is found. See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL55-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BisectionState" href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BisectionState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>.</p><p>See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> for the implementation of the algorithm.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">BisectionState(options)
BisectionState(; options)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bisection.jl#LL86-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BracketMinimumCriterion" href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BracketMinimumCriterion &lt;: BracketingCriterion</code></pre><p>The criterion used for <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><p><strong>Functor</strong></p><pre><code class="language-julia hljs">bc(yb, yc)</code></pre><p>This checks whether <code>yc</code> is bigger than <code>yb</code>, i.e. whether <code>c</code> is <em>past the minimum</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.CurvatureCondition" href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CurvatureCondition &lt;: LinesearchCondition</code></pre><p>The second of the Wolfe conditions [<a href="references/#nocedal2006numerical">3</a>]. The first one is the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a>.</p><p>This encompasses the <em>standard curvature condition</em> and the <em>strong curvature condition</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CurvatureCondition(c, xₖ, gradₖ, pₖ, obj, grad; mode)</code></pre><p>Here <code>grad</code> has to be a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>obj</code> an <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a>. The other inputs are either arrays or numbers.</p><p><strong>Implementation</strong></p><p>For computational reasons <code>CurvatureCondition</code> also has a field <code>gradₖ₊₁</code> in which the temporary new gradient is saved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/curvature_condition.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Gradient" href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient</code></pre><p>Abstract type. <code>strcut</code>s that are derived from this need an assoicated functor that computes the gradient of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Gradient</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (grad::Gradient)(g::AbstractVector, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.GradientFunction"><code>GradientFunction</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientAutodiff" href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientAutodiff &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>∇config</code>: result of applying <code>ForwardDiff.GradientConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GradientAutodiff(F, x::AbstractVector)
GradientAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = ForwardDiff.gradient!(g, grad.F, x, grad.∇config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL139-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientFiniteDifferences" href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientFiniteDifferences &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>e</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">GradientFiniteDifferences{T}(F, nx::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>DEFAULT_GRADIENT_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x,g)
    ϵⱼ = grad.ϵ * x[j] + grad.ϵ
    fill!(grad.e, 0)
    grad.e[j] = 1
    grad.tx .= x .- ϵⱼ .* grad.e
    f1 = grad.F(grad.tx)
    grad.tx .= x .+ ϵⱼ .* grad.e
    f2 = grad.F(grad.tx)
    g[j] = (f2 - f1) / (2ϵⱼ)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL195-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientFunction" href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientFunction &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>∇F!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = grad.∇F!(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Hessian" href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian</code></pre><p>Abstract type. <code>struct</code>s derived from this need an associated functor that computes the Hessian of a function (in-place).</p><p>Also see <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Implementation</strong></p><p>When a custom <code>Hessian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (hessian::Hessian)(h::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.HessianFunction"><code>HessianFunction</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>HessianDFP</code></a></li></ul><p>These examples can also be called with e.g. <code>Hessian(x; mode = :autodiff)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianAutodiff" href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianAutodiff &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes <a href="update/#Hessian"><code>Hessian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>H</code>: a matrix in which the (updated) <a href="update/#Hessian"><code>Hessian</code></a> is stored. </li><li><code>Hconfig</code>: result of applying <code>ForwardDiff.HessianConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HessianAutodiff(F, x::AbstractVector)
HessianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(g, x) = ForwardDiff.hessian!(hes.H, hes.F, x, grad.Hconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL123-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianBFGS" href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianBFGS &lt;: Hessian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/hessian_bfgs.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianDFP" href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianDFP &lt;: Hessian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/hessian_dfp.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianFunction" href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianFunction &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes a <a href="update/#Hessian"><code>Hessian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>H!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(H, x) = hes.H!(H, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Jacobian" href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian</code></pre><p>Abstract type. <code>struct</code>s that are derived from this need an associated functor that computes the Jacobian of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Jacobian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (j::Jacobian)(g::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}}} where T"><code>compute_jacobian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.JacobianFunction"><code>JacobianFunction</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>JacobianFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianAutodiff" href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianAutodiff &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>Jconfig</code>: result of applying <code>ForwardDiff.JacobianConfig</code>.</li><li><code>ty</code>: vector that is used for evaluating <code>ForwardDiff.jacobian!</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">JacobianAutodiff(F, y::AbstractVector)
JacobianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(J, x) = ForwardDiff.jacobian!(J, jac.ty, x, grad.Jconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL104-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianFiniteDifferences" href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianFiniteDifferences &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>f1</code>:</li><li><code>f2</code>:</li><li><code>e1</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>e2</code>:</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">JacobianFiniteDifferences{T}(F, nx::Integer, ny::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>DEFAULT_JACOBIAN_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x)
    ϵⱼ = jac.ϵ * x[j] + jac.ϵ
    fill!(jac.e, 0)
    jac.e[j] = 1
    jac.tx .= x .- ϵⱼ .* jac.e
    f(jac.f1, jac.tx)
    jac.tx .= x .+ ϵⱼ .* jac.e
    f(jac.f2, jac.tx)
    for i in eachindex(x)
        J[i,j] = (jac.f2[i] - jac.f1[i]) / (2ϵⱼ)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL159-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianFunction" href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianFunction &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>DF!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(g, x) = jac.DF!(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL70-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LUSolver" href="#SimpleSolvers.LUSolver"><code>SimpleSolvers.LUSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LUSolver &lt;: LinearSolver</code></pre><p>A custom implementation of an LU solver.</p><p>Routines that use <code>LUSolver</code> include <a href="#SimpleSolvers.factorize!-Union{Tuple{T}, Tuple{LUSolver{T}, AbstractMatrix{T}}} where T"><code>factorize!</code></a> and <a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T"><code>ldiv!</code></a>. In practice the <code>LUSolver</code> is used by calling its constructor together with <a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T"><code>ldiv!</code></a> as shown in the <em>Example section</em> of this docstring.</p><p><strong>Example</strong></p><p>We use the <code>LUSolver</code> together with <a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T"><code>ldiv!</code></a> to compute multiplication of a matrix inverse onto a vector (from the left):</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]

lu = LUSolver(A)
v = rand(3)
x = similar(v)

ldiv!(x, lu, v) ≈ inv(A) * v

# output

true</code></pre><p>When calling <code>LUSolver</code> on an integer alone, a matrix with all zeros is allocated:</p><pre><code class="language-julia hljs">LUSolver{Float32}(2)

# output

LUSolver{Float32}(2, Float32[0.0 0.0; 0.0 0.0], [1, 2], [1, 2], 1)</code></pre><p><strong>Keys</strong></p><ul><li><code>n::Int</code></li><li><code>A::Matrix{T}</code></li><li><code>pivots::Vector{Int}</code></li><li><code>perms::Vector{Int}</code></li><li><code>info::Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/lu_solver.jl#LL1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LUSolverLAPACK" href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LUSolverLAPACK &lt;: LinearSolver</code></pre><p>The LU Solver taken from <code>LinearAlgebra.BLAS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/lu_solver_lapack.jl#LL5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinearSolver" href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSolver &lt;: AbstractSolver</code></pre><p>A supertype that comprises e.g. <a href="#SimpleSolvers.LUSolver"><code>LUSolver</code></a> and <a href="#SimpleSolvers.LUSolverLAPACK"><code>LUSolverLAPACK</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LinearSolver(x; linear_solver = :julia)</code></pre><p>The convenience constructor allocates a specific <code>struct</code> derived from <code>LinearSolver</code> based on what is supplied to <code>liner_solver</code>. The default <code>:julia</code> calls the constructor for <a href="#SimpleSolvers.LUSolver"><code>LUSolver</code></a>. Another option would be <code>:lapack</code> which calls <a href="#SimpleSolvers.LUSolverLAPACK"><code>LUSolverLAPACK</code></a> and uses the <code>LinearAlgebra.BLAS</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/linear_solvers.jl#LL2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Linesearch" href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Linesearch</code></pre><p>A <code>struct</code> that stores the <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a>, the <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>state::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li></ul><p><strong>Constructors</strong></p><p>The following constructors can be used:</p><pre><code class="language-julia hljs">Linesearch(alg, config, state)
Linesearch(; algorithm, config, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/linesearch.jl#LL50-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinesearchMethod" href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinesearchMethod</code></pre><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>, <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a> and <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. See these examples for specific information on linesearch algorithms.</p><p><strong>Extended help</strong></p><p>A <code>LinesearchMethod</code> always goes together with a <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and each of those <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a>s has a functor implemented:</p><pre><code class="language-julia hljs">ls(obj, α)</code></pre><p>where obj is a <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> and <code>α</code> is an initial <em>step size</em>. The output of this functor is then a final step size that is used for updating the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinesearchState" href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinesearchState</code></pre><p>Abstract type. </p><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>, <a href="#SimpleSolvers.BisectionState"><code>BisectionState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>.</p><p><strong>Implementation</strong></p><p>A <code>struct</code> that is subtyped from <code>LinesearchState</code> needs to implement the functors:</p><pre><code class="language-julia hljs">ls(x; kwargs...)
ls(obj::AbstractUnivariateObjective, x; kwargs...)</code></pre><p>Additionaly the following function needs to be extended:</p><pre><code class="language-julia hljs">LinesearchState(algorithm::LinesearchMethod; kwargs...)</code></pre><p><strong>Functors</strong></p><p>The following functors are auxiliary helper functions:</p><pre><code class="language-julia hljs">ls(f::Callable; kwargs...) = ls(TemporaryUnivariateObjective(f, missing); kwargs...)
ls(f::Callable, x::Number; kwargs...) = ls(TemporaryUnivariateObjective(f, missing), x; kwargs...)
ls(f::Callable, g::Callable; kwargs...) = ls(TemporaryUnivariateObjective(f, g); kwargs...)
ls(f::Callable, g::Callable, x::Number; kwargs...) = ls(TemporaryUnivariateObjective(f, g), x; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/linesearch.jl#LL4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.MultivariateObjective" href="#SimpleSolvers.MultivariateObjective"><code>SimpleSolvers.MultivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultivariateObjective &lt;: AbstractObjective</code></pre><p>Like <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>, but stores <em>gradients</em> instead of <em>derivatives</em>.</p><p>The type of the <em>stored gradient</em> has to be a subtype of <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Functor</strong></p><p>If <code>MultivariateObjective</code> is called on a single function, the gradient is generated with <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonOptimizerCache" href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonOptimizerCache</code></pre><p><strong>Keys</strong></p><ul><li><code>x̄</code>: the previous iterate,</li><li><code>x</code>: current iterate (this stores the guess called by the functions generated with <a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_objective</code></a>),</li><li><code>δ</code>: direction of optimization step (difference between <code>x</code> and <code>x̄</code>); this is obtained by multiplying <code>rhs</code> with the inverse of the Hessian,</li><li><code>g</code>: gradient value (this stores the gradient associated with <code>x</code> called by the <em>derivative part</em> of <a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_objective</code></a>),</li><li><code>rhs</code>: the right hand side used to compute the update.</li></ul><p>To understand how these are used in practice see e.g. <a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_objective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonOptimizerState" href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonOptimizerState &lt;: OptimizationAlgorithm</code></pre><p><strong>Keys</strong></p><ul><li><code>objective::</code><a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a></li><li><code>hessian::</code><a href="update/#Hessian"><code>Hessian</code></a></li><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>ls_objective</code></li><li><code>cache::</code><a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonSolver" href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonSolver</code></pre><p>A struct that comprises all Newton solvers. Those typically differ in the way the Jacobian is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/newton_solver.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonSolverCache" href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonSolverCache</code></pre><p>Stores <code>x₀</code>, <code>x₁</code>, <code>δx</code>, <code>rhs</code>, <code>y</code> and <code>J</code>.</p><p><strong>Keys</strong></p><p><code>δx</code>: search direction.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NewtonSolverCache(x, y)</code></pre><p><code>J</code> is allocated by calling <a href="#SimpleSolvers.alloc_j"><code>alloc_j</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearMethod" href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A supertype collecting all nonlinear methods, including <code>NewtonMethod</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/methods.jl#LL4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSolver" href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSolver &lt;: AbstractSolver</code></pre><p>A supertype that comprises e.g. <a href="#SimpleSolvers.AbstractNewtonSolver"><code>AbstractNewtonSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizationAlgorithm" href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OptimizationAlgorithm</code> is a data structure that is used to dispatch on different algorithms.</p><p>It needs to implement three methods,</p><pre><code class="nohighlight hljs">initialize!(alg::OptimizationAlgorithm, ::AbstractVector)
update!(alg::OptimizationAlgorithm, ::AbstractVector)
solver_step!(::AbstractVector, alg::OptimizationAlgorithm)</code></pre><p>that initialize and update the state of the algorithm and perform an actual optimization step.</p><p>Further the following convenience methods should be implemented,</p><pre><code class="nohighlight hljs">objective(alg::OptimizationAlgorithm)
gradient(alg::OptimizationAlgorithm)
hessian(alg::OptimizationAlgorithm)
linesearch(alg::OptimizationAlgorithm)</code></pre><p>which return the objective to optimize, its gradient and (approximate) Hessian as well as the linesearch algorithm used in conjunction with the optimization algorithm if any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer.jl#LL4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Optimizer" href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer.jl#LL44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizerResult" href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerResult</code></pre><p>Stores an <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> as well as <code>x</code>, <code>f</code> and <code>g</code> (as keys). <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> stores all other information (apart form <code>x</code> ,<code>f</code> and <code>g</code>); i.e. residuals etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_result.jl#LL2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizerStatus" href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerStatus</code></pre><p>Stores residuals (relative and absolute) and various convergence properties.</p><p>See <a href="update/#OptimizerResult"><code>OptimizerResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_status.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Options" href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configurable options with defaults (values 0 and NaN indicate unlimited):</p><ul><li><code>x_abstol = -Inf</code>,</li><li><code>x_reltol = 4.440892098500626e-16</code>,</li><li><code>x_suctol = 4.440892098500626e-16</code></li><li><code>f_abstol = 1.0e-50</code>,</li><li><code>f_reltol = 4.440892098500626e-16</code>,</li><li><code>f_suctol = 4.440892098500626e-16</code>,</li><li><code>f_mindec = 0.0001</code>,</li><li><code>g_restol = 1.4901161193847656e-8</code>,</li><li><code>x_abstol_break = Inf</code>,</li><li><code>x_reltol_break = Inf</code>,</li><li><code>f_abstol_break = Inf</code>,</li><li><code>f_reltol_break = Inf</code>,</li><li><code>g_restol_break = Inf</code>,</li><li><code>f_calls_limit = 0</code>,</li><li><code>g_calls_limit = 0</code>,</li><li><code>h_calls_limit = 0</code>,</li><li><code>allow_f_increases = true</code>,</li><li><code>min_iterations = 0</code>,</li><li><code>max_iterations = 1000</code>,</li><li><code>warn_iterations = 1000</code>,</li><li><code>show_trace = false</code>,</li><li><code>store_trace = false</code>,</li><li><code>extended_trace = false</code>,</li><li><code>show_every = 1</code>,</li><li><code>verbosity = 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/options.jl#LL37-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Quadratic" href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadractic &lt;: LinesearchMethod</code></pre><p>The <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Quadractic()</code></pre><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.QuadraticState" href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticState &lt;: LinesearchState</code></pre><p>Quadratic Polynomial line search.</p><p><em>Quadratic line search</em> works by fitting a polynomial to a univariate objective (see <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>) and then finding the minimum of that polynomial. Also compare this to <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>α₀</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>DEFAULT_ARMIJO_α₀</code></a></li><li><code>σ₀</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a></li><li><code>σ₁</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a></li><li><code>c</code>: by default <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/quadratic.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Static" href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Static &lt;: LinesearchMethod</code></pre><p>The <em>static</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Static(α)</code></pre><p><strong>Keys</strong></p><p>Keys include: -<code>α</code>: equivalent to a step size. The default is <code>1</code>.</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/methods.jl#LL95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.StaticState" href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticState &lt;: LinesearchState</code></pre><p>The state for <a href="#SimpleSolvers.Static"><code>Static</code></a>.</p><p><strong>Functors</strong></p><p>For a <code>Number</code> <code>a</code> and an <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> <code>obj</code> we have the following functors:</p><pre><code class="language-julia hljs">ls.(a) = ls.α
ls.(obj, a) = ls.α</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/static.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.SufficientDecreaseCondition" href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SufficientDecreaseCondition &lt;: LinesearchCondition</code></pre><p>The condition that determines if <span>$\alpha_k$</span> is <em>big enough</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SufficientDecreaseCondition(c₁, xₖ, fₖ, gradₖ, pₖ, obj)</code></pre><p><strong>Functors</strong></p><pre><code class="language-julia hljs">sdc(xₖ₊₁, αₖ)
sdc(αₖ)</code></pre><p>The second functor is shorthand for <code>sdc(compute_new_iterate(sdc.xₖ, αₖ, sdc.pₖ), T(αₖ))</code>, also see <a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>compute_new_iterate</code></a>.</p><p><strong>Extended help</strong></p><p>We call the constant that pertains to the sufficient decrease condition <span>$c$</span>. This is typically called <span>$c_1$</span> in the literature [<a href="references/#nocedal2006numerical">3</a>]. See <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a> for the relevant constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/sufficient_decrease_condition.jl#LL1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.TemporaryUnivariateObjective" href="#SimpleSolvers.TemporaryUnivariateObjective"><code>SimpleSolvers.TemporaryUnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporaryUnivariateObjective &lt;: AbstractUnivariateObjective</code></pre><p>Like <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> but doesn&#39;t store <code>f</code>, <code>d</code>, <code>x_f</code> and <code>x_d</code> as well as <code>f_calls</code> and <code>d_calls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.UnivariateObjective" href="#SimpleSolvers.UnivariateObjective"><code>SimpleSolvers.UnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnivariateObjective &lt;: AbstractUnivariateObjective</code></pre><p><strong>Keywords</strong></p><p>It stores the following:</p><ul><li><code>F</code>: objective</li><li><code>D</code>: derivative of objective</li><li><code>f</code>: cache for function output</li><li><code>d</code>: cache for derivative output</li><li><code>x_f</code>: x used to evaluate F (stored in f)</li><li><code>x_d</code>: x used to evaluate D (stored in d)</li><li><code>f_calls</code>: number of times <code>F</code> has been called</li><li><code>d_calls</code>: number of times <code>D</code> has been called</li></ul><p><strong>Constructor</strong></p><p>There are several constructors, the most generic (besides the default one) is:</p><pre><code class="language-julia hljs">UnivariateObjective(F, D, x; f, d)</code></pre><p>Where no keys are inferred, except <code>x_f</code> and <code>x_d</code> (via <a href="#SimpleSolvers.alloc_f"><code>alloc_f</code></a> and <a href="#SimpleSolvers.alloc_d"><code>alloc_d</code></a>). <code>f_calls</code> and <code>d_calls</code> are set to zero.</p><p>The most general constructor (i.e. the one the needs the least specification) is:</p><pre><code class="language-julia hljs">f(x::Number) = x ^ 2
UnivariateObjective(f, 1.)

# output

UnivariateObjective:

    f(x)              = NaN
    d(x)              = NaN
    x_f               = NaN
    x_d               = NaN
    number of f calls = 0
    number of d calls = 0</code></pre><p>where <code>ForwardDiff</code> is used to generate the derivative of the (anonymous) function.</p><p><strong>Functor</strong></p><p>The functor calls <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL21-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}" href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value(obj::AbstractObjective, x)</code></pre><p>Evaluates the objective value at <code>x</code> (i.e. computes <code>obj.F(x)</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

obj = UnivariateObjective(x::Number -&gt; x^2, 1.)
value(obj, 2.)
obj.f_calls

# output

1</code></pre><p>Note that the <code>f_calls</code> counter increased by one!</p><p>If <code>value</code> is called on <code>obj</code> (an <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a>) without supplying <code>x</code> than the output of the last <code>obj.F</code> call is returned:</p><pre><code class="language-julia hljs">using SimpleSolvers

obj = UnivariateObjective(x::Number -&gt; x^2, 1.)
value(obj)

# output

NaN</code></pre><p>In this example this is <code>NaN</code> since the function hasn&#39;t been called yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL108-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T" href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector{T}, LUSolver{T}, AbstractVector{T}}} where T"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldiv!(x, lu, b)</code></pre><p>Compute <code>inv(lu.A) * b</code> by utilizing the factorization in the <a href="#SimpleSolvers.LUSolver"><code>LUSolver</code></a> and store the result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/lu_solver.jl#LL156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T" href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjust_α(ls, αₜ, α)</code></pre><p>Check which conditions the new <code>αₜ</code> is in <span>$[\sigma_0\alpha_0, \simga_1\alpha_0]$</span> and return the updated <code>α</code> accordingly (it is updated if it does not lie in the interval).</p><p>We first check the following:</p><p class="math-container">\[    \alpha_t  &lt; \alpha_0\alpha,\]</p><p>where <span>$\sigma_0$</span> is stored in <code>ls</code> (i.e. in an instance of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). If this is not true we check:</p><p class="math-container">\[    \alpha_t &gt; \sigma_1\alpha,\]</p><p>where <span>$\sigma_1$</span> is again stored in <code>ls</code>. If this second condition is also not true we simply return the unchanged <span>$\alpha_t$</span>. So if <code>\alpha_t</code> does not lie in the interval <span>$(\sigma_0\alpha, \sigma_1\alpha)$</span> the interval is made bigger by either multiplying with <span>$\sigma_0$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a>) or <span>$\sigma_1$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/quadratic.jl#LL38-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T" href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjust_α(αₜ, α)</code></pre><p>Adjust <code>αₜ</code> based on the previous <code>α</code>. Also see <a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>adjust_α(::QuadraticState{T}, ::T, ::T) where {T}</code></a>.</p><p>The check that <span>$\alpha \in [\sigma_0\alpha_\mathrm{old}, \sigma_1\alpha_\mathrm{old}]$</span> should <em>safeguard against stagnation in the iterates</em> as well as checking that <span>$\alpha$</span> decreases at least by a factor <span>$\sigma_1$</span>. The defaults for <code>σ₀</code> and <code>σ₁</code> are <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a> respectively.</p><p><strong>Implementation</strong></p><p>Wee use defaults <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/quadratic.jl#LL59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_d" href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_d(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the derivative of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_f" href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_f(x)</code></pre><p>Allocate <code>NaN</code>s of the size the size of <code>f</code> (evaluated at <code>x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_g" href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_g(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the gradient of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_h" href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_h(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the Hessian of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_j" href="#SimpleSolvers.alloc_j"><code>SimpleSolvers.alloc_j</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_j(x, f)</code></pre><p>Allocate <code>NaN</code>s of the size of the Jacobian of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = rand(3)
fₓ = rand(2)
alloc_j(x, fₓ)

# output

2×3 Matrix{Float64}:
 NaN  NaN  NaN
 NaN  NaN  NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL52-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_x" href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_x(x)</code></pre><p>Allocate <code>NaN</code>s of the size of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/utils.jl#LL11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}" href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess_convergence!(status, config)</code></pre><p>Checks if the optimizer converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_status.jl#LL138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bisection-Tuple{Any, Number}" href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bisection(f, x)</code></pre><p>Use <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> to find a starting interval and then do bisections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bisection.jl#LL79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number" href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bisection(f, xmin, xmax; config)</code></pre><p>Perform bisection of <code>f</code> in the interval [<code>xmin</code>, <code>xmax</code>] with <a href="#SimpleSolvers.Options"><code>Options</code></a> <code>config</code>.</p><p>The algorithm is repeated until a root is found (up to tolerance <code>config.f_abstol</code> which is <a href="#SimpleSolvers.F_ABSTOL"><code>F_ABSTOL</code></a> by default).</p><p><strong>implementation</strong></p><p>When calling <code>bisection</code> it first checks if <span>$x_\mathrm{min} &lt; x_\mathrm{max}$</span> and else flips the two entries.</p><p><strong>Extended help</strong></p><p>The bisection algorithm divides an interval into equal halves until a root is found (up to a desired accuracy).</p><p>We first initialize:</p><p class="math-container">\[\begin{aligned}
x_0 \gets &amp; x_\mathrm{min},
x_1 \gets &amp; x_\mathrm{max},
\end{aligned}\]</p><p>and then repeat:</p><p class="math-container">\[\begin{aligned}
&amp; x \gets \frac{x_0 + x_1}{2}, \\
&amp; \text{if $f(x_0)f(x) &gt; 0$} \\
&amp; \qquad x_0 \gets x, \\
&amp; \text{else} \\
&amp; \qquad x_1 \gets x, \\
&amp; \text{end}
\end{aligned}\]</p><p>So the algorithm checks in each step where the sign change occurred and moves the <span>$x_0$</span> or <span>$x_1$</span> accordingly. The loop is terminated (and errors) if <code>config.max_iterations</code> is reached (see <a href="#SimpleSolvers.MAX_ITERATIONS"><code>MAX_ITERATIONS</code></a> and the <a href="#SimpleSolvers.Options"><code>Options</code></a> struct).</p><div class="admonition is-warning" id="Warning-2ade81735dfddc94"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2ade81735dfddc94" title="Permalink"></a></header><div class="admonition-body"><p>The obvious danger with using bisections is that the supplied interval can have multiple roots (or no roots). One should be careful to avoid this when fixing the interval.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/bisection.jl#LL1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_minimum(f, x)</code></pre><p>Move a bracket successively in the search direction (starting at <code>x</code>) and increase its size until a local minimum of <code>f</code> is found.  This is used for performing <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>s when only one <code>x</code> is given (and not an entire interval).  This bracketing algorithm is taken from [<a href="references/#kochenderfer2019algorithms">4</a>]. Also compare it to <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>s::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a></li><li><code>k::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a></li><li><code>nmax::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a></li></ul><p><strong>Extended help</strong></p><p>For bracketing we need two constants <span>$s$</span> and <span>$k$</span> (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>). </p><p>Before we start the algorithm we <em>initialize</em> it, i.e. we check that we indeed have a descent direction:</p><p class="math-container">\[\begin{aligned}
&amp; a \gets x, \\
&amp; b \gets a + s, \\
&amp; \mathrm{if} \quad f(b) &gt; f(a)\\
&amp; \qquad\text{Flip $a$ and $b$ and set $s\gets-s$.}\\
&amp; \mathrm{end}
\end{aligned}\]</p><p>The algorithm then successively computes:</p><p class="math-container">\[c \gets b + s,\]</p><p>and then checks whether <span>$f(c) &gt; f(b)$</span>. If this is true it returns <span>$(a, c)$</span> or <span>$(c, a)$</span>, depending on whether <span>$a&lt;c$</span> or <span>$c&lt;a$</span> respectively. If this is not satisfied <span>$a,$</span> <span>$b$</span> and <span>$s$</span> are updated:</p><p class="math-container">\[\begin{aligned}
a \gets &amp; b, \\
b \gets &amp; c, \\
s \gets &amp; sk, 
\end{aligned}\]</p><p>and the algorithm is continued. If we have not found a sign chance after <span>$n_\mathrm{max}$</span> iterations (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a>) the algorithm is terminated and returns an error. The interval that is returned by <code>bracket_minimum</code> is then typically used as a starting point for <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p><div class="admonition is-info" id="Info-d2bfb17d476806f1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-d2bfb17d476806f1" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>bracket_root</code> is equivalent to <code>bracket_minimum</code> with the only difference that the criterion we check for is:</p><p class="math-container">\[f(c)f(b) &lt; 0,\]</p><p>i.e. that a sign change in the function occurs.</p></div></div><p>See <a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_root</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL64-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_minimum_with_fixed_point(f, x)</code></pre><p>Find a bracket while keeping the left side (i.e. <code>x</code>) fixed.  The algorithm is similar to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> (also based on <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>) with the difference that for the latter the left side is also moving.</p><p>The function <code>bracket_minimum_with_fixed_point</code> is used as a starting point for <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), as the minimum of the polynomial approximation is:</p><p class="math-container">\[p_2 = \frac{f(b) - f(a) - f&#39;(0)b}{b^2},\]</p><p>where <span>$b = \mathtt{bracket\_minimum\_with\_fixed\_point}(a)$</span>. We check that <span>$f(b) &gt; f(a)$</span> in order to ensure that the curvature of the polynomial (i.e. <span>$p_2$</span> is positive) and we have a minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL140-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_root(f, x)</code></pre><p>Make a bracket for the function based on <code>x</code> (for root finding).</p><p>This is largely equivalent to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>. See the end of that docstring for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/bracket_minimum.jl#LL189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_gradient-Tuple{AbstractVector}" href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_gradient(g)</code></pre><p>Check norm, maximum value and minimum value of a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

g = [1., 1., 1., 2., 0.9, 3.]
SimpleSolvers.check_gradient(g; digits=3)

# output

norm(Gradient):               4.1
minimum(|Gradient|):          0.9
maximum(|Gradient|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL71-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_hessian-Tuple{AbstractMatrix}" href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_hessian(H)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="update/#Hessian"><code>Hessian</code></a> <code>H</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

H = [1. √2.; √2. 3.]
SimpleSolvers.check_hessian(H)

# output

Condition Number of Hessian: 13.9282
Determinant of Hessian:      1.0
minimum(|Hessian|):          1.0
maximum(|Hessian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL56-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}" href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_jacobian(J)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> <code>J</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

J = [1. √2.; √2. 3.]
SimpleSolvers.check_jacobian(J)

# output

Condition Number of Jacobian: 13.9282
Determinant of Jacobian:      1.0
minimum(|Jacobian|):          1.0
maximum(|Jacobian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL38-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Tuple{MultivariateObjective}" href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL390-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}" href="#SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_result.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_status.jl#LL49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_gradient!" href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_gradient!</code></pre><p>Alias for <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>. Will probably be deprecated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian!(h, x, ForH)</code></pre><p>Compute the hessian of function <code>ForH</code> at <code>x</code> and store it in <code>h</code>.</p><p><strong>Implementation</strong></p><p>Internally this allocates a <a href="update/#Hessian"><code>Hessian</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL238-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian!(h, x, hessian)</code></pre><p>Compute the Hessian and store it in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian-Tuple{Any, Hessian}" href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian(x, hessian)</code></pre><p>Compute the Hessian at point <code>x</code> and return the result.</p><p>Internally this calls <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}" href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>H</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> version.</p><p><strong>Implementation</strong></p><p>This is using <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a> with the keyword <code>mode</code> set to <code>autodiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}}} where T" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, jacobian::Jacobian)</code></pre><p>Apply the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> and store the result in <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}}} where T" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, ForJ)</code></pre><p>Allocate a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> object, apply it to <code>x</code>, and store the result in <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/jacobian.jl#LL252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}" href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_new_iterate(xₖ, αₖ, pₖ)</code></pre><p>Compute <code>xₖ₊₁</code> based on a <em>direction</em> <code>pₖ</code> and a <em>step length</em> <code>αₖ</code>.</p><p><strong>Extended help</strong></p><p>In the case of vector spaces this function simply does:</p><pre><code class="language-julia hljs">xₖ + αₖ * pₖ</code></pre><p>For manifolds we instead perform a <em>retraction</em> [<a href="references/#absil2008optimization">5</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/backtracking/condition.jl#LL10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative!!(obj::AbstractObjective, x)</code></pre><p>Similar to <a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>value!!</code></a>, but fo the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> and <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative!(obj, x)</code></pre><p>Similar to <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a>, but fo the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative(obj::AbstractObjective, x)</code></pre><p>Similar to <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a>, but for the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}} where T" href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">determine_initial_α(y₀, obj, α₀)</code></pre><p>Check whether <code>α₀</code> satisfies the <a href="#SimpleSolvers.BracketMinimumCriterion"><code>BracketMinimumCriterion</code></a> for <code>obj</code>. If the criterion is not satisfied we call <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>. This is used as a starting point for using the functor of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> and makes sure that <code>α</code> describes <em>a point past the minimum</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linesearch/quadratic.jl#LL80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direction(::NewtonOptimizerCache)</code></pre><p>Return the direction of the gradient step (i.e. <code>δ</code>) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.factorize!-Union{Tuple{T}, Tuple{LUSolver{T}, AbstractMatrix{T}}} where T" href="#SimpleSolvers.factorize!-Union{Tuple{T}, Tuple{LUSolver{T}, AbstractMatrix{T}}} where T"><code>SimpleSolvers.factorize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorize!(lu, A)</code></pre><p>Factorize the matrix <code>A</code> and store the result in <code>lu.A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
lu = LUSolver{Float64}(3, similar(A), zeros(Int, 3), zeros(Int, 3), 0)
factorize!(lu, A)
lu.A

# output

3×3 Matrix{Float64}:
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Here lu.A stores the factorized result. If we want to save this factorized matrix in the same <code>A</code> to save memory we can write:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
lu = LUSolver{Float64}(3, A, zeros(Int, 3), zeros(Int, 3), 0)
factorize!(lu, A)
A

# output

3×3 Matrix{Float64}:
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/lu_solver.jl#LL61-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number" href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_maximum_value(v, k)</code></pre><p>Find the maximum value of vector <code>v</code> starting from the index <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/linear/lu_solver.jl#LL138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}" href="#SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(obj::MultivariateObjective, x)</code></pre><p>Like <a href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>derivative!!</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL345-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}" href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient!(g, x, grad)</code></pre><p>Apply the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> <code>grad</code> to <code>x</code> and store the result in <code>g</code>.</p><p><strong>Implementation</strong></p><p>This is equivalent to doing</p><pre><code class="language-julia hljs">grad(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}" href="#SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>gradient!(obj::MultivariateObjective, x)</p><p>Like <a href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>derivative!</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL357-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{Any, Gradient}" href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(x, grad)</code></pre><p>Apply <code>grad</code> to <code>x</code> and return the result. </p><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{MultivariateObjective}" href="#SimpleSolvers.gradient-Tuple{MultivariateObjective}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(x, obj::MultivariateObjective)</code></pre><p>Like <a href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>derivative</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(::NewtonOptimizerCache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number" href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>gradient_fd!</code></a> for the finite differences version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}" href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_fd!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the autodiff version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/gradient.jl#LL261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increase_iteration_number!(status)</code></pre><p>Increase iteration number of <code>status</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
increase_iteration_number!(status)
status.i

# output

1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver_status.jl#LL86-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(hessian, x)</code></pre><p>See e.g. <a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>initialize!(::HessianAutodiff, ::AbstractVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(H, x)</code></pre><p>Initialize a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL177-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(cache, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>.</p><p><strong>Implementation</strong></p><p>This calls <a href="#SimpleSolvers.alloc_x"><code>alloc_x</code></a> to do all the initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, SimpleSolvers.AbstractObjective}" href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, SimpleSolvers.AbstractObjective}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(status, x, f)</code></pre><p>Clear <code>status</code> and initialize it based on <code>x</code> and the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver_status.jl#LL183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}" href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Verifies if an object implements the <a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer.jl#LL29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.jacobian-Tuple{AbstractNewtonSolver}" href="#SimpleSolvers.jacobian-Tuple{AbstractNewtonSolver}"><code>SimpleSolvers.jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(solver::AbstractNewtonSolver)</code></pre><p>Calling <code>jacobian</code> on an instance of <a href="#SimpleSolvers.AbstractNewtonSolver"><code>AbstractNewtonSolver</code></a> produces a slight ambiguity since the <code>cache</code> (of type <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>) also stores a Jacobian, but in the latter case it is a matrix not an instance of type <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a>. Hence we return the object of type <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> when calling <code>jacobian</code>. This is also used in <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, T}, SimpleSolvers.AbstractObjective, Any, NewtonSolver{T, AT, OT, JT, TJ, TL, TLS, TST} where {AT, OT&lt;:SimpleSolvers.AbstractObjective, JT, TJ&lt;:Jacobian, TL, TLS&lt;:SimpleSolvers.LinesearchState, TST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}}} where T"><code>solver_step!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linearsolver-Tuple{AbstractNewtonSolver}" href="#SimpleSolvers.linearsolver-Tuple{AbstractNewtonSolver}"><code>SimpleSolvers.linearsolver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linearsolver(solver)</code></pre><p>Return the linear part (i.e. a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) of an <a href="#SimpleSolvers.AbstractNewtonSolver"><code>AbstractNewtonSolver</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = rand(3)
y = rand(3)
F(x) = tanh.(x)
s = NewtonSolver(x, y; F = F)
linearsolver(s)

# output

LUSolver{Float64}(3, [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], [1, 2, 3], [1, 2, 3], 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL126-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T" href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linesearch_objective(objective, cache)</code></pre><p>Create <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a> for linesearch algorithm. The variable on which this objective depends is <span>$\alpha$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = [1, 0., 0.]
f = x -&gt; sum(x .^ 3 / 6 + x .^ 2 / 2)
obj = MultivariateObjective(f, x)
gradient!(obj, x)
value!(obj, x)
cache = NewtonOptimizerCache(x)
hess = Hessian(obj, x; mode = :autodiff)
update!(hess, x)
update!(cache, x, obj.g, hess)
x₂ = [.9, 0., 0.]
gradient!(obj, x₂)
value!(obj, x₂)
update!(hess, x₂)
update!(cache, x₂, obj.g, hess)
ls_obj = linesearch_objective(obj, cache)
α = .1
(ls_obj.F(α), ls_obj.D(α))

# output

(0.4412947468016475, -0.8083161485821551)</code></pre><p>In the example above we have to apply <a href="#SimpleSolvers.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!</code></a> twice on the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> because it needs to store the current <em>and</em> the previous iterate.</p><p><strong>Implementation</strong></p><p>Calling the function and derivative stored in the <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a> created with <code>linesearch_objective</code> does not allocate a new array, but uses the one stored in the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL105-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractObjective, Jacobian, SimpleSolvers.NewtonSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}}} where T" href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractObjective, Jacobian, SimpleSolvers.NewtonSolverCache{T, AT, JT} where {AT&lt;:AbstractVector{T}, JT&lt;:AbstractMatrix{T}}}} where T"><code>SimpleSolvers.linesearch_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linesearch_objective(objective!, jacobian!, cache)</code></pre><p>Make a line search objective for a <em>Newton solver</em> (the <code>cache</code> here is an instance of <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>).</p><p><strong>Implementation</strong></p><div class="admonition is-info" id="Producing-a-single-valued-output-1802c227a264436d"><header class="admonition-header">Producing a single-valued output<a class="admonition-anchor" href="#Producing-a-single-valued-output-1802c227a264436d" title="Permalink"></a></header><div class="admonition-body"><p>Different from the <code>linesearch_objective</code> for <code>NewtonOptimizerCache</code>s, we apply <code>l2norm</code> to the output of <code>objective!</code>. This is because the solver operates on an objective with multiple outputs from which we have to find roots, whereas an optimizer operates on an objective with a single output of which we should find a minimum.</p></div></div><p>Also see <a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_objective(::MultivariateObjective{T}, ::NewtonOptimizerCache{T}) where {T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Check if the optimizer has converged.</p><p><strong>Implementation</strong></p><p><code>meets_stopping_criteria</code> first calls <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>assess_convergence!</code></a> and then checks if one of the following is true:</p><ul><li><code>converged</code> (the output of <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>assess_convergence!</code></a>) is <code>true</code> and <code>status.i</code> <span>$\geq$</span> <code>config.min_iterations</code>,</li><li>if <code>config.allow_f_increases</code> is <code>false</code>: <code>status.f_increased</code> is <code>true</code>,</li><li><code>status.i</code> <span>$\geq$</span> <code>config.max_iterations</code>,</li><li><code>status.rxₐ</code> <span>$&gt;$</span> <code>config.x_abstol_break</code></li><li><code>status.rxᵣ</code> <span>$&gt;$</span> <code>config.x_reltol_break</code></li><li><code>status.rfₐ</code> <span>$&gt;$</span> <code>config.f_abstol_break</code></li><li><code>status.rfᵣ</code> <span>$&gt;$</span> <code>config.f_reltol_break</code></li><li><code>status.rg</code>  <span>$&gt;$</span> <code>config.g_restol_break</code></li><li><code>status.x_isnan</code></li><li><code>status.f_isnan</code></li><li><code>status.g_isnan</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_status.jl#LL168-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.next_iteration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">next_iteration!(status)</code></pre><p>Call <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!</code></a>, set <code>x̄</code> and <code>f̄</code> to <code>x</code> and <code>f</code> respectively and <code>δ</code> as well as <code>γ</code> to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver_status.jl#LL227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}" href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_status(status, config)</code></pre><p>Print the solver staus if:</p><ol><li>The following three are satisfied: (i) <code>config.verbosity</code> <span>$\geq1$</span> (ii) <code>assess_convergence!(status, config)</code> is <code>false</code> (iii) <code>status.i &gt; config.max_iterations</code></li><li><code>config.verbosity &gt; 1</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver_status.jl#LL72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}" href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(status, x, x̄, f, f̄, g, ḡ)</code></pre><p>Compute the residual based on previous iterates (<code>x̄</code>, <code>f̄</code>, <code>ḡ</code>) and current iterates (<code>x</code>, <code>f</code>, <code>g</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_status.jl#LL79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}" href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(result, x, f, g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_result.jl#LL30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{AbstractVector, Optimizer}" href="#SimpleSolvers.solve!-Tuple{AbstractVector, Optimizer}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(x, opt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer.jl#LL137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, T}, SimpleSolvers.AbstractObjective, Any, NewtonSolver{T, AT, OT, JT, TJ, TL, TLS, TST} where {AT, OT&lt;:SimpleSolvers.AbstractObjective, JT, TJ&lt;:Jacobian, TL, TLS&lt;:SimpleSolvers.LinesearchState, TST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}}} where T" href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, T}, SimpleSolvers.AbstractObjective, Any, NewtonSolver{T, AT, OT, JT, TJ, TL, TLS, TST} where {AT, OT&lt;:SimpleSolvers.AbstractObjective, JT, TJ&lt;:Jacobian, TL, TLS&lt;:SimpleSolvers.LinesearchState, TST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}}} where T"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver_step!(s)</code></pre><p>Compute one Newton step for <code>f</code> based on the Jacobian <code>jacobian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/newton_solver.jl#LL35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, SimpleSolvers.NewtonOptimizerState}} where VT&lt;:(AbstractVector)" href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{VT, SimpleSolvers.NewtonOptimizerState}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver_step!(x, newton)</code></pre><p>Compute a full iterate for an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> <code>newton</code>.</p><p>This also performs a line search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T" href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triple_point_finder(f, x)</code></pre><p>Find three points <code>a &gt; b &gt; c</code> s.t. <code>f(a) &gt; f(b)</code> and <code>f(c) &gt; f(b)</code>. This is used for performing a quadratic line search (see <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>).</p><p><strong>Implementation</strong></p><p>For <code>δ</code> we take <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> as default. For <code>nmax we take [</code>DEFAULT<em>BRACKETING</em>nmax`](@ref) as default.</p><p><strong>Extended help</strong></p><p>The algorithm is taken from [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/bracketing/triple_point_finder.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{HessianAutodiff, AbstractVector}" href="#SimpleSolvers.update!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(H, x)</code></pre><p>Update a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p>This is identical to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL191-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{Optimizer, AbstractVector}" href="#SimpleSolvers.update!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>compute objective and gradient at new solution and update result</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer.jl#LL129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}" href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(cache::NewtonOptimizerCache, x, g, hes)</code></pre><p>Update an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code>.</p><p>This sets:</p><p class="math-container">\[\bar{x}^\mathtt{cache} \gets x,
x^\mathtt{cache} \gets x,
g^\mathtt{cache} \gets g,
\mathrm{rhs}^\mathtt{cache} \gets -g,
\delta^\mathtt{cache} \gets H^{-1}\mathrm{rhs}^\mathtt{cache},\]</p><p>where we wrote <span>$H$</span> for the Hessian (i.e. the input argument <code>hes</code>). </p><p>Also see <a href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}"><code>update!(::NewtonSolverCache, ::AbstractVector)</code></a>. </p><p><strong>Implementation</strong></p><p>The multiplication by the inverse of <span>$H$</span> is done with <code>LinearAlgebra.ldiv!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL69-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector}" href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(newton::NewtonOptimizerState, x)</code></pre><p>Update an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> based on <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/newton_optimizer.jl#LL214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}" href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NewtonSolverCache, AbstractVector}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(cache, x)</code></pre><p>Update the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>, i.e.:</p><ol><li><code>cache.x₀</code> <span>$\gets$</span> x,</li><li><code>cache.x₁</code> <span>$\gets$</span> x,</li><li><code>cache.δx</code> <span>$\gets$</span> 0.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/abstract_newton_solver.jl#LL38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, Union{Function, Type}}" href="#SimpleSolvers.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, Union{Function, Type}}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(status, x, f)</code></pre><p>Update <code>status</code> based on <code>x</code> and the function <code>f</code>.</p><p>The new <code>x</code> and <code>x̄</code> stored in <code>status</code> are used to compute <code>δ</code>. The new <code>f</code> and <code>f̄</code> stored in <code>status</code> are used to compute <code>γ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/nonlinear/nonlinear_solver_status.jl#LL198-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}" href="#SimpleSolvers.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(result, x, f, g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/optimization/optimizer_result.jl#LL54-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian" href="#SimpleSolvers.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>SimpleSolvers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(hessian, x)</code></pre><p>Update the <a href="update/#Hessian"><code>Hessian</code></a> based on the vector <code>x</code>. For an explicit example see e.g. <a href="#SimpleSolvers.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::HessianAutodiff)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/hessian.jl#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}" href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>SimpleSolvers.value!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value!!(obj::AbstractObjective, x)</code></pre><p>Set <code>obj.x_f</code> to <code>x</code> and <code>obj.f</code> to <code>value(obj, x)</code> and return <code>value(obj)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}" href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value!(obj::AbstractObjective, x)</code></pre><p>Check if <code>x</code> is not equal to <code>obj.x_f</code> and then apply <a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>value!!</code></a>. Else simply return <code>value(obj)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/e7b739b30f16d4a3965ca91418316d7103268191/src/base/objectives.jl#LL160-L164">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="objectives/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 16 May 2025 16:03">Friday 16 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
