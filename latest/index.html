<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ SimpleSolvers.jl</title><meta name="title" content="Home ¬∑ SimpleSolvers.jl"/><meta property="og:title" content="Home ¬∑ SimpleSolvers.jl"/><meta property="twitter:title" content="Home ¬∑ SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="optimizer_problems/">Optimizer Problems</a></li><li><a class="tocitem" href="gradients/">Gradients</a></li><li><a class="tocitem" href="jacobians/">Jacobians</a></li><li><a class="tocitem" href="hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="linesearch/linesearch/">Line Searches</a></li><li><a class="tocitem" href="linesearch/static/">Static</a></li><li><a class="tocitem" href="linesearch/sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="linesearch/curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="linesearch/backtracking/">Backtracking</a></li><li><a class="tocitem" href="linesearch/bisections/">Bisections</a></li><li><a class="tocitem" href="linesearch/quadratic/">Quadratic</a></li><li><a class="tocitem" href="linesearch/bierlaire_quadratic/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="update/">Updates</a></li><li><a class="tocitem" href="initialize/">Initialization</a></li><li><a class="tocitem" href="linear/linear_solvers/">Linear Solvers</a></li><li><a class="tocitem" href="nonlinear_solver_status/">Solver Status</a></li><li><a class="tocitem" href="in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SimpleSolvers"><a class="docs-heading-anchor" href="#SimpleSolvers">SimpleSolvers</a><a id="SimpleSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleSolvers" title="Permalink"></a></h1><ul><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ"><code>SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œµ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_Œµ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œæ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_Œæ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a></li><li><a href="#SimpleSolvers.DEFAULT_GRADIENT_œµ"><code>SimpleSolvers.DEFAULT_GRADIENT_œµ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a></li><li><a href="#SimpleSolvers.DEFAULT_JACOBIAN_œµ"><code>SimpleSolvers.DEFAULT_JACOBIAN_œµ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><code>SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a></li><li><a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a></li><li><a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a></li><li><a href="#SimpleSolvers.AbstractLinearProblem"><code>SimpleSolvers.AbstractLinearProblem</code></a></li><li><a href="#SimpleSolvers.AbstractOptimizerProblem"><code>SimpleSolvers.AbstractOptimizerProblem</code></a></li><li><a href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a></li><li><a href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a></li><li><a href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a></li><li><a href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a></li><li><a href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a></li><li><a href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a></li><li><a href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a></li><li><a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.FixedPointIterator</code></a></li><li><a href="#SimpleSolvers.FixedPointIteratorCache"><code>SimpleSolvers.FixedPointIteratorCache</code></a></li><li><a href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a></li><li><a href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a></li><li><a href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a></li><li><a href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.Jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a></li><li><a href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a></li><li><a href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a></li><li><a href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a></li><li><a href="#SimpleSolvers.LinearProblem"><code>SimpleSolvers.LinearProblem</code></a></li><li><a href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a></li><li><a href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a></li><li><a href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a></li><li><a href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a></li><li><a href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a></li><li><a href="#SimpleSolvers.LinesearchProblem"><code>SimpleSolvers.LinesearchProblem</code></a></li><li><a href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a></li><li><a href="#SimpleSolvers.NewtonMethod"><code>SimpleSolvers.NewtonMethod</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a></li><li><a href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a></li><li><a href="#SimpleSolvers.NoLinearProblem"><code>SimpleSolvers.NoLinearProblem</code></a></li><li><a href="#SimpleSolvers.NoLinesearchState"><code>SimpleSolvers.NoLinesearchState</code></a></li><li><a href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a></li><li><a href="#SimpleSolvers.NonlinearProblem"><code>SimpleSolvers.NonlinearProblem</code></a></li><li><a href="#SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearProblem</code></a></li><li><a href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverCache"><code>SimpleSolvers.NonlinearSolverCache</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a></li><li><a href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a></li><li><a href="#SimpleSolvers.OptimizerProblem"><code>SimpleSolvers.OptimizerProblem</code></a></li><li><a href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a></li><li><a href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a></li><li><a href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a></li><li><a href="#SimpleSolvers.PicardMethod"><code>SimpleSolvers.PicardMethod</code></a></li><li><a href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a></li><li><a href="#SimpleSolvers.Quadratic2"><code>SimpleSolvers.Quadratic2</code></a></li><li><a href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a></li><li><a href="#SimpleSolvers.QuadraticState2"><code>SimpleSolvers.QuadraticState2</code></a></li><li><a href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a></li><li><a href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a></li><li><a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a></li><li><a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearProblem, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{Optimizer, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{OptimizerProblem, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{NewtonSolver{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a></li><li><a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a></li><li><a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a></li><li><a href="#SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_Œ±</code></a></li><li><a href="#SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_Œ±</code></a></li><li><a href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a></li><li><a href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a></li><li><a href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a></li><li><a href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a></li><li><a href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a></li><li><a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a></li><li><a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a></li><li><a href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a></li><li><a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a></li><li><a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a></li><li><a href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a></li><li><a href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a></li><li><a href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a></li><li><a href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{NonlinearProblem}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{OptimizerProblem}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a></li><li><a href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, JacobianFunction{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a></li><li><a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a></li><li><a href="#SimpleSolvers.determine_initial_Œ±-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><code>SimpleSolvers.determine_initial_Œ±</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.f_argument-Tuple{NonlinearProblem}"><code>SimpleSolvers.f_argument</code></a></li><li><a href="#SimpleSolvers.f_calls-Tuple{NonlinearProblem}"><code>SimpleSolvers.f_calls</code></a></li><li><a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{OptimizerProblem}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a></li><li><a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a></li><li><a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.j_argument-Tuple{NonlinearProblem}"><code>SimpleSolvers.j_argument</code></a></li><li><a href="#SimpleSolvers.j_calls-Tuple{NonlinearProblem}"><code>SimpleSolvers.j_calls</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian, AbstractArray{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.jacobian!</code></a></li><li><a href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.jacobian!!</code></a></li><li><a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.linearsolver</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_problem</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a></li><li><a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a></li><li><a href="#SimpleSolvers.nonlinearproblem-Tuple{FixedPointIterator{T} where T}"><code>SimpleSolvers.nonlinearproblem</code></a></li><li><a href="#SimpleSolvers.nonlinearproblem-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.nonlinearproblem</code></a></li><li><a href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.shift_œá_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_œá_to_avoid_stalling</code></a></li><li><a href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.solution</code></a></li><li><a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{NewtonSolver{T} where T, AbstractArray}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a></li><li><a href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.value!</code></a></li><li><a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a></li><li><a href="#SimpleSolvers.value!!-Tuple{LinesearchProblem, Number}"><code>SimpleSolvers.value!!</code></a></li></ul><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_p"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_p</code></pre><p>Constant used in <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>. Its value is 0.5</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL29-L34">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ"><code>SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_Œ±‚ÇÄ</code></pre><p>The default starting value for <span>$\alpha$</span> used in <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> (also see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). Its value is 1.0</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL2-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_œÉ‚ÇÄ</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a>.</p><p>It is meant to <em>safeguard against stagnation</em> when performing line searches (see [<a href="references/#kelley1995iterative">1</a>]).</p><p>Its value is 0.1</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL10-L18">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_œÉ‚ÇÅ</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a>. Its value is 0.5</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL21-L26">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BIERLAIRE_Œµ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œµ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_Œµ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_Œµ</code></pre><p>A constant that determines the <em>precision</em> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. The constant recommended in [<a href="references/#bierlaire2015optimization">2</a>] is <code>1E-3</code>.</p><p>Note that this constant may also depend on whether we deal with optimizers or solvers.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bierlaire_quadratic.jl#LL1-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BIERLAIRE_Œæ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œæ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_Œæ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_Œæ</code></pre><p>A constant on basis of which the <code>b</code> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a> is perturbed in order &quot;to avoid stalling&quot; (see [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1]; in this reference the author recommends <span>$10^{-7}$</span> as a value). Its value is 1.1920928955078125e-7.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bierlaire_quadratic.jl#LL10-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_k"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_k</code></pre><p>Gives the default ratio by which the bracket is increased if bracketing was not successful. See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL8-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_nmax"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><p>Default constant</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_BRACKETING_s"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_s</code></pre><p>Gives the default width of the interval (the bracket). See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_GRADIENT_œµ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_GRADIENT_œµ"><code>SimpleSolvers.DEFAULT_GRADIENT_œµ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">DEFAULT_GRADIENT_œµ</code></pre><p>A constant on whose basis finite differences are computed.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><p>The default number of iterations before the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is refactored in the <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/methods.jl#LL23-L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_JACOBIAN_œµ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_JACOBIAN_œµ"><code>SimpleSolvers.DEFAULT_JACOBIAN_œµ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">DEFAULT_JACOBIAN_œµ</code></pre><p>A constant used for computing the finite difference Jacobian.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><code>SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DEFAULT_WOLFE_c‚ÇÅ</code></pre><p>A constant <span>$\epsilon$</span> on which a finite difference approximation of the derivative of the problem is computed. This is then used in the following stopping criterion:</p><p class="math-container">\[\frac{f(\alpha) - f(\alpha_0)}{\epsilon} &lt; \alpha\cdot{}f&#39;(\alpha_0).\]</p><p><strong>Extended help</strong></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL37-L49">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.DEFAULT_s_REDUCTION"><a class="docstring-binding" href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><p>A factor by which <code>s</code> is reduced in each bracketing iteration (see <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/custom_quadratic.jl#LL6-L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><a class="docstring-binding" href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><p>This constant is used for <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> and <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/custom_quadratic.jl#LL1-L3">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.N_STATIC_THRESHOLD"><a class="docstring-binding" href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><div><p>Threshold for the maximum size a static matrix should have.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL59-L61">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.AbstractLinearProblem"><a class="docstring-binding" href="#SimpleSolvers.AbstractLinearProblem"><code>SimpleSolvers.AbstractLinearProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><p>Encompasses the <a href="#SimpleSolvers.NoLinearProblem"><code>NoLinearProblem</code></a> and the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL1-L3">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.AbstractOptimizerProblem"><a class="docstring-binding" href="#SimpleSolvers.AbstractOptimizerProblem"><code>SimpleSolvers.AbstractOptimizerProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">AbstractOptimizerProblem</code></pre><p>An <em>optimizer problem</em> is a quantity to has to be made zero by a solver or minimized by an optimizer.</p><p>See <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> and <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL1-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Backtracking"><a class="docstring-binding" href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Backtracking &lt;: LinesearchMethod</code></pre><p>The <em>backtracking</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Backtracking()</code></pre><p><strong>Extended help</strong></p><p>The backtracking algorithm starts by setting <span>$y_0 \gets f(0)$</span> and <span>$d_0 \gets \nabla_0f$</span>.</p><p>The algorithm is executed by calling the functor of <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>.</p><p>The following is then repeated until the stopping criterion is satisfied or <code>config.max_iterations</code> (1000 by default) is reached:</p><pre><code class="language-julia hljs">if value!(obj, Œ±) ‚â• y‚ÇÄ + ls.œµ * Œ± * d‚ÇÄ
    Œ± *= ls.p
else
    break
end</code></pre><p>The stopping criterion as an equation can be written as:</p><p class="math-container">\[f(lpha) &lt; y_0 + psilon lpha 
abla_0f = y_0 + psilon (lpha - 0)
abla_0f.\]</p><p>Note that if the stopping criterion is not reached, <span>$lpha$</span> is multiplied with <span>$p$</span> and the process continues.</p><p><a href="https://en.wikipedia.org/wiki/Backtracking_line_search">Sometimes</a> the parameters <span>$p$</span> and <span>$psilon$</span> have different names such as <span>$au$</span> and <span>$c$</span>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL18-L54">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BacktrackingCondition"><a class="docstring-binding" href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BacktrackingCondition</code></pre><p>Abstract type comprising the conditions that are used for checking step sizes for the backtracking line search (see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/condition.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BacktrackingState"><a class="docstring-binding" href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BacktrackingState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>.</p><p><strong>Keys</strong></p><p>The keys are:</p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>Œ±‚ÇÄ</code>: </li><li><code>œµ=$(DEFAULT_WOLFE_c‚ÇÅ)</code>: a default step size on whose basis we compute a finite difference approximation of the derivative of the problem. Also see <a href="#SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><code>DEFAULT_WOLFE_c‚ÇÅ</code></a>.</li><li><code>p=$(DEFAULT_ARMIJO_p)</code>: a parameter with which <span>$\alpha$</span> is decreased in every step until the stopping criterion is satisfied.</li></ul><p><strong>Functor</strong></p><p>The functor is used the following way:</p><pre><code class="language-julia hljs">ls(obj, Œ± = ls.Œ±‚ÇÄ)</code></pre><p><strong>Implementation</strong></p><p>The algorithm starts by setting:</p><p class="math-container">\[x_0 \gets 0,
y_0 \gets f(x_0),
d_0 \gets f&#39;(x_0),
\alpha \gets \alpha_0,\]</p><p>where <span>$f$</span> is the <em>univariate optimizer problem</em> (of type <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a>) and <span>$\alpha_0$</span> is stored in <code>ls</code>. It then repeatedly does <span>$\alpha \gets \alpha\cdot{}p$</span> until either (i) the maximum number of iterations is reached (the <code>max_iterations</code> keyword in <a href="#SimpleSolvers.Options"><code>Options</code></a>) or (ii) the following holds:</p><p class="math-container">\[    f(\alpha) &lt; y_0 + \epsilon \cdot \alpha \cdot d_0,\]</p><p>where <span>$\epsilon$</span> is stored in <code>ls</code>.</p><div class="admonition is-info" id="Info-f45ea34c7d883f1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f45ea34c7d883f1" title="Permalink"></a></header><div class="admonition-body"><p>The algorithm allocates an instance of <code>SufficientDecreaseCondition</code> by calling <code>SufficientDecreaseCondition(ls.œµ, x‚ÇÄ, y‚ÇÄ, d‚ÇÄ, one(Œ±), obj)</code>, here we take the <em>value one</em> for the search direction <span>$p$</span>, this is because we already have the search direction encoded into the line search problem.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/backtracking.jl#LL52-L91">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BierlaireQuadratic"><a class="docstring-binding" href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BierlaireQuadratic &lt;: LinesearchMethod</code></pre><p>Algorithm taken from [<a href="references/#bierlaire2015optimization">2</a>].</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL97-L101">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BierlaireQuadraticState"><a class="docstring-binding" href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BierlaireQuadraticState &lt;: LinesearchState</code></pre><p><strong>Extended help</strong></p><p>Note that the performance of <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a> may heavily depend on the choice of <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œµ"><code>DEFAULT_BIERLAIRE_Œµ</code></a> (i.e. the precision) and <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_Œæ"><code>DEFAULT_BIERLAIRE_Œæ</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bierlaire_quadratic.jl#LL18-L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Bisection"><a class="docstring-binding" href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Bisection &lt;: LinesearchMethod</code></pre><p>The <em>bisection</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Bisection()</code></pre><p><strong>Extended help</strong></p><p>The bisection algorithm starts with an interval and successively bisects it into smaller intervals until a root is found. See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL55-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BisectionState"><a class="docstring-binding" href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BisectionState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>.</p><p>See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> for the implementation of the algorithm.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">BisectionState(options)
BisectionState(; options)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bisection.jl#LL86-L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.BracketMinimumCriterion"><a class="docstring-binding" href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BracketMinimumCriterion &lt;: BracketingCriterion</code></pre><p>The criterion used for <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><p><strong>Functor</strong></p><pre><code class="language-julia hljs">bc(yb, yc)</code></pre><p>This checks whether <code>yc</code> is bigger than <code>yb</code>, i.e. whether <code>c</code> is <em>past the minimum</em>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL19-L30">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.CurvatureCondition"><a class="docstring-binding" href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">CurvatureCondition &lt;: LinesearchCondition</code></pre><p>The second of the Wolfe conditions [<a href="references/#nocedal2006numerical">3</a>]. The first one is the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a>.</p><p>This encompasses the <em>standard curvature condition</em> and the <em>strong curvature condition</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CurvatureCondition(c, x‚Çñ, grad‚Çñ, p‚Çñ, obj, grad; mode)</code></pre><p>Here <code>grad</code> has to be a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>obj</code> an <a href="#SimpleSolvers.AbstractOptimizerProblem"><code>AbstractOptimizerProblem</code></a>. The other inputs are either arrays or numbers.</p><p><strong>Implementation</strong></p><p>For computational reasons <code>CurvatureCondition</code> also has a field <code>grad‚Çñ‚Çä‚ÇÅ</code> in which the temporary new gradient is saved.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/curvature_condition.jl#LL1-L18">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.FixedPointIterator</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">FixedPointIterator(x, F)</code></pre><p><strong>Keywords</strong></p><ul><li><code>options_kwargs</code>: see <a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL25-L30">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.FixedPointIteratorCache"><a class="docstring-binding" href="#SimpleSolvers.FixedPointIteratorCache"><code>SimpleSolvers.FixedPointIteratorCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">FixedPointIteratorCache</code></pre><p>Stores the last solution <code>x‚Çñ</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Gradient"><a class="docstring-binding" href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Gradient</code></pre><p>Abstract type. <code>strcut</code>s that are derived from this need an assoicated functor that computes the gradient of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Gradient</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (grad::Gradient)(g::AbstractVector, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.GradientFunction"><code>GradientFunction</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL8-L28">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientAutodiff"><a class="docstring-binding" href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">GradientAutodiff &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>‚àáconfig</code>: result of applying <code>ForwardDiff.GradientConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GradientAutodiff(F, x::AbstractVector)
GradientAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = ForwardDiff.gradient!(g, grad.F, x, grad.‚àáconfig)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL139-L164">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientFiniteDifferences"><a class="docstring-binding" href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">GradientFiniteDifferences &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>œµ</code>: small constant on whose basis the finite differences are computed.</li><li><code>e</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">GradientFiniteDifferences{T}(F, nx::Integer; œµ)</code></pre><p>By default for <code>œµ</code> is <a href="#SimpleSolvers.DEFAULT_GRADIENT_œµ"><code>DEFAULT_GRADIENT_œµ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x,g)
    œµ‚±º = grad.œµ * x[j] + grad.œµ
    fill!(grad.e, 0)
    grad.e[j] = 1
    grad.tx .= x .- œµ‚±º .* grad.e
    f1 = grad.F(grad.tx)
    grad.tx .= x .+ œµ‚±º .* grad.e
    f2 = grad.F(grad.tx)
    g[j] = (f2 - f1) / (2œµ‚±º)
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL195-L232">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.GradientFunction"><a class="docstring-binding" href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">GradientFunction &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>‚àáF!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = grad.‚àáF!(g, x)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL104-L121">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Hessian"><a class="docstring-binding" href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Hessian</code></pre><p>Abstract type. <code>struct</code>s derived from this need an associated functor that computes the Hessian of a function (in-place).</p><p>Also see <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Implementation</strong></p><p>When a custom <code>Hessian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (hessian::Hessian)(h::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.HessianFunction"><code>HessianFunction</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>HessianDFP</code></a></li></ul><p>These examples can also be called with e.g. <code>Hessian(x; mode = :autodiff)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL1-L26">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianAutodiff"><a class="docstring-binding" href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">HessianAutodiff &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes <a href="update/#Hessian"><code>Hessian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>H</code>: a matrix in which the (updated) <a href="update/#Hessian"><code>Hessian</code></a> is stored. </li><li><code>Hconfig</code>: result of applying <code>ForwardDiff.HessianConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HessianAutodiff(F, x::AbstractVector)
HessianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(g, x) = ForwardDiff.hessian!(hes.H, hes.F, x, grad.Hconfig)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL123-L149">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianBFGS"><a class="docstring-binding" href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">HessianBFGS &lt;: Hessian</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/hessian_bfgs.jl#LL1-L3">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianDFP"><a class="docstring-binding" href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">HessianDFP &lt;: Hessian</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/hessian_dfp.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.HessianFunction"><a class="docstring-binding" href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">HessianFunction &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes a <a href="update/#Hessian"><code>Hessian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>H!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(H, x) = hes.H!(H, x)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL95-L112">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Jacobian"><a class="docstring-binding" href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Jacobian</code></pre><p>Abstract type. <code>struct</code>s that are derived from this need an associated functor that computes the Jacobian of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Jacobian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (j::Jacobian)(g::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, JacobianFunction{T}, Any}} where T"><code>compute_jacobian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.JacobianFunction"><code>JacobianFunction</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>JacobianFiniteDifferences</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL8-L28">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Jacobian-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.Jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.Jacobian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Jacobian(nlp::NonlinearProblem)</code></pre><p>Return the <em>Jacobian function</em> stored in <code>nlp</code>. Also see <a href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>jacobian(::NonlinearProblem)</code></a>.</p><div class="admonition is-category-warn" id="Warn-15de6b88744007fc"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-15de6b88744007fc" title="Permalink"></a></header><div class="admonition-body"></div></div><p>Note that this is different from the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> used in the <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a>! There the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is a separate <code>struct</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL226-L233">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianAutodiff"><a class="docstring-binding" href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">JacobianAutodiff &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>Jconfig</code>: result of applying <code>ForwardDiff.JacobianConfig</code>.</li><li><code>ty</code>: vector that is used for evaluating <code>ForwardDiff.jacobian!</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">JacobianAutodiff(F, y::AbstractVector)
JacobianAutodiff{T}(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(J, x) = ForwardDiff.jacobian!(J, jac.ty, x, grad.Jconfig)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL84-L110">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianFiniteDifferences"><a class="docstring-binding" href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">JacobianFiniteDifferences &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>œµ</code>: small constant on whose basis the finite differences are computed.</li><li><code>f1</code>:</li><li><code>f2</code>:</li><li><code>e1</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>e2</code>:</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">JacobianFiniteDifferences{T}(F, nx::Integer, ny::Integer; œµ)</code></pre><p>By default for <code>œµ</code> is <a href="#SimpleSolvers.DEFAULT_JACOBIAN_œµ"><code>DEFAULT_JACOBIAN_œµ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x)
    œµ‚±º = jac.œµ * x[j] + jac.œµ
    fill!(jac.e, 0)
    jac.e[j] = 1
    jac.tx .= x .- œµ‚±º .* jac.e
    f(jac.f1, jac.tx)
    jac.tx .= x .+ œµ‚±º .* jac.e
    f(jac.f2, jac.tx)
    for i in eachindex(x)
        J[i,j] = (jac.f2[i] - jac.f1[i]) / (2œµ‚±º)
    end
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL142-L184">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.JacobianFunction"><a class="docstring-binding" href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">JacobianFunction &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by explicitly supplying a function taken from the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>.</p><p><strong>Functor</strong></p><p>There is no functor associated to <code>JacobianFunction</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL65-L73">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LU"><a class="docstring-binding" href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct LU &lt;: LinearSolverMethod</code></pre><p>A custom implementation of an LU solver, meant to solve a <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>.</p><p>Routines that use the LU solver include <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>, <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> and <a href="#SimpleSolvers.solve!"><code>solve!</code></a>. In practice the <code>LU</code> solver is used by calling the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> constructor and <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> or <a href="#SimpleSolvers.solve!"><code>solve!</code></a>, or with an instance of <code>LU</code> as an argument directly, as shown in the <em>Example section</em> of this docstring.</p><p><strong>constructor</strong></p><p>The constructor is called with either no argument:</p><pre><code class="language-julia hljs">LU()

# output

LU{Missing}(missing, true)</code></pre><p>or with <code>pivot</code> and <code>static</code> as optional booleans:</p><pre><code class="language-julia hljs">LU(; pivot=true, static=true)

# output

LU{Bool}(true, true)</code></pre><p>Note that if we do not supply an explicit keyword <code>static</code>, the corresponding field is <code>missing</code> (as in the first case). Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p><p><strong>Example</strong></p><p>We use the <code>LU</code> together with <a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>solve</code></a> to solve a linear system:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
v = rand(3)
ls = LinearProblem(A, v)
update!(ls, A, v)

lu = LU()

solve(lu, ls) ‚âà inv(A) * v

# output

true</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL1-L51">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LUSolverCache"><a class="docstring-binding" href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LUSolverCache &lt;: LinearSolverCache</code></pre><p><strong>Keys</strong></p><ul><li><code>A</code>: the factorized matrix <code>A</code>,</li><li><code>pivots</code>:</li><li><code>perms</code>:</li><li><code>info</code></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL73-L81">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LUSolverLAPACK"><a class="docstring-binding" href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LUSolverLAPACK &lt;: LinearSolver</code></pre><p>The LU Solver taken from <code>LinearAlgebra.BLAS</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver_lapack.jl#LL4-L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearProblem"><a class="docstring-binding" href="#SimpleSolvers.LinearProblem"><code>SimpleSolvers.LinearProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinearProblem</code></pre><p>A <code>LinearProblem</code> describes <span>$Ax = y$</span>, where we want to solve for <span>$x$</span>.</p><p><strong>Keys</strong></p><ul><li><code>A</code></li><li><code>y</code></li></ul><p><strong>Constructors</strong></p><p>A <code>LinearProblem</code> can be allocated by calling:</p><pre><code class="language-julia hljs">LinearProblem(A, y)
LinearProblem)(A)
LinearProblem(y)
LinearProblem{T}(n, m)
LinearProblem{T}(n)</code></pre><p>Note that in any case the allocated system is initialized with <code>NaN</code>s:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 4. 5. 6.; 7. 8. 9.]
y = [1., 2., 3.]
ls = LinearProblem(A, y)

# output

LinearProblem{Float64, Vector{Float64}, Matrix{Float64}}([NaN NaN NaN; NaN NaN NaN; NaN NaN NaN], [NaN, NaN, NaN])</code></pre><p>In order to initialize the system with values, we have to call <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!</code></a>:</p><pre><code class="language-julia hljs">update!(ls, A, y)

# output

LinearProblem{Float64, Vector{Float64}, Matrix{Float64}}([1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0], [1.0, 2.0, 3.0])</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL11-L53">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolver"><a class="docstring-binding" href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinearSolver &lt;: AbstractSolver</code></pre><p>A struct that stores <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>s and <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>s. <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s are used to solve <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>s.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LinearSolver(method, cache)
LinearSolver(method, A)
LinearSolver(method, ls::LinearProblem)
LinearSolver(method, x)</code></pre><div class="admonition is-info" id="Info-ba84fd979e3e35af"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-ba84fd979e3e35af" title="Permalink"></a></header><div class="admonition-body"><p>We note that the constructors do not call the function <code>factorize</code>, so only allocate a new matrix. The factorization needs to be done manually.</p></div></div><p>You can manually factorize by either calling <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a> or <a href="#SimpleSolvers.solve!"><code>solve!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL5-L23">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolverCache"><a class="docstring-binding" href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinearSolverCache</code></pre><p>An abstract type that summarizes all the caches used for <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s. See e.g. <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solver_cache.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinearSolverMethod"><a class="docstring-binding" href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinearSolverMethod &lt;: SolverMethod</code></pre><p>Summarizes all the methods used for solving <em>linear systems of equations</em> such as the <a href="#SimpleSolvers.LU"><code>LU</code></a> method.</p><p><strong>Extended help</strong></p><p>The abstract type <code>SolverMethod</code> was imported from <code>GeometricBase</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solver_method.jl#LL1-L9">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Linesearch"><a class="docstring-binding" href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Linesearch</code></pre><p>A <code>struct</code> that stores the <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a>, the <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>state::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li></ul><p><strong>Constructors</strong></p><p>The following constructors can be used:</p><pre><code class="language-julia hljs">Linesearch(alg, config, state)
Linesearch(; algorithm, config, kwargs...)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/linesearch.jl#LL56-L75">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinesearchMethod"><a class="docstring-binding" href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinesearchMethod</code></pre><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>, <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a> and <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. See these examples for specific information on linesearch algorithms.</p><p><strong>Extended help</strong></p><p>A <code>LinesearchMethod</code> always goes together with a <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and each of those <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a>s has a functor implemented:</p><pre><code class="language-julia hljs">ls(obj, Œ±)</code></pre><p>where obj is a <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> and <code>Œ±</code> is an initial <em>step size</em>. The output of this functor is then a final step size that is used for updating the parameters.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL1-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinesearchProblem"><a class="docstring-binding" href="#SimpleSolvers.LinesearchProblem"><code>SimpleSolvers.LinesearchProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinesearchProblem &lt;: AbstractOptimizerProblem</code></pre><p>Doesn&#39;t store <code>f</code>, <code>d</code>, <code>x_f</code> and <code>x_d</code> as well as <code>f_calls</code> and <code>d_calls</code>.</p><p>In practice <code>LinesearchProblem</code>s are allocated by calling <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>.</p><p><strong>Constructors</strong></p><div class="admonition is-category-warn" id="Calling-line-search-problems-cb92926832f65238"><header class="admonition-header">Calling line search problems<a class="admonition-anchor" href="#Calling-line-search-problems-cb92926832f65238" title="Permalink"></a></header><div class="admonition-body"><p>Below we show a few constructors that can be used to allocate <code>LinesearchProblem</code>s. Note however that in practice one probably should not do that and instead call <code>linesearch_problem</code>.</p></div></div><pre><code class="language-julia hljs">f(x) = x^2 - 1
g(x) = 2x
Œ¥x(x) = - g(x) / 2
x‚ÇÄ = 3.
_f(Œ±) = f(compute_new_iterate(x‚ÇÄ, Œ±, Œ¥x(x‚ÇÄ)))
_d(Œ±) = g(compute_new_iterate(x‚ÇÄ, Œ±, Œ¥x(x‚ÇÄ)))
ls_obj = LinesearchProblem{typeof(x‚ÇÄ)}(_f, _d)

# output

LinesearchProblem{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Alternatively one can also do:</p><pre><code class="language-julia hljs">ls_obj = LinesearchProblem(_f, _d, x‚ÇÄ)

# output

LinesearchProblem{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Here we wrote <code>ls_obj</code> to mean <em>line search problem</em>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL26-L63">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.LinesearchState"><a class="docstring-binding" href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LinesearchState</code></pre><p>Abstract type. </p><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>, <a href="#SimpleSolvers.BisectionState"><code>BisectionState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>.</p><p><strong>Implementation</strong></p><p>A <code>struct</code> that is subtyped from <code>LinesearchState</code> needs to implement the functors:</p><pre><code class="language-julia hljs">ls(x; kwargs...)
ls(obj::LinesearchProblem, x; kwargs...)</code></pre><p>Additionaly the following function needs to be extended:</p><pre><code class="language-julia hljs">LinesearchState(algorithm::LinesearchMethod; kwargs...)</code></pre><p><strong>Constructors</strong></p><p>The following is used to construct a specific line search state based on a <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a>:</p><pre><code class="language-julia hljs">LinesearchState(algorithm::LinesearchMethod; T::DataType=Float64, kwargs...)</code></pre><p>where the data type should be specified each time the constructor is called. This is done automatically when calling the constructor of <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> for example.</p><p><strong>Functors</strong></p><p>The following functors are auxiliary helper functions:</p><pre><code class="language-julia hljs">ls(f::Callable; kwargs...) = ls(LinesearchProblem(f, missing); kwargs...)
ls(f::Callable, x::Number; kwargs...) = ls(LinesearchProblem(f, missing), x; kwargs...)
ls(f::Callable, g::Callable; kwargs...) = ls(LinesearchProblem(f, g); kwargs...)
ls(f::Callable, g::Callable, x::Number; kwargs...) = ls(LinesearchProblem(f, g), x; kwargs...)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/linesearch.jl#LL4-L45">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonMethod"><a class="docstring-binding" href="#SimpleSolvers.NewtonMethod"><code>SimpleSolvers.NewtonMethod</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NewtonMethod(refactorize)</code></pre><p>Make an instance of a <em>quasi Newton solver</em> based on an integer <em>refactorize</em> that determines how often the rhs is refactored.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/methods.jl#LL12-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonOptimizerCache"><a class="docstring-binding" href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NewtonOptimizerCache</code></pre><p><strong>Keys</strong></p><ul><li><code>xÃÑ</code>: the previous iterate,</li><li><code>x</code>: current iterate (this stores the guess called by the functions generated with <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>),</li><li><code>Œ¥</code>: direction of optimization step (difference between <code>x</code> and <code>xÃÑ</code>); this is obtained by multiplying <code>rhs</code> with the inverse of the Hessian,</li><li><code>g</code>: gradient value (this stores the gradient associated with <code>x</code> called by the <em>derivative part</em> of <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>),</li><li><code>rhs</code>: the right hand side used to compute the update.</li></ul><p>To understand how these are used in practice see e.g. <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>.</p><p>Also compare this to <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL1-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonOptimizerState"><a class="docstring-binding" href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NewtonOptimizerState &lt;: OptimizationAlgorithm</code></pre><p>The optimizer state is needed to update the <a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a>. This is different to <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> and <a href="update/#OptimizerResult"><code>OptimizerResult</code></a> which serve as diagnostic tools. It stores a <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and a <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> which is used to compute the line search problem at each iteration.</p><p><strong>Keys</strong></p><ul><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>cache::</code><a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_state.jl#LL1-L11">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonSolver"><a class="docstring-binding" href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NewtonSolver</code></pre><p>A <code>const</code> derived from <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a></p><p><strong>Constructors</strong></p><p>The <code>NewtonSolver</code> can be called with an <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> or with a <code>Callable</code>. Note however that the latter will probably be deprecated in the future.</p><pre><code class="language-julia hljs">linesearch = Quadratic()
F(y, x, params) = y .= tanh.(x)
x = [.5, .5]
y = zero(x)
F(y, x, nothing)

NewtonSolver(x, y; F = F, linesearch = linesearch)

# output

i=   0,
x= NaN,
f= NaN,
rx‚Çê= NaN,
rf‚Çê= NaN</code></pre><p>What is shown here is the status of the <code>NewtonSolver</code>, i.e. an instance of <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>nonlinearproblem::</code><a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>: the system that has to be solved. This can be accessed by calling <a href="#SimpleSolvers.nonlinearproblem-Tuple{FixedPointIterator{T} where T}"><code>nonlinearproblem</code></a>,</li><li><code>jacobian::</code><a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a></li><li><code>linear::</code><a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>: the linear solver is used to compute the <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>direction</code></a> of the solver step (see <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a>). This can be accessed by calling <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>linearsolver</code></a>,</li><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>refactorize::Int</code>: determines after how many steps the Jacobian is updated and refactored (see <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>). If we have <code>refactorize &gt; 1</code>, then we speak of a <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a>,</li><li><code>cache::</code><a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL1-L38">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">NewtonSolver(x, F, y)</code></pre><p><strong>Keywords</strong></p><ul><li><code>linear_solver_method</code></li><li><code>DF!</code></li><li><code>linesearch</code></li><li><code>mode</code></li><li><code>options_kwargs</code>: see <a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL50-L59">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NewtonSolverCache"><a class="docstring-binding" href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NewtonSolverCache</code></pre><p>Stores <code>xÃÑ</code>, <code>x</code>, <code>Œ¥x</code>, <code>rhs</code>, <code>y</code> and <code>J</code>.</p><p>Compare this to <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>xÃÑ</code>: the previous iterate,</li><li><code>x</code>: the next iterate (or <em>guess</em> thereof). The <em>guess</em> is computed when calling the functions created by <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>,</li><li><code>Œ¥x</code>: search direction. This is updated when calling <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a> via the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> stored in the <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>,</li><li><code>rhs</code>: the right-hand-side (this can be accessed by calling <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>rhs</code></a>), </li><li><code>y</code>: the problem evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>,</li><li><code>J::AbstractMatrix</code>: the Jacobian evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>linesearch_problem</code></a>. Note that this is not of type <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a>!</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NewtonSolverCache(x, y)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_cache.jl#LL1-L22">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NoLinearProblem"><a class="docstring-binding" href="#SimpleSolvers.NoLinearProblem"><code>SimpleSolvers.NoLinearProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><p>A <em>dummy linear system</em> used for the <em>fixed point iterator</em> (<a href="#SimpleSolvers.PicardMethod"><code>PicardMethod</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL6-L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NoLinesearchState"><a class="docstring-binding" href="#SimpleSolvers.NoLinesearchState"><code>SimpleSolvers.NoLinesearchState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NoLinesearchState &lt;: LinesearchState</code></pre><p>Used for the <em>fixed point iterator</em> (<a href="#SimpleSolvers.PicardMethod"><code>PicardMethod</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/dummy_linesearch.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearMethod"><a class="docstring-binding" href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><p>A supertype collecting all nonlinear methods, including <code>NewtonMethod</code>s.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/methods.jl#LL3">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearProblem"><a class="docstring-binding" href="#SimpleSolvers.NonlinearProblem"><code>SimpleSolvers.NonlinearProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NonlinearProblem</code></pre><p>A <code>NonlinearProblem</code> describes <span>$F(x) = y$</span>, where we want to solve for <span>$x$</span> and <span>$F$</span> is in nonlinear in general (also compare this to <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> and <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>).</p><div class="admonition is-info" id="Info-314478d54e386025"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-314478d54e386025" title="Permalink"></a></header><div class="admonition-body"><p><code>NonlinearProblem</code>s are used for <em>solvers</em> whereas <code>OptimizerProblem</code>s are their equivalent for <em>optimizers</em>.</p></div></div><p><strong>Keys</strong></p><ul><li><code>F</code>: accessed by calling <code>Function(nlp)</code>,</li><li><code>J::Union{Callable, Missing}</code>: accessed by calling <code>Jacobian(nlp)</code>,</li><li><code>f</code>: accessed by calling <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a><code>(nlp)</code>,</li><li><code>j</code>: accessed by calling <a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver{T} where T}"><code>jacobian</code></a><code>(nlp)</code>,</li><li><code>x_f</code>: accessed by calling <a href="#SimpleSolvers.f_argument-Tuple{NonlinearProblem}"><code>f_argument</code></a><code>(nlp)</code>,</li><li><code>x_j</code>: accessed by calling <a href="#SimpleSolvers.j_argument-Tuple{NonlinearProblem}"><code>j_argument</code></a><code>(nlp)</code>,</li><li><code>f_calls</code>: accessed by calling <a href="#SimpleSolvers.f_calls-Tuple{NonlinearProblem}"><code>f_calls</code></a><code>(nlp)</code>,</li><li><code>j_calls</code>: accessed by calling <a href="#SimpleSolvers.j_calls-Tuple{NonlinearProblem}"><code>j_calls</code></a><code>(nlp)</code>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL129-L148">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#SimpleSolvers.NonlinearProblem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearProblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">NonlinearProblem(F, x, f)</code></pre><p>Set <code>jacobian</code> <span>$\gets$</span> <code>missing</code> and call the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> constructor.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL177-L181">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolver"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NonlinearSolver</code></pre><p>A <code>struct</code> that comprises <em>Newton solvers</em> (see <a href="#SimpleSolvers.NewtonMethod"><code>NewtonMethod</code></a>) and the <em>fixed point iterator</em> (see <a href="#SimpleSolvers.PicardMethod"><code>PicardMethod</code></a>).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NonlinearSolver(x, nlp, ls, linearsolver, linesearch, cache; method)</code></pre><p>The <code>NonlinearSolver</code> can be called with an <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> or with a <code>Callable</code>. Note however that the latter will probably be deprecated in the future. See <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> for examples (as well as <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>).</p><p>It&#39;s arguments are:</p><ul><li><code>nlp::</code><a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>: the system that has to be solved. This can be accessed by calling <a href="#SimpleSolvers.nonlinearproblem-Tuple{FixedPointIterator{T} where T}"><code>nonlinearproblem</code></a>,</li><li><code>ls::</code><a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>,</li><li><code>linearsolver::</code><a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>: the linear solver is used to compute the <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>direction</code></a> of the solver step (see <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a>). This can be accessed by calling <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>linearsolver</code></a>,</li><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>cache::</code><a href="#SimpleSolvers.NonlinearSolverCache"><code>NonlinearSolverCache</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver.jl#LL10-L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolverCache"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolverCache"><code>SimpleSolvers.NonlinearSolverCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NonlinearSolverCache</code></pre><p>An abstract type that comprises e.g. the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver.jl#LL3-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.NonlinearSolverStatus"><a class="docstring-binding" href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NonlinearSolverStatus</code></pre><p>Stores absolute, relative and successive residuals for <code>x</code> and <code>f</code>. It is used as a diagnostic tool in <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>i::Int</code>: iteration number,</li><li><code>rx‚Çê</code>: absolute residual in <code>x</code>,</li><li><code>rx‚Çõ</code>: successive residual in <code>x</code>,</li><li><code>rf‚Çê</code>: absolute residual in <code>f</code>,</li><li><code>rf‚Çõ</code>: successive residual in <code>f</code>,</li><li><code>x</code>: the <em>current solution</em> (can also be accessed by calling <a href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>solution</code></a>),</li><li><code>xÃÑ</code>: previous solution</li><li><code>Œ¥</code>: change in solution (see <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>direction</code></a>). This is updated by calling <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearProblem)</code></a>,</li><li><code>xÃÉ</code>: a variable that gives the <em>component-wise change</em> via <span>$\delta/x$</span>,</li><li><code>f‚ÇÄ</code>: initial function value,</li><li><code>f</code>: current function value,</li><li><code>fÃÑ</code>: previous function value,</li><li><code>Œ≥</code>: records change in <code>f</code>. This is updated by calling <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearProblem)</code></a>,</li><li><code>x_converged::Bool</code></li><li><code>f_converged::Bool</code></li><li><code>g_converged::Bool</code></li><li><code>f_increased::Bool</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">NonlinearSolverStatus{Float64}(3)

# output

i=   0,
x= NaN,
f= NaN,
rx‚Çê= NaN,
rf‚Çê= NaN</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL1-L38">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizationAlgorithm"><a class="docstring-binding" href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><p>An <code>OptimizationAlgorithm</code> is a data structure that is used to dispatch on different algorithms.</p><p>It needs to implement three methods,</p><pre><code class="language-julia hljs">initialize!(alg::OptimizationAlgorithm, ::AbstractVector)
update!(alg::OptimizationAlgorithm, ::AbstractVector)
solver_step!(::AbstractVector, alg::OptimizationAlgorithm)</code></pre><p>that initialize and update the state of the algorithm and perform an actual optimization step.</p><p>Further the following convenience methods should be implemented,</p><pre><code class="language-julia hljs">problem(alg::OptimizationAlgorithm)
gradient(alg::OptimizationAlgorithm)
hessian(alg::OptimizationAlgorithm)
linesearch(alg::OptimizationAlgorithm)</code></pre><p>which return the problem to optimize, its gradient and (approximate) Hessian as well as the linesearch algorithm used in conjunction with the optimization algorithm if any.</p><p>See <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> for a <code>struct</code> that was derived from <code>OptimizationAlgorithm</code>.</p><div class="admonition is-info" id="Info-2237bf6f31831567"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-2237bf6f31831567" title="Permalink"></a></header><div class="admonition-body"><p>Note that a <code>OptimizationAlgorithm</code> is not necessarily a <code>NewtonOptimizerState</code> as we can also have other optimizers, <em>Adam</em> for example.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL4-L29">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Optimizer"><a class="docstring-binding" href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Optimizer</code></pre><p>The optimizer that stores all the information needed for an optimization problem. This problem can be solved by calling <a href="#SimpleSolvers.solve!"><code>solve!(::AbstractVector, ::Optimizer)</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a>,</li><li><code>problem::</code><a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>,</li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a>,</li><li><code>result::</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>,</li><li><code>state::</code><a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL51-L62">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerProblem"><a class="docstring-binding" href="#SimpleSolvers.OptimizerProblem"><code>SimpleSolvers.OptimizerProblem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">OptimizerProblem &lt;: AbstractOptimizerProblem</code></pre><p>Stores <em>gradients</em>. Also compare this to <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>.</p><p>The type of the <em>stored gradient</em> has to be a subtype of <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Functor</strong></p><p>If <code>OptimizerProblem</code> is called on a single function, the gradient is generated with <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL109-L119">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerResult"><a class="docstring-binding" href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">OptimizerResult</code></pre><p>Stores an <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> as well as <code>x</code>, <code>f</code> and <code>g</code> (as keys). <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> stores all other information (apart form <code>x</code> ,<code>f</code> and <code>g</code>); i.e. residuals etc.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_result.jl#LL2-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.OptimizerStatus"><a class="docstring-binding" href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">OptimizerStatus</code></pre><p>Stores residuals (relative and absolute) and various convergence properties.</p><p>See <a href="update/#OptimizerResult"><code>OptimizerResult</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL1-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Options"><a class="docstring-binding" href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Options</code></pre><p><strong>Keys</strong></p><p>Configurable options with defaults (values 0 and NaN indicate unlimited):</p><ul><li><code>x_abstol = 2eps(T)</code>: absolute tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>,</li><li><code>x_reltol = 2eps(T)</code>: relative tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>x_suctol = 2eps(T)</code>: succesive tolerance for <code>x</code>. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_abstol = zero(T)</code>: absolute tolerance for how close the function value should be to zero. See <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>. Used in e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_reltol = 2eps(T)</code>: relative tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_suctol = 2eps(T)</code>: succesive tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_mindec = T(10)^-4</code>: minimum value by which the function has to decrease (also see <a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>minimum_decrease_threshold</code></a>),</li><li><code>g_restol = 2eps(T)</code>: tolerance for the residual (?) of the gradient,</li><li><code>x_abstol_break = -Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>x_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_abstol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>.,</li><li><code>g_restol_break = Inf</code>,</li><li><code>f_calls_limit = 0</code>,</li><li><code>g_calls_limit = 0</code>,</li><li><code>h_calls_limit = 0</code>,</li><li><code>allow_f_increases = true</code>,</li><li><code>min_iterations = 0</code>,</li><li><code>max_iterations = 1000</code>: the maximum number of iterations used in an alorithm, e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and the functor for <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>,</li><li><code>warn_iterations = 1000</code>,</li><li><code>show_trace = false</code>,</li><li><code>store_trace = false</code>,</li><li><code>extended_trace = false</code>,</li><li><code>show_every = 1</code>,</li><li><code>verbosity = 1</code></li></ul><p>Some of the constants are defined by the functions <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> and <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/options.jl#LL107-L140">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.PicardMethod"><a class="docstring-binding" href="#SimpleSolvers.PicardMethod"><code>SimpleSolvers.PicardMethod</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PicardMethod()</code></pre><p>Make an instance of a <em>Picard solver</em> (fixed point iterator).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/methods.jl#LL30-L34">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Quadratic"><a class="docstring-binding" href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Quadratic &lt;: LinesearchMethod</code></pre><p>The <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Quadratic()</code></pre><p><strong>Extended help</strong></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL73-L85">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Quadratic2"><a class="docstring-binding" href="#SimpleSolvers.Quadratic2"><code>SimpleSolvers.Quadratic2</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Quadratic2 &lt;: LinesearchMethod</code></pre><p>The second <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>.</p><p><strong>Extended help</strong></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL88-L94">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.QuadraticState"><a class="docstring-binding" href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">QuadraticState &lt;: LinesearchState</code></pre><p>Quadratic Polynomial line search.</p><p><em>Quadratic line search</em> works by fitting a polynomial to a univariate problem (see <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a>) and then finding the minimum of that polynomial. Also compare this to <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>Œ±‚ÇÄ</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_Œ±‚ÇÄ"><code>DEFAULT_ARMIJO_Œ±‚ÇÄ</code></a></li><li><code>œÉ‚ÇÄ</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a></li><li><code>œÉ‚ÇÅ</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a></li><li><code>c</code>: by default <a href="#SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><code>DEFAULT_WOLFE_c‚ÇÅ</code></a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/quadratic.jl#LL1-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.QuadraticState2"><a class="docstring-binding" href="#SimpleSolvers.QuadraticState2"><code>SimpleSolvers.QuadraticState2</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">QuadraticState2 &lt;: LinesearchState</code></pre><p>Quadratic Polynomial line search. This is similar to <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>, but performs multiple iterations in which all parameters <span>$p_0$</span>, <span>$p_1$</span> and <span>$p_2$</span> are changed. This is different from <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), where only <span>$p_2$</span> is changed. We further do not check the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> but rather whether the derivative is <em>small enough</em>.</p><p>This algorithm repeatedly builds new quadratic polynomials until a minimum is found (to sufficient accuracy). The iteration may also stop after we reaches the maximum number of iterations (see <a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a>).</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>Œµ</code>: A constant that checks the <em>precision</em>/<em>tolerance</em>.</li><li><code>s</code>: A constant that determines the initial interval for bracketing. By default this is <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a>.</li><li><code>s_reduction:</code> A constant that determines the factor by which <code>s</code> is decreased in each new <em>bracketing iteration</em>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/custom_quadratic.jl#LL11-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.Static"><a class="docstring-binding" href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Static &lt;: LinesearchMethod</code></pre><p>The <em>static</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Static(Œ±)</code></pre><p><strong>Keys</strong></p><p>Keys include: -<code>Œ±</code>: equivalent to a step size. The default is <code>1</code>.</p><p><strong>Extended help</strong></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/methods.jl#LL104-L121">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.StaticState"><a class="docstring-binding" href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StaticState &lt;: LinesearchState</code></pre><p>The state for <a href="#SimpleSolvers.Static"><code>Static</code></a>.</p><p><strong>Functors</strong></p><p>For a <code>Number</code> <code>a</code> and an <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> <code>obj</code> we have the following functors:</p><pre><code class="language-julia hljs">ls.(a) = ls.Œ±
ls.(obj, a) = ls.Œ±</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/static.jl#LL1-L13">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.SufficientDecreaseCondition"><a class="docstring-binding" href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">SufficientDecreaseCondition &lt;: LinesearchCondition</code></pre><p>The condition that determines if <span>$\alpha_k$</span> is <em>big enough</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SufficientDecreaseCondition(c‚ÇÅ, x‚Çñ, f‚Çñ, grad‚Çñ, p‚Çñ, obj)</code></pre><p><strong>Functors</strong></p><pre><code class="language-julia hljs">sdc(x‚Çñ‚Çä‚ÇÅ, Œ±‚Çñ)
sdc(Œ±‚Çñ)</code></pre><p>The second functor is shorthand for <code>sdc(compute_new_iterate(sdc.x‚Çñ, Œ±‚Çñ, sdc.p‚Çñ), T(Œ±‚Çñ))</code>, also see <a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>compute_new_iterate</code></a>.</p><p><strong>Extended help</strong></p><p>We call the constant that pertains to the sufficient decrease condition <span>$c$</span>. This is typically called <span>$c_1$</span> in the literature [<a href="references/#nocedal2006numerical">3</a>]. See <a href="#SimpleSolvers.DEFAULT_WOLFE_c‚ÇÅ"><code>DEFAULT_WOLFE_c‚ÇÅ</code></a> for the relevant constant</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/sufficient_decrease_condition.jl#LL1-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(iterator, x, params)</code></pre><p>Update the <code>solver::</code><a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><code>FixedPointIterator</code></a> based on <code>x</code>. This updates the cache (instance of type <a href="#SimpleSolvers.FixedPointIteratorCache"><code>FixedPointIteratorCache</code></a>) and the status (instance of type <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>). In course of updating the latter, we also update the <code>nonlinear</code> stored in <code>iterator</code> (and <code>status(iterator)</code>).</p><div class="admonition is-info" id="Info-be10b41090faf66b"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-be10b41090faf66b" title="Permalink"></a></header><div class="admonition-body"><p>At the moment this is neither used in <code>solver_step!</code> nor <code>solve!</code>.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL72-L80">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(H, x)</code></pre><p>Update a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p>This is identical to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL193-L203">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{NewtonSolver{T} where T, AbstractArray, Any}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{NewtonSolver{T} where T, AbstractArray, Any}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(solver, x, params)</code></pre><p>Update the <code>solver::</code><a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> based on <code>x</code>. This updates the cache (instance of type <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>) and the status (instance of type <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>). In course of updating the latter, we also update the <code>nonlinear</code> stored in <code>solver</code> (and <code>status(solver)</code>).</p><div class="admonition is-info" id="Info-be10b41090faf66b"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-be10b41090faf66b" title="Permalink"></a></header><div class="admonition-body"><p>At the moment this is neither used in <code>solver_step!</code> nor <code>solve!</code>.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL172-L180">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{Optimizer, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{Optimizer, AbstractVector}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(opt, x)</code></pre><p>Compute problem and gradient at new solution and update result.</p><p>This first calls <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a> and then <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NewtonOptimizerState, ::AbstractVector)</code></a>. We note that the <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> (unlike the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a>) is updated when calling <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL160-L167">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{OptimizerProblem, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{OptimizerProblem, AbstractVector}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(obj, x)</code></pre><p>Call <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a> and <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a> on <code>obj</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL247-L251">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(cache, x, g)</code></pre><p>Update the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code> and <code>g</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL62-L66">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(cache::NewtonOptimizerCache, x, g, hes)</code></pre><p>Update an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code>.</p><p>This is used in <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NewtonOptimizerState, ::AbstractVector)</code></a>.</p><p>This sets:</p><p class="math-container">\[\bar{x}^\mathtt{cache} \gets x,
x^\mathtt{cache} \gets x,
g^\mathtt{cache} \gets g,
\mathrm{rhs}^\mathtt{cache} \gets -g,
\delta^\mathtt{cache} \gets H^{-1}\mathrm{rhs}^\mathtt{cache},\]</p><p>where we wrote <span>$H$</span> for the Hessian (i.e. the input argument <code>hes</code>). </p><p>Also see <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NewtonSolverCache, ::AbstractVector)</code></a>. </p><div class="admonition is-category-warn" id="Warn-e00474329f0f1936"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-e00474329f0f1936" title="Permalink"></a></header><div class="admonition-body"><p>Note that this is not updating the Hessian <code>hes</code>. For this call <code>update!</code> on the <code>Hessian</code>.</p></div></div><p><strong>Implementation</strong></p><p>The multiplication by the inverse of <span>$H$</span> is done with <code>LinearAlgebra.ldiv!</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL76-L101">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(state::NewtonOptimizerState, x, g, hes)</code></pre><p>Update an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> based on <code>x</code>, <code>g</code> and <code>hes</code>, where <code>g</code> can either be an <code>AbstractVector</code> or a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>hes</code> is a <a href="update/#Hessian"><code>Hessian</code></a>. This updates the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> contained in the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> by calling <a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>update!(::NewtonOptimizerCache, ::AbstractVector, ::Union{AbstractVector, Gradient}, ::Hessian)</code></a>.</p><div class="admonition is-info" id="Info-6321756d4ef3fd12"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-6321756d4ef3fd12" title="Permalink"></a></header><div class="admonition-body"><p>An instance of <code>NewtonOptimizerState</code> stores the <code>NewtonOptimizerCache</code> as well as a <code>LinesearchState</code>. The <code>LinesearchState</code> stays the same at every iteration, which is why only the <code>NewtonOptimizerState</code> is updated.</p></div></div><p><strong>Examples</strong></p><p>We show that after initializing, update has to be called together with a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and a <a href="update/#Hessian"><code>Hessian</code></a>:</p><p>If we only call <code>update!</code> once there are still <code>NaN</code>s in the ...</p><pre><code class="language-julia hljs">f(x) = sum(x.^2)
x = [1., 2.]
state = NewtonOptimizerState(x)
obj = OptimizerProblem(f, x)
g = gradient!(obj, x)
hes = HessianAutodiff(obj, x)
update!(hes, x)
update!(state, x, g, hes)

# output

NewtonOptimizerState{Float64, SimpleSolvers.BacktrackingState{Float64}, SimpleSolvers.NewtonOptimizerCache{Float64, Vector{Float64}}}(Backtracking with Œ±‚ÇÄ = 1.0, œµ = 0.0001and p = 0.5., SimpleSolvers.NewtonOptimizerCache{Float64, Vector{Float64}}([1.0, 2.0], [1.0, 2.0], [-1.0, -2.0], [2.0, 4.0], [-2.0, -4.0]))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_state.jl#LL42-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearProblem, Any}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearProblem, Any}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(status, x, nls)</code></pre><p>Update the <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> based on <code>x</code> for the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> <code>obj</code>.</p><div class="admonition is-info" id="Info-f780c4b3a2e3124"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f780c4b3a2e3124" title="Permalink"></a></header><div class="admonition-body"></div></div><p>This also updates the problem <code>nls</code>!</p><p>Sets <code>xÃÑ</code> and <code>fÃÑ</code> to <code>x</code> and <code>f</code> respectively and computes <code>Œ¥</code> as well as <code>Œ≥</code>. The new <code>x</code> and <code>xÃÑ</code> stored in <code>status</code> are used to compute <code>Œ¥</code>. The new <code>f</code> and <code>fÃÑ</code> stored in <code>status</code> are used to compute <code>Œ≥</code>. See <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> for an explanation of those variables.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL278-L290">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(result, x, f, g)</code></pre><p>Update the <a href="update/#OptimizerResult"><code>OptimizerResult</code></a> based on <code>x</code>, <code>f</code> and <code>g</code> (all vectors). This involves updating the <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> stored in <code>result</code> (by calling <a href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>residual!</code></a>).</p><p>This also calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>increase_iteration_number!(::OptimizerResult)</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_result.jl#LL63-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(hessian, x)</code></pre><p>Update the <a href="update/#Hessian"><code>Hessian</code></a> based on the vector <code>x</code>. For an explicit example see e.g. <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::HessianAutodiff)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL88-L92">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(ls, A, y)</code></pre><p>Set the <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>rhs</code></a> vector to <code>y</code> and the matrix stored in <code>ls</code> to <code>A</code>.</p><div class="admonition is-info" id="Info-3962d3cc26bd7dbf"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-3962d3cc26bd7dbf" title="Permalink"></a></header><div class="admonition-body"><p>Calling <code>update!</code> doesn&#39;t solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a>, you still have to call <code>solve!</code> in combination with a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL80-L87">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">update!(cache, x)</code></pre><p>Update the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>, i.e.:</p><ol><li><code>cache.xÃÑ</code> <span>$\gets$</span> x,</li><li><code>cache.x</code> <span>$\gets$</span> x,</li><li><code>cache.Œ¥x</code> <span>$\gets$</span> 0.</li></ol><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_cache.jl#LL41-L48">source</a></div></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><a class="docstring-binding" href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">value(obj::AbstractOptimizerProblem, x)</code></pre><p>Evaluates the value at <code>x</code> (i.e. computes <code>obj.F(x)</code>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL14-L18">source</a></div></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><a class="docstring-binding" href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">ldiv!(x, lu, b)</code></pre><p>Compute <code>inv(cache(lsolver).A) * b</code> by utilizing the factorization of the lu solver (see <a href="#SimpleSolvers.LU"><code>LU</code></a> and <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) and store the result in <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL253-L257">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.QuasiNewtonSolver-Tuple"><a class="docstring-binding" href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">QuasiNewtonSolver</code></pre><p>A convenience constructor for <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a>.</p><p>Calling <code>QuasiNewtonSolver</code> hence produces an instance of <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> with the difference that <code>refactorize ‚â† 1</code>. The <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is thus not evaluated and refactored in every step.</p><p><strong>Implementation</strong></p><p>It does:</p><pre><code class="language-julia hljs">QuasiNewtonSolver(args...; kwargs...) = NewtonSolver(args...; refactorize=DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER, kwargs...)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL93-L106">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers._static-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">_static(A)</code></pre><p>Determine whether to allocate a <code>StaticArray</code> or simply copy the input array. This is used when calling <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> on <a href="#SimpleSolvers.LU"><code>LU</code></a>. Every matrix that is smaller or equal to <a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>N_STATIC_THRESHOLD</code></a> is turned into a <code>StaticArray</code> as a consequence.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL64-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">absolute_tolerance(T)</code></pre><p>Determine the absolute tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p>In comparison to <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>, this should return a very small number, close to zero (i.e. not just machine precision).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">absolute_tolerance(Float64)

# output

0.0</code></pre><pre><code class="language-julia hljs">absolute_tolerance(Float32)

# output

0.0f0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/options.jl#LL36-L60">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">adjust_Œ±(ls, Œ±‚Çú, Œ±)</code></pre><p>Check which conditions the new <code>Œ±‚Çú</code> is in <span>$[\sigma_0\alpha_0, \simga_1\alpha_0]$</span> and return the updated <code>Œ±</code> accordingly (it is updated if it does not lie in the interval).</p><p>We first check the following:</p><p class="math-container">\[    \alpha_t  &lt; \alpha_0\alpha,\]</p><p>where <span>$\sigma_0$</span> is stored in <code>ls</code> (i.e. in an instance of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). If this is not true we check:</p><p class="math-container">\[    \alpha_t &gt; \sigma_1\alpha,\]</p><p>where <span>$\sigma_1$</span> is again stored in <code>ls</code>. If this second condition is also not true we simply return the unchanged <span>$\alpha_t$</span>. So if <code>\alpha_t</code> does not lie in the interval <span>$(\sigma_0\alpha, \sigma_1\alpha)$</span> the interval is made bigger by either multiplying with <span>$\sigma_0$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a>) or <span>$\sigma_1$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/quadratic.jl#LL39-L55">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">adjust_Œ±(Œ±‚Çú, Œ±)</code></pre><p>Adjust <code>Œ±‚Çú</code> based on the previous <code>Œ±</code>. Also see <a href="#SimpleSolvers.adjust_Œ±-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>adjust_Œ±(::QuadraticState{T}, ::T, ::T) where {T}</code></a>.</p><p>The check that <span>$\alpha \in [\sigma_0\alpha_\mathrm{old}, \sigma_1\alpha_\mathrm{old}]$</span> should <em>safeguard against stagnation in the iterates</em> as well as checking that <span>$\alpha$</span> decreases at least by a factor <span>$\sigma_1$</span>. The defaults for <code>œÉ‚ÇÄ</code> and <code>œÉ‚ÇÅ</code> are <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a> respectively.</p><p><strong>Implementation</strong></p><p>Wee use defaults <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÄ"><code>DEFAULT_ARMIJO_œÉ‚ÇÄ</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_œÉ‚ÇÅ"><code>DEFAULT_ARMIJO_œÉ‚ÇÅ</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/quadratic.jl#LL60-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_d"><a class="docstring-binding" href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">alloc_d(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the derivative of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/utils.jl#LL15-L21">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_f"><a class="docstring-binding" href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">alloc_f(x)</code></pre><p>Allocate <code>NaN</code>s of the size the size of <code>f</code> (evaluated at <code>x</code>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/utils.jl#LL8-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_g"><a class="docstring-binding" href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">alloc_g(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the gradient of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/utils.jl#LL24-L30">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_h"><a class="docstring-binding" href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">alloc_h(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the Hessian of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/utils.jl#LL33-L39">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.alloc_x"><a class="docstring-binding" href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">alloc_x(x)</code></pre><p>Allocate <code>NaN</code>s of the size of <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/utils.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">assess_convergence!(status, config)</code></pre><p>Check if one of the following is true for <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><ul><li><code>status.rx‚Çê ‚â§ config.x_abstol</code>,</li><li><code>status.rx‚Çõ ‚â§ config.x_suctol</code>,</li><li><code>status.rf‚Çê ‚â§ config.f_abstol</code>,</li><li><code>status.rf‚Çõ ‚â§ config.f_suctol</code>.</li></ul><p>Also see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>. The tolerances are by default determined with <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL160-L170">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">assess_convergence!(status, config)</code></pre><p>Checks if the optimizer converged.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL145-L149">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bisection-Tuple{Any, Number}"><a class="docstring-binding" href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bisection(f, x)</code></pre><p>Use <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> to find a starting interval and then do bisections.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bisection.jl#LL79-L83">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bisection(f, xmin, xmax; config)</code></pre><p>Perform bisection of <code>f</code> in the interval [<code>xmin</code>, <code>xmax</code>] with <a href="#SimpleSolvers.Options"><code>Options</code></a> <code>config</code>.</p><p>The algorithm is repeated until a root is found (up to tolerance <code>config.f_abstol</code> which is determined by <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> by default).</p><p><strong>implementation</strong></p><p>When calling <code>bisection</code> it first checks if <span>$x_\mathrm{min} &lt; x_\mathrm{max}$</span> and else flips the two entries.</p><p><strong>Extended help</strong></p><p>The bisection algorithm divides an interval into equal halves until a root is found (up to a desired accuracy).</p><p>We first initialize:</p><p class="math-container">\[\begin{aligned}
x_0 \gets &amp; x_\mathrm{min},
x_1 \gets &amp; x_\mathrm{max},
\end{aligned}\]</p><p>and then repeat:</p><p class="math-container">\[\begin{aligned}
&amp; x \gets \frac{x_0 + x_1}{2}, \\
&amp; \text{if $f(x_0)f(x) &gt; 0$} \\
&amp; \qquad x_0 \gets x, \\
&amp; \text{else} \\
&amp; \qquad x_1 \gets x, \\
&amp; \text{end}
\end{aligned}\]</p><p>So the algorithm checks in each step where the sign change occurred and moves the <span>$x_0$</span> or <span>$x_1$</span> accordingly. The loop is terminated (and errors) if <code>config.max_iterations</code> is reached (by default1000 and the <a href="#SimpleSolvers.Options"><code>Options</code></a> struct).</p><div class="admonition is-warning" id="Warning-71c199606f789e27"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-71c199606f789e27" title="Permalink"></a></header><div class="admonition-body"><p>The obvious danger with using bisections is that the supplied interval can have multiple roots (or no roots). One should be careful to avoid this when fixing the interval.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bisection.jl#LL1-L38">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bracket_minimum(f, x)</code></pre><p>Move a bracket successively in the search direction (starting at <code>x</code>) and increase its size until a local minimum of <code>f</code> is found.  This is used for performing <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>s when only one <code>x</code> is given (and not an entire interval).  This bracketing algorithm is taken from [<a href="references/#kochenderfer2019algorithms">4</a>]. Also compare it to <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>s::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a></li><li><code>k::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a></li><li><code>nmax::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a></li></ul><p><strong>Extended help</strong></p><p>For bracketing we need two constants <span>$s$</span> and <span>$k$</span> (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>). </p><p>Before we start the algorithm we <em>initialize</em> it, i.e. we check that we indeed have a descent direction:</p><p class="math-container">\[\begin{aligned}
&amp; a \gets x, \\
&amp; b \gets a + s, \\
&amp; \mathrm{if} \quad f(b) &gt; f(a)\\
&amp; \qquad\text{Flip $a$ and $b$ and set $s\gets-s$.}\\
&amp; \mathrm{end}
\end{aligned}\]</p><p>The algorithm then successively computes:</p><p class="math-container">\[c \gets b + s,\]</p><p>and then checks whether <span>$f(c) &gt; f(b)$</span>. If this is true it returns <span>$(a, c)$</span> or <span>$(c, a)$</span>, depending on whether <span>$a&lt;c$</span> or <span>$c&lt;a$</span> respectively. If this is not satisfied <span>$a,$</span> <span>$b$</span> and <span>$s$</span> are updated:</p><p class="math-container">\[\begin{aligned}
a \gets &amp; b, \\
b \gets &amp; c, \\
s \gets &amp; sk, 
\end{aligned}\]</p><p>and the algorithm is continued. If we have not found a sign chance after <span>$n_\mathrm{max}$</span> iterations (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a>) the algorithm is terminated and returns an error. The interval that is returned by <code>bracket_minimum</code> is then typically used as a starting point for <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p><div class="admonition is-info" id="Info-ca26305065bc9a9f"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-ca26305065bc9a9f" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>bracket_root</code> is equivalent to <code>bracket_minimum</code> with the only difference that the criterion we check for is:</p><p class="math-container">\[f(c)f(b) &lt; 0,\]</p><p>i.e. that a sign change in the function occurs.</p></div></div><p>See <a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_root</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL64-L117">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bracket_minimum_with_fixed_point(f, x)</code></pre><p>Find a bracket while keeping the left side (i.e. <code>x</code>) fixed.  The algorithm is similar to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> (also based on <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>) with the difference that for the latter the left side is also moving.</p><p>The function <code>bracket_minimum_with_fixed_point</code> is used as a starting point for <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), as the minimum of the polynomial approximation is:</p><p class="math-container">\[p_2 = \frac{f(b) - f(a) - f&#39;(0)b}{b^2},\]</p><p>where <span>$b = \mathtt{bracket\_minimum\_with\_fixed\_point}(a)$</span>. We check that <span>$f(b) &gt; f(a)$</span> in order to ensure that the curvature of the polynomial (i.e. <span>$p_2$</span> is positive) and we have a minimum.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL140-L151">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bracket_root(f, x)</code></pre><p>Make a bracket for the function based on <code>x</code> (for root finding).</p><p>This is largely equivalent to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>. See the end of that docstring for more information.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/bracket_minimum.jl#LL190-L196">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.cache-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">cache(ls)</code></pre><p>Return the cache (of type <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL42-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_gradient-Tuple{AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">check_gradient(g)</code></pre><p>Check norm, maximum value and minimum value of a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

g = [1., 1., 1., 2., 0.9, 3.]
SimpleSolvers.check_gradient(g; digits=3)

# output

norm(Gradient):               4.1
minimum(|Gradient|):          0.9
maximum(|Gradient|):          3.0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL71-L90">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">check_hessian(H)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="update/#Hessian"><code>Hessian</code></a> <code>H</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

H = [1. ‚àö2.; ‚àö2. 3.]
SimpleSolvers.check_hessian(H)

# output

Condition Number of Hessian: 13.9282
Determinant of Hessian:      1.0
minimum(|Hessian|):          1.0
maximum(|Hessian|):          3.0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL56-L74">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">check_jacobian(J)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> <code>J</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

J = [1. ‚àö2.; ‚àö2. 3.]
SimpleSolvers.check_jacobian(J)

# output

Condition Number of Jacobian: 13.9282
Determinant of Jacobian:      1.0
minimum(|Jacobian|):          1.0
maximum(|Jacobian|):          3.0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL38-L56">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.clear!-Tuple{NonlinearProblem}"><code>SimpleSolvers.clear!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(nlp::NonlinearProblem)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but with only one input argument.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL293-L297">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Tuple{OptimizerProblem}"><a class="docstring-binding" href="#SimpleSolvers.clear!-Tuple{OptimizerProblem}"><code>SimpleSolvers.clear!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but with only one input argument.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL232-L236">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><a class="docstring-binding" href="#SimpleSolvers.clear!-Union{Tuple{LinearProblem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(ls)</code></pre><p>Write <code>NaN</code>s into <code>Matrix(ls)</code> and <code>Vector(ls)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL108-L112">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><a class="docstring-binding" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(result)</code></pre><p>Clear all the information contained in <code>result::</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>. This also calls <a href="#SimpleSolvers.clear!-Tuple{NonlinearProblem}"><code>clear!(::OptimizerStatus)</code></a>.</p><div class="admonition is-info" id="Info-f780c4b3a2e3124"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f780c4b3a2e3124" title="Permalink"></a></header><div class="admonition-body"></div></div><p>Calling <code>initialize!</code> on an <code>OptimizerResult</code> calls <code>clear!</code> internally.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_result.jl#LL39-L47">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><a class="docstring-binding" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL49-L53">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_gradient!"><a class="docstring-binding" href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">compute_gradient!</code></pre><p>Alias for <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>. Will probably be deprecated.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL49-L53">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><a class="docstring-binding" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_hessian!(h, x, ForH)</code></pre><p>Compute the hessian of function <code>ForH</code> at <code>x</code> and store it in <code>h</code>.</p><p><strong>Implementation</strong></p><p>Internally this allocates a <a href="update/#Hessian"><code>Hessian</code></a> object.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL240-L248">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><a class="docstring-binding" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_hessian!(h, x, hessian)</code></pre><p>Compute the Hessian and store it in <code>h</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL36-L40">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><a class="docstring-binding" href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_hessian(x, hessian)</code></pre><p>Compute the Hessian at point <code>x</code> and return the result.</p><p>Internally this calls <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL43-L49">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><a class="docstring-binding" href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_hessian_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>H</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> version.</p><p><strong>Implementation</strong></p><p>This is using <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a> with the keyword <code>mode</code> set to <code>autodiff</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL254-L264">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, JacobianFunction{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, JacobianFunction{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, ForJ, params)</code></pre><p>Allocate a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> object, apply it to <code>x</code>, and store the result in <code>j</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL227-L231">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, jacobian::Jacobian, params)</code></pre><p>Apply the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> and store the result in <code>j</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/jacobian.jl#LL31-L35">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><a class="docstring-binding" href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compute_new_iterate(x‚Çñ, Œ±‚Çñ, p‚Çñ)</code></pre><p>Compute <code>x‚Çñ‚Çä‚ÇÅ</code> based on a <em>direction</em> <code>p‚Çñ</code> and a <em>step length</em> <code>Œ±‚Çñ</code>.</p><p><strong>Extended help</strong></p><p>In the case of vector spaces this function simply does:</p><pre><code class="language-julia hljs">x‚Çñ + Œ±‚Çñ * p‚Çñ</code></pre><p>For manifolds we instead perform a <em>retraction</em> [<a href="references/#absil2008optimization">5</a>].</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/backtracking/condition.jl#LL10-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">default_tolerance(T)</code></pre><p>Determine the default tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">default_tolerance(Float64)

# output

4.440892098500626e-16</code></pre><pre><code class="language-julia hljs">default_tolerance(Float32)

# output

2.3841858f-7</code></pre><pre><code class="language-julia hljs">default_tolerance(Float16)

# output

Float16(0.001953)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/options.jl#LL1-L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.determine_initial_Œ±-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.determine_initial_Œ±-Union{Tuple{T}, Tuple{LinesearchProblem, T}, Tuple{LinesearchProblem, T, T}, Tuple{LinesearchProblem, T, T, T}} where T"><code>SimpleSolvers.determine_initial_Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">determine_initial_Œ±(y‚ÇÄ, obj, Œ±‚ÇÄ)</code></pre><p>Check whether <code>Œ±‚ÇÄ</code> satisfies the <a href="#SimpleSolvers.BracketMinimumCriterion"><code>BracketMinimumCriterion</code></a> for <code>obj</code>. If the criterion is not satisfied we call <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>. This is used as a starting point for using the functor of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> and makes sure that <code>Œ±</code> describes <em>a point past the minimum</em>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/quadratic.jl#LL81-L86">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">direction(::NewtonOptimizerCache)</code></pre><p>Return the direction of the gradient step (i.e. <code>Œ¥</code>) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL48-L52">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.f_argument-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.f_argument-Tuple{NonlinearProblem}"><code>SimpleSolvers.f_argument</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><p>f_argument(nlp)</p><p>Return the argument that was last used for evaluating <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a> for the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> <code>nlp</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL310-L314">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.f_calls-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.f_calls-Tuple{NonlinearProblem}"><code>SimpleSolvers.f_calls</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">f_calls(nlp)</code></pre><p>Tell how many times <code>Function(nlp)</code> has been called.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">F(x) = tanh.(x)
x = [1., 2., 3.]
F!(y, x, params) = y .= F(x)
nlp = NonlinearProblem(F!, x, F(x))

f_calls(nlp)

# output

0</code></pre><p>After calling <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a> once we get:</p><pre><code class="language-julia hljs">value!(nlp, x, nothing)

f_calls(nlp)

# output

1</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL324-L354">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.factorize!-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">factorize!(lsolver)</code></pre><p>Factorize the matrix stored in the <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> in <code>lsolver</code>.</p><p>See <a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>factorize!(::LinearSolver{T, LUT}) where {T, LUT &lt;: LU}</code></a> for a concrete example.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL31-L37">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><a class="docstring-binding" href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">factorize!(lsolver::LinearSolver, A)</code></pre><p>Factorize the matrix <code>A</code> and store the result in <code>cache(lsolver).A</code>. Note that calling <code>cache</code> on <code>lsolver</code> returns the instance of <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a> stored in <code>lsolver</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]
x = similar(y)

lsolver = LinearSolver(LU(; static=false), x)
factorize!(lsolver, A)
cache(lsolver).A

# output

3√ó3 Matrix{Float64}:
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Here <code>cache(lsolver).A</code> stores the factorized matrix. If we call <code>factorize!</code> with two input arguments as above, the method first copies the matrix <code>A</code> into the <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>. We can equivalently also do:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]

lsolver = LinearSolver(LU(), A)
factorize!(lsolver)
cache(lsolver).A

# output

3√ó3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Also note the difference between the output types of the two refactorized matrices. This is because we set the keyword <code>static</code> to false when calling <a href="#SimpleSolvers.LU"><code>LU</code></a>. Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL141-L184">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">find_maximum_value(v, k)</code></pre><p>Find the maximum value of vector <code>v</code> starting from the index <code>k</code>. This is used for <em>pivoting</em> in <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/lu_solver.jl#LL234-L239">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient!!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><a class="docstring-binding" href="#SimpleSolvers.gradient!!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient!!(obj::OptimizerProblem, x)</code></pre><p>Like <code>derivative!!</code>, but for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL187-L191">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><a class="docstring-binding" href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient!(g, x, grad)</code></pre><p>Apply the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> <code>grad</code> to <code>x</code> and store the result in <code>g</code>.</p><p><strong>Implementation</strong></p><p>This is equivalent to doing</p><pre><code class="language-julia hljs">grad(g, x)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL35-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><a class="docstring-binding" href="#SimpleSolvers.gradient!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><p>gradient!(obj::OptimizerProblem, x)</p><p>Like <code>derivative!</code>, but for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL199-L203">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{Any, Gradient}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient(x, grad)</code></pre><p>Apply <code>grad</code> to <code>x</code> and return the result. </p><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL56-L64">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{OptimizerProblem}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{OptimizerProblem}"><code>SimpleSolvers.gradient</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient(x, obj::OptimizerProblem)</code></pre><p>Like <code>derivative</code>, but for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL175-L179">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient(::NewtonOptimizerCache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL42-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>gradient_fd!</code></a> for the finite differences version.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL183-L189">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><a class="docstring-binding" href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">gradient_fd!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the autodiff version.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/gradient.jl#LL261-L267">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><a class="docstring-binding" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">increase_iteration_number!(status)</code></pre><p>Increase iteration number of <code>status</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
increase_iteration_number!(status)
iteration_number(status)

# output

1</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL139-L155">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><a class="docstring-binding" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>SimpleSolvers.increase_iteration_number!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">increase_iteration_number!(result)</code></pre><p>Increase the iteration number of <code>result</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>. This calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>increase_iteration_number!(::OptimizerStatus)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_result.jl#LL85-L89">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><a class="docstring-binding" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">increase_iteration_number!(status)</code></pre><p>Increase the iteration number of a <code>status</code><a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a>. See <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!(::NonlinearSolverStatus)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL136-L140">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initialize!(hessian, x)</code></pre><p>See e.g. <a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>initialize!(::HessianAutodiff, ::AbstractVector)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL29-L33">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initialize!(H, x)</code></pre><p>Initialize a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/hessian.jl#LL179-L187">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Tuple{LinearProblem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initialize!(ls, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>ls</code>. See <a href="#SimpleSolvers.clear!-Tuple{NonlinearProblem}"><code>clear!(::LinearProblem)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL119-L123">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initialize!(status, x)</code></pre><p>Clear <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> (via the function <a href="#SimpleSolvers.clear!-Tuple{NonlinearProblem}"><code>clear!</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL267-L271">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initialize!(cache, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>.</p><p><strong>Implementation</strong></p><p>This calls <a href="#SimpleSolvers.alloc_x"><code>alloc_x</code></a> to do all the initialization.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_cache.jl#LL57-L65">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><a class="docstring-binding" href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">isaOptimizationAlgorithm(alg)</code></pre><p>Verify if an object implements the <a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a> interface.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL34-L38">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.j_argument-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.j_argument-Tuple{NonlinearProblem}"><code>SimpleSolvers.j_argument</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><p>j_argument(nlp)</p><p>Return the argument that was last used for evaluating <a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian, AbstractArray{T}, Any}} where T&lt;:Number"><code>jacobian!</code></a> for the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> <code>nlp</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL317-L321">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.j_calls-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.j_calls-Tuple{NonlinearProblem}"><code>SimpleSolvers.j_calls</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">j_calls(nlp)</code></pre><p>Like <a href="#SimpleSolvers.f_calls-Tuple{NonlinearProblem}"><code>f_calls</code></a> in relation to a <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> <code>nlp</code>, but for <a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver{T} where T}"><code>jacobian</code></a> (or <a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian, AbstractArray{T}, Any}} where T&lt;:Number"><code>jacobian!</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL357-L361">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, AbstractArray{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.jacobian!!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">jacobian!!(nlp::NonlinearProblem, jacobian::Jacobian, x, prams)</code></pre><p>Force the evaluation of the jacobian for a <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>. Like <a href="#SimpleSolvers.gradient!!-Tuple{OptimizerProblem, AbstractArray{&lt;:Number}}"><code>gradient!!</code></a> for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL241-L246">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian, AbstractArray{T}, Any}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian, AbstractArray{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.jacobian!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">jacobian!(nlp::NonlinearProblem, jacobian_instance, x, params)</code></pre><p>Compute the Jacobian of <code>nlp</code> at <code>x</code> and store it in <code>jacobian(nlp)</code>. Note that the evaluation of the Jacobian is not necessarily enforced here (unlike calling <a href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, AbstractArray{T}, Any}} where T"><code>jacobian!!</code></a>). Like <code>derivative!</code> for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL265-L270">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobian-Tuple{NewtonSolver{T} where T}"><a class="docstring-binding" href="#SimpleSolvers.jacobian-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.jacobian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">jacobian(solver::NewtonSolver)</code></pre><p>Return the evaluated Jacobian (a Matrix) stored in the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> of <code>solver</code>.</p><p>Also see <a href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>jacobian(::NonlinearProblem)</code></a> and <a href="#SimpleSolvers.Jacobian-Tuple{NonlinearProblem}"><code>Jacobian(::NonlinearProblem)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL126-L132">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.jacobian-Tuple{NonlinearProblem}"><code>SimpleSolvers.jacobian</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">jacobian(nlp::NonlinearProblem)</code></pre><p>Return the value of the jacobian stored in <code>nlp</code> (instance of <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a>). Like <a href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>gradient</code></a> for <a href="#SimpleSolvers.OptimizerProblem"><code>OptimizerProblem</code></a>.</p><p>Also see <a href="#SimpleSolvers.Jacobian-Tuple{NonlinearProblem}"><code>Jacobian(::NonlinearProblem)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL216-L223">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><a class="docstring-binding" href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.linearsolver</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">linearsolver(solver)</code></pre><p>Return the linear part (i.e. a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) of an <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = rand(3)
y = rand(3)
F(x) = tanh.(x)
F!(y, x, params) = y .= F(x)
s = NewtonSolver(x, y; F = F!)
linearsolver(s)

# output

LinearSolver{Float64, LU{Missing}, SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}}(LU{Missing}(missing, true), SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], [0, 0, 0], [0, 0, 0], 0))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL135-L154">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Tuple{NonlinearSolver, Any}"><code>SimpleSolvers.linesearch_problem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">linesearch_problem(nl::NonlinearSolver, params)</code></pre><p>Build a line search problem based on a <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a> (almost always a <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> in practice).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_linesearch_problem.jl#LL33-L37">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, Jacobian{T}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_problem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">linesearch_problem(nlp, cache, params)</code></pre><p>Make a line search problem for a <em>Newton solver</em> (the <code>cache</code> here is an instance of <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>).</p><p><strong>Implementation</strong></p><div class="admonition is-info" id="Producing-a-single-valued-output-ffe780b0771ed142"><header class="admonition-header">Producing a single-valued output<a class="admonition-anchor" href="#Producing-a-single-valued-output-ffe780b0771ed142" title="Permalink"></a></header><div class="admonition-body"><p>Different from the <code>linesearch_problem</code> for <code>NewtonOptimizerCache</code>s, we apply <code>l2norm</code> to the output of <code>objective!</code>. This is because the solver operates on an objective with multiple outputs from which we have to find roots, whereas an optimizer operates on an objective with a single output of which we should find a minimum.</p></div></div><p>Also see <a href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_problem(::OptimizerProblem{T}, ::NewtonOptimizerCache{T}) where {T}</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_linesearch_problem.jl#LL1-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><a class="docstring-binding" href="#SimpleSolvers.linesearch_problem-Union{Tuple{T}, Tuple{OptimizerProblem{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_problem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">linesearch_problem(objective, cache)</code></pre><p>Create <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> for linesearch algorithm. The variable on which this objective depends is <span>$\alpha$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = [1, 0., 0.]
f = x -&gt; sum(x .^ 3 / 6 + x .^ 2 / 2)
obj = OptimizerProblem(f, x)
gradient!(obj, x)
value!(obj, x)
cache = NewtonOptimizerCache(x)
hess = Hessian(obj, x; mode = :autodiff)
update!(hess, x)
update!(cache, x, obj.g, hess)
x‚ÇÇ = [.9, 0., 0.]
gradient!(obj, x‚ÇÇ)
value!(obj, x‚ÇÇ)
update!(hess, x‚ÇÇ)
update!(cache, x‚ÇÇ, obj.g, hess)
ls_obj = linesearch_problem(obj, cache)
Œ± = .1
(ls_obj.F(Œ±), ls_obj.D(Œ±))

# output

(0.4412947468016475, -0.8083161485821551)</code></pre><p>In the example above we have to apply <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!</code></a> twice on the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> because it needs to store the current <em>and</em> the previous iterate.</p><p><strong>Implementation</strong></p><p>Calling the function and derivative stored in the <a href="#SimpleSolvers.LinesearchProblem"><code>LinesearchProblem</code></a> created with <code>linesearch_problem</code> does not allocate a new array, but uses the one stored in the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_linesearch_problem.jl#LL1-L37">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Determines whether the iteration stops based on the current <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><div class="admonition is-category-warn" id="Warn-ad26e8f0c958d456"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-ad26e8f0c958d456" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>meets_stopping_criteria</code> may return <code>true</code> even if the solver has not converged. To check convergence, call <code>assess_convergence!</code> (with the same input arguments).</p></div></div><p>The function <code>meets_stopping_criteria</code> returns <code>true</code> if one of the following is satisfied:</p><ul><li>the <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> is converged (checked with <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>) and <code>iteration_number(status) ‚â• config.min_iterations</code>,</li><li><code>status.f_increased</code> and <code>config.allow_f_increases = false</code> (i.e. <code>f</code> increased even though we do not allow it),</li><li><code>iteration_number(status) ‚â• config.max_iterations</code>,</li><li>if any component in <code>solution(status)</code> is <code>NaN</code>,</li><li>if any component in <code>status.f</code> is <code>NaN</code>,</li><li><code>status.rx‚Çê &gt; config.x_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li><li><code>status.rf‚Çê &gt; config.f_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li></ul><p>So convergence is only one possible criterion for which <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>. We may also satisfy a stopping criterion without having convergence!</p><p><strong>Examples</strong></p><p>In the following example we show that <code>meets_stopping_criteria</code> evaluates to true when used on a freshly allocated <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
config = Options()
meets_stopping_criteria(status, config)

# output

true</code></pre><p>This obviously has not converged. To check convergence we can use <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>:</p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
config = Options()
assess_convergence!(status, config)

# output

false</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL185-L225">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Check if the optimizer has converged.</p><p><strong>Implementation</strong></p><p><code>meets_stopping_criteria</code> first calls <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and then checks if one of the following is true:</p><ul><li><code>converged</code> (the output of <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>) is <code>true</code> and <code>status.i</code> <span>$\geq$</span> <code>config.min_iterations</code>,</li><li>if <code>config.allow_f_increases</code> is <code>false</code>: <code>status.f_increased</code> is <code>true</code>,</li><li><code>status.i</code> <span>$\geq$</span> <code>config.max_iterations</code>,</li><li><code>status.rx‚Çê</code> <span>$&gt;$</span> <code>config.x_abstol_break</code></li><li><code>status.rx·µ£</code> <span>$&gt;$</span> <code>config.x_reltol_break</code></li><li><code>status.rf‚Çê</code> <span>$&gt;$</span> <code>config.f_abstol_break</code></li><li><code>status.rf·µ£</code> <span>$&gt;$</span> <code>config.f_reltol_break</code></li><li><code>status.rg</code>  <span>$&gt;$</span> <code>config.g_restol_break</code></li><li><code>status.x_isnan</code></li><li><code>status.f_isnan</code></li><li><code>status.g_isnan</code></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL168-L187">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.method-Tuple{LinearSolver}"><a class="docstring-binding" href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">method(ls)</code></pre><p>Return the method (of type <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL49-L53">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">minimum_decrease_threshold(T)</code></pre><p>The minimum value by which a function <span>$f$</span> should decrease during an iteration.</p><p>The default value of <span>$10^-4$</span> is often used in the literature [bierlaire2015optimization], nocedal2006numerical(@cite).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">minimum_decrease_threshold(Float64)

# output

0.0001</code></pre><pre><code class="language-julia hljs">minimum_decrease_threshold(Float32)

# output

0.0001f0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/options.jl#LL65-L89">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.nonlinearproblem-Tuple{FixedPointIterator{T} where T}"><a class="docstring-binding" href="#SimpleSolvers.nonlinearproblem-Tuple{FixedPointIterator{T} where T}"><code>SimpleSolvers.nonlinearproblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">nonlinearproblem(it)</code></pre><p>Return the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> contained in the <a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><code>FixedPointIterator</code></a>. Compare this to <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>linearsolver</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL59-L63">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.nonlinearproblem-Tuple{NewtonSolver{T} where T}"><a class="docstring-binding" href="#SimpleSolvers.nonlinearproblem-Tuple{NewtonSolver{T} where T}"><code>SimpleSolvers.nonlinearproblem</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">nonlinearproblem(solver)</code></pre><p>Return the <a href="#SimpleSolvers.NonlinearProblem"><code>NonlinearProblem</code></a> contained in the <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>. Compare this to <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver{T} where T}"><code>linearsolver</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL115-L119">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><a class="docstring-binding" href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">print_status(status, config)</code></pre><p>Print the solver status if:</p><ol><li>The following three are satisfied: (i) <code>config.verbosity</code> <span>$\geq1$</span> (ii) <code>assess_convergence!(status, config)</code> is <code>false</code> (iii) <code>iteration_number(status) &gt; config.max_iterations</code></li><li><code>config.verbosity &gt; 1</code>.</li></ol><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL125-L131">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><a class="docstring-binding" href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.residual!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">residual!(status)</code></pre><p>Compute the residuals for <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>. Note that this does not update <code>x</code>, <code>f</code>, <code>Œ¥</code> or <code>Œ≥</code>. These are updated with <a href="#GeometricBase.update!-Tuple{FixedPointIterator{T} where T, AbstractArray, Any}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearProblem)</code></a>. The computed residuals are the following:</p><ul><li><code>rx‚Çê</code>: absolute residual in <span>$x$</span>,</li><li><code>rx‚Çõ</code> : successive residual (the norm of <span>$\delta$</span>),</li><li><code>rf‚Çê</code>: absolute residual in <span>$f$</span>,</li><li><code>rf‚Çõ</code> : successive residual (the norm of <span>$\gamma$</span>).</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL245-L255">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><a class="docstring-binding" href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">residual!(status, x, xÃÑ, f, fÃÑ, g, gÃÑ)</code></pre><p>Compute the residual based on previous iterates (<code>xÃÑ</code>, <code>fÃÑ</code>, <code>gÃÑ</code>) and current iterates (<code>x</code>, <code>f</code>, <code>g</code>).</p><p>Also see <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_status.jl#LL79-L85">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><a class="docstring-binding" href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">residual!(result, x, f, g)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer_result.jl#LL30-L32">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/newton_optimizer_cache.jl#LL36-L40">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}"><a class="docstring-binding" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}"><code>SimpleSolvers.rhs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right-hand side of the equation, stored in <code>cache::</code><a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver_cache.jl#LL78-L82">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.shift_œá_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.shift_œá_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_œá_to_avoid_stalling</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">shift_œá_to_avoid_stalling(œá, a, b, c, Œµ)</code></pre><p>Check whether <code>b</code> is closer to <code>a</code> or <code>c</code> and shift <code>œá</code> accordingly.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linesearch/bierlaire_quadratic.jl#LL47-L51">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><a class="docstring-binding" href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.solution</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solution(status)</code></pre><p>Return the current value of <code>x</code> (i.e. the current solution).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/nonlinear_solver_status.jl#LL85-L89">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!"><a class="docstring-binding" href="#SimpleSolvers.solve!"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">solve!(it, x)</code></pre><p><strong>Extended help</strong></p><div class="admonition is-info" id="Info-b9c961a5b4c5910e"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-b9c961a5b4c5910e" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>update!</code> calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!</code></a>.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL89-L96">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, A, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$A$</span> and <span>$b$</span> are provided as an input arguments.</p><p><strong>implementation</strong></p><p>Note that, compared to <a href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>solve(::LinearSolver, ::AbstractVector)</code></a> this method involves an additional <em>factorization</em> of <code>A</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL104-L116">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$b$</span> is provided as an input argument and the factorized <span>$A$</span> is stored in the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> (respectively its <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL91-L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearProblem}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, lsys::LinearProblem)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>lsys</code> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> and store the result in <code>x</code>. Also see <a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>solve!(::LinearSolver, ::LinearProblem)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL72-L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(ls::LinearSolver, args...)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solvers.jl#LL82-L86">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{NewtonSolver{T} where T, AbstractArray}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{NewtonSolver{T} where T, AbstractArray}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(s, x)</code></pre><p><strong>Extended help</strong></p><div class="admonition is-info" id="Info-b9c961a5b4c5910e"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-b9c961a5b4c5910e" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>update!</code> calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!</code></a>.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/newton_solver.jl#LL189-L196">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}"><a class="docstring-binding" href="#SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.solve!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve!(x, opt)</code></pre><p>Solve the optimization problem described by <code>opt::</code><a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a> and store the result in <code>x</code>.</p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())

solve!(opt, x)

# output
2-element Vector{Float32}:
 4.6478817f-8
 3.0517578f-5</code></pre><p>We can also check how many iterations it took:</p><pre><code class="language-julia hljs">iteration_number(opt)

# output

12</code></pre><p>Too see the value of <code>x</code> after one iteration confer the docstring of <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL215-L243">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><a class="docstring-binding" href="#SimpleSolvers.solve-Tuple{LinearProblem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solve(ls, method)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearProblem"><code>LinearProblem</code></a> <code>ls</code> with the <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a> <code>method</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/linear/linear_solver_method.jl#LL12-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><a class="docstring-binding" href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{FixedPointIterator{T, AT, NLST, LST, JT, LSoT, LiSeT, CT, NSST} where {AT, NLST&lt;:(NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}), LST&lt;:SimpleSolvers.AbstractLinearProblem, JT&lt;:Jacobian{T}, LSoT&lt;:SimpleSolvers.AbstractLinearSolver, LiSeT&lt;:SimpleSolvers.LinesearchState{T}, CT&lt;:SimpleSolvers.NonlinearSolverCache{T}, NSST&lt;:(SimpleSolvers.NonlinearSolverStatus{T})}, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solver_step!(it, x, params)</code></pre><p>Solve the problem stored in an instance <code>it</code> of <a href="#SimpleSolvers.FixedPointIterator-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}}} where {T, AT&lt;:AbstractVector{T}}"><code>FixedPointIterator</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/nonlinear/fixed_point_iterator.jl#LL42-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)"><a class="docstring-binding" href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">solver_step!(x, state)</code></pre><p>Compute a full iterate for an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> <code>state</code>.</p><p>This also performs a line search.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())

solver_step!(opt, x)

# output

2-element Vector{Float32}:
 0.25
 0.6666666</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/optimization/optimizer.jl#LL177-L199">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><a class="docstring-binding" href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">triple_point_finder(f, x)</code></pre><p>Find three points <code>a &gt; b &gt; c</code> s.t. <code>f(a) &gt; f(b)</code> and <code>f(c) &gt; f(b)</code>. This is used for performing a quadratic line search (see <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>).</p><p><strong>Implementation</strong></p><p>For <code>Œ¥</code> we take <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> as default. For <code>nmax we take [</code>DEFAULT<em>BRACKETING</em>nmax`](@ref) as default.</p><p><strong>Extended help</strong></p><p>The algorithm is taken from [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1].</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/bracketing/triple_point_finder.jl#LL1-L13">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.value!!-Tuple{LinesearchProblem, Number}"><a class="docstring-binding" href="#SimpleSolvers.value!!-Tuple{LinesearchProblem, Number}"><code>SimpleSolvers.value!!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">value!!(obj::AbstractOptimizerProblem, x)</code></pre><p>Set <code>obj.x_f</code> to <code>x</code> and <code>obj.f</code> to <code>value(obj, x)</code> and return <code>value(obj)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL69-L73">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><a class="docstring-binding" href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractOptimizerProblem, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">value!(obj::AbstractOptimizerProblem, x)</code></pre><p>Check if <code>x</code> is not equal to <code>obj.x_f</code> and then apply <a href="#SimpleSolvers.value!!-Tuple{LinesearchProblem, Number}"><code>value!!</code></a>. Else simply return <code>value(obj)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/optimizer_problems.jl#LL79-L83">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number"><a class="docstring-binding" href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearProblem{T, FixedPoint, TF, TJ, Tx, Tf, Tj} where {FixedPoint, TF&lt;:Union{Function, Type}, TJ&lt;:Union{Missing, Function, Type}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.value!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">value!(nlp::NonlinearProblem, x)</code></pre><p>Check if <code>x</code> is not equal to <code>f_argument(nlp)</code> and then apply <a href="#SimpleSolvers.value!!-Tuple{LinesearchProblem, Number}"><code>value!!</code></a>. Else simply return <code>value(nlp)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/224d284bd3f78b810453779f0ebbecf6fa27c782/src/base/solver_problems.jl#LL204-L208">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="optimizer_problems/">Optimizer Problems ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 09:37">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
