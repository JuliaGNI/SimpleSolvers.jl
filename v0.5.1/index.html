<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SimpleSolvers.jl</title><meta name="title" content="Home · SimpleSolvers.jl"/><meta property="og:title" content="Home · SimpleSolvers.jl"/><meta property="twitter:title" content="Home · SimpleSolvers.jl"/><meta name="description" content="Documentation for SimpleSolvers.jl."/><meta property="og:description" content="Documentation for SimpleSolvers.jl."/><meta property="twitter:description" content="Documentation for SimpleSolvers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SimpleSolvers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SimpleSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="objectives/">Objectives</a></li><li><a class="tocitem" href="gradients/">Gradients</a></li><li><a class="tocitem" href="jacobians/">Jacobians</a></li><li><a class="tocitem" href="hessians/">Hessians</a></li><li><span class="tocitem">Line Search</span><ul><li><a class="tocitem" href="linesearch/linesearch/">Line Searches</a></li><li><a class="tocitem" href="linesearch/static/">Static</a></li><li><a class="tocitem" href="linesearch/sufficient_decrease_condition/">The Sufficient Decrease Condition</a></li><li><a class="tocitem" href="linesearch/curvature_condition/">The Curvature Condition</a></li><li><a class="tocitem" href="linesearch/backtracking/">Backtracking</a></li><li><a class="tocitem" href="linesearch/bisections/">Bisections</a></li><li><a class="tocitem" href="linesearch/quadratic/">Quadratic</a></li><li><a class="tocitem" href="linesearch/bierlaire_quadratic/">Bierlaire Quadratic</a></li></ul></li><li><span class="tocitem">Optimizers</span><ul><li><a class="tocitem" href="optimizers/optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="update/">Updates</a></li><li><a class="tocitem" href="initialize/">Initialization</a></li><li><a class="tocitem" href="linear/linear_solvers/">Linear Solvers</a></li><li><a class="tocitem" href="nonlinear_solver_status/">Solver Status</a></li><li><a class="tocitem" href="in_place_out_of_place/">In-place vs out-of-place</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/main/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SimpleSolvers"><a class="docs-heading-anchor" href="#SimpleSolvers">SimpleSolvers</a><a id="SimpleSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleSolvers" title="Permalink"></a></h1><ul><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a></li><li><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a></li><li><a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a></li><li><a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a></li><li><a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a></li><li><a href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a></li><li><a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a></li><li><a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a></li><li><a href="#SimpleSolvers.AbstractObjective"><code>SimpleSolvers.AbstractObjective</code></a></li><li><a href="#SimpleSolvers.AbstractUnivariateObjective"><code>SimpleSolvers.AbstractUnivariateObjective</code></a></li><li><a href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a></li><li><a href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a></li><li><a href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a></li><li><a href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a></li><li><a href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a></li><li><a href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a></li><li><a href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a></li><li><a href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a></li><li><a href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a></li><li><a href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a></li><li><a href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a></li><li><a href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.Jacobian-Tuple{NonlinearSystem}"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.Jacobian-Tuple{NewtonSolver}"><code>SimpleSolvers.Jacobian</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a></li><li><a href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a></li><li><a href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a></li><li><a href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a></li><li><a href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a></li><li><a href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a></li><li><a href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a></li><li><a href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a></li><li><a href="#SimpleSolvers.LinearSystem"><code>SimpleSolvers.LinearSystem</code></a></li><li><a href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a></li><li><a href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a></li><li><a href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a></li><li><a href="#SimpleSolvers.MultivariateObjective"><code>SimpleSolvers.MultivariateObjective</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a></li><li><a href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a></li><li><a href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a></li><li><a href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a></li><li><a href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a></li><li><a href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a></li><li><a href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a></li><li><a href="#SimpleSolvers.NonlinearSystem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearSystem</code></a></li><li><a href="#SimpleSolvers.NonlinearSystem-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>SimpleSolvers.NonlinearSystem</code></a></li><li><a href="#SimpleSolvers.NonlinearSystem"><code>SimpleSolvers.NonlinearSystem</code></a></li><li><a href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a></li><li><a href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a></li><li><a href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a></li><li><a href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a></li><li><a href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a></li><li><a href="#SimpleSolvers.Quadratic2"><code>SimpleSolvers.Quadratic2</code></a></li><li><a href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a></li><li><a href="#SimpleSolvers.QuadraticState2"><code>SimpleSolvers.QuadraticState2</code></a></li><li><a href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a></li><li><a href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a></li><li><a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a></li><li><a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>SimpleSolvers.TemporaryUnivariateObjective</code></a></li><li><a href="#SimpleSolvers.UnivariateObjective"><code>SimpleSolvers.UnivariateObjective</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearSystem, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{Optimizer, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{NewtonSolver, AbstractArray, Any}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{MultivariateObjective, AbstractVector}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a></li><li><a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a></li><li><a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a></li><li><a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a></li><li><a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_α</code></a></li><li><a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a></li><li><a href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a></li><li><a href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a></li><li><a href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a></li><li><a href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a></li><li><a href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a></li><li><a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a></li><li><a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a></li><li><a href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a></li><li><a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a></li><li><a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a></li><li><a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a></li><li><a href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a></li><li><a href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a></li><li><a href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a></li><li><a href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{NonlinearSystem}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>SimpleSolvers.clear!</code></a></li><li><a href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a></li><li><a href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a></li><li><a href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a></li><li><a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a></li><li><a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a></li><li><a href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative</code></a></li><li><a href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!</code></a></li><li><a href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!!</code></a></li><li><a href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a></li><li><a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a></li><li><a href="#SimpleSolvers.f_argument-Tuple{NonlinearSystem}"><code>SimpleSolvers.f_argument</code></a></li><li><a href="#SimpleSolvers.f_calls-Tuple{NonlinearSystem}"><code>SimpleSolvers.f_calls</code></a></li><li><a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a></li><li><a href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient-Tuple{MultivariateObjective}"><code>SimpleSolvers.gradient</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a></li><li><a href="#SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a></li><li><a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a></li><li><a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{LinearSystem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a></li><li><a href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a></li><li><a href="#SimpleSolvers.j_argument-Tuple{NonlinearSystem}"><code>SimpleSolvers.j_argument</code></a></li><li><a href="#SimpleSolvers.j_calls-Tuple{NonlinearSystem}"><code>SimpleSolvers.j_calls</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{NonlinearSystem}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver}"><code>SimpleSolvers.jacobian</code></a></li><li><a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.jacobian!</code></a></li><li><a href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.jacobian!!</code></a></li><li><a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver}"><code>SimpleSolvers.linearsolver</code></a></li><li><a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_objective</code></a></li><li><a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>SimpleSolvers.linesearch_objective</code></a></li><li><a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_objective</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a></li><li><a href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a></li><li><a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a></li><li><a href="#SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.next_iteration!</code></a></li><li><a href="#SimpleSolvers.nonlinearsystem-Tuple{NewtonSolver}"><code>SimpleSolvers.nonlinearsystem</code></a></li><li><a href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a></li><li><a href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a></li><li><a href="#SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_χ_to_avoid_stalling</code></a></li><li><a href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.solution</code></a></li><li><a href="#SimpleSolvers.solve-Tuple{LinearSystem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{NewtonSolver, AbstractArray}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearSystem}"><code>SimpleSolvers.solve!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a></li><li><a href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a></li><li><a href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.value!</code></a></li><li><a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a></li><li><a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>SimpleSolvers.value!!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_p" href="#SimpleSolvers.DEFAULT_ARMIJO_p"><code>SimpleSolvers.DEFAULT_ARMIJO_p</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_p</code></pre><p>Constant used in <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_α₀" href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>SimpleSolvers.DEFAULT_ARMIJO_α₀</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_α₀</code></pre><p>The default starting value for <span>$\alpha$</span> used in <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> (also see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). Its value is 1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_σ₀" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₀</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₀</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>.</p><p>It is meant to <em>safeguard against stagnation</em> when performing line searches (see [<a href="references/#kelley1995iterative">1</a>]).</p><p>Its value is 0.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ARMIJO_σ₁" href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>SimpleSolvers.DEFAULT_ARMIJO_σ₁</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_ARMIJO_σ₁</code></pre><p>Constant used in <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a>. Its value is 0.5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BIERLAIRE_ε" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ε</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ε</code></pre><p>A constant that determines the <em>precision</em> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. The constant recommended in [<a href="references/#bierlaire2015optimization">2</a>] is <code>1E-3</code>.</p><p>Note that this constant may also depend on whether we deal with optimizers or solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bierlaire_quadratic.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BIERLAIRE_ξ" href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>SimpleSolvers.DEFAULT_BIERLAIRE_ξ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_BIERLAIRE_ξ</code></pre><p>A constant on basis of which the <code>b</code> in <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a> is perturbed in order &quot;to avoid stalling&quot; (see [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1]; in this reference the author recommends <span>$10^{-7}$</span> as a value). Its value is 1.1920928955078125e-7.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bierlaire_quadratic.jl#LL10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_k" href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>SimpleSolvers.DEFAULT_BRACKETING_k</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_k</code></pre><p>Gives the default ratio by which the bracket is increased if bracketing was not successful. See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_nmax" href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>SimpleSolvers.DEFAULT_BRACKETING_nmax</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Default constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_BRACKETING_s" href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>SimpleSolvers.DEFAULT_BRACKETING_s</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_BRACKETING_s</code></pre><p>Gives the default width of the interval (the bracket). See <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_GRADIENT_ϵ" href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>SimpleSolvers.DEFAULT_GRADIENT_ϵ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_GRADIENT_ϵ</code></pre><p>A constant on whose basis finite differences are computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER" href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The default number of iterations before the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is refactored in the <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_JACOBIAN_ϵ" href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>SimpleSolvers.DEFAULT_JACOBIAN_ϵ</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DEFAULT_JACOBIAN_ϵ</code></pre><p>A constant used for computing the finite difference Jacobian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_WOLFE_c₁" href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>SimpleSolvers.DEFAULT_WOLFE_c₁</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DEFAULT_WOLFE_c₁</code></pre><p>A constant <span>$\epsilon$</span> on which a finite difference approximation of the derivative of the objective is computed. This is then used in the following stopping criterion:</p><p class="math-container">\[\frac{f(\alpha) - f(\alpha_0)}{\epsilon} &lt; \alpha\cdot{}f&#39;(\alpha_0).\]</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL37-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.DEFAULT_s_REDUCTION" href="#SimpleSolvers.DEFAULT_s_REDUCTION"><code>SimpleSolvers.DEFAULT_s_REDUCTION</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A factor by which <code>s</code> is reduced in each bracketing iteration (see <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/custom_quadratic.jl#LL6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH" href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This constant is used for <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> and <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/custom_quadratic.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.N_STATIC_THRESHOLD" href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>SimpleSolvers.N_STATIC_THRESHOLD</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Threshold for the maximum size a static matrix should have.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.AbstractObjective" href="#SimpleSolvers.AbstractObjective"><code>SimpleSolvers.AbstractObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractObjective</code></pre><p>An <em>objective</em> is a quantity to has to be made zero by a solver or minimized by an optimizer.</p><p>See <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> and <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.AbstractUnivariateObjective" href="#SimpleSolvers.AbstractUnivariateObjective"><code>SimpleSolvers.AbstractUnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractUnivariateObjective &lt;: AbstractObjective</code></pre><p>A subtype of <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a> that only depends on one variable. See <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Backtracking" href="#SimpleSolvers.Backtracking"><code>SimpleSolvers.Backtracking</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Backtracking &lt;: LinesearchMethod</code></pre><p>The <em>backtracking</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Backtracking()</code></pre><p><strong>Extended help</strong></p><p>The backtracking algorithm starts by setting <span>$y_0 \gets f(0)$</span> and <span>$d_0 \gets \nabla_0f$</span>.</p><p>The algorithm is executed by calling the functor of <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>.</p><p>The following is then repeated until the stopping criterion is satisfied or <code>config.max_iterations</code> (1000 by default) is reached:</p><pre><code class="language-julia hljs">if value!(obj, α) ≥ y₀ + ls.ϵ * α * d₀
    α *= ls.p
else
    break
end</code></pre><p>The stopping criterion as an equation can be written as:</p><p class="math-container">\[f(lpha) &lt; y_0 + psilon lpha 
abla_0f = y_0 + psilon (lpha - 0)
abla_0f.\]</p><p>Note that if the stopping criterion is not reached, <span>$lpha$</span> is multiplied with <span>$p$</span> and the process continues.</p><p><a href="https://en.wikipedia.org/wiki/Backtracking_line_search">Sometimes</a> the parameters <span>$p$</span> and <span>$psilon$</span> have different names such as <span>$au$</span> and <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL18-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BacktrackingCondition" href="#SimpleSolvers.BacktrackingCondition"><code>SimpleSolvers.BacktrackingCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BacktrackingCondition</code></pre><p>Abstract type comprising the conditions that are used for checking step sizes for the backtracking line search (see <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/condition.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BacktrackingState" href="#SimpleSolvers.BacktrackingState"><code>SimpleSolvers.BacktrackingState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BacktrackingState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>.</p><p><strong>Keys</strong></p><p>The keys are:</p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>α₀</code>: </li><li><code>ϵ=$(DEFAULT_WOLFE_c₁)</code>: a default step size on whose basis we compute a finite difference approximation of the derivative of the objective. Also see <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a>.</li><li><code>p=$(DEFAULT_ARMIJO_p)</code>: a parameter with which <span>$\alpha$</span> is decreased in every step until the stopping criterion is satisfied.</li></ul><p><strong>Functor</strong></p><p>The functor is used the following way:</p><pre><code class="language-julia hljs">ls(obj, α = ls.α₀)</code></pre><p><strong>Implementation</strong></p><p>The algorithm starts by setting:</p><p class="math-container">\[x_0 \gets 0,
y_0 \gets f(x_0),
d_0 \gets f&#39;(x_0),
\alpha \gets \alpha_0,\]</p><p>where <span>$f$</span> is the <em>univariate objective</em> (of type <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>) and <span>$\alpha_0$</span> is stored in <code>ls</code>. It then repeatedly does <span>$\alpha \gets \alpha\cdot{}p$</span> until either (i) the maximum number of iterations is reached (the <code>max_iterations</code> keyword in <a href="#SimpleSolvers.Options"><code>Options</code></a>) or (ii) the following holds:</p><p class="math-container">\[    f(\alpha) &lt; y_0 + \epsilon \cdot \alpha \cdot d_0,\]</p><p>where <span>$\epsilon$</span> is stored in <code>ls</code>.</p><div class="admonition is-info" id="Info-72fed8c52c6e36b1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-72fed8c52c6e36b1" title="Permalink"></a></header><div class="admonition-body"><p>The algorithm allocates an instance of <code>SufficientDecreaseCondition</code> by calling <code>SufficientDecreaseCondition(ls.ϵ, x₀, y₀, d₀, one(α), obj)</code>, here we take the <em>value one</em> for the search direction <span>$p$</span>, this is because we already have the search direction encoded into the line search objective.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/backtracking.jl#LL52-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BierlaireQuadratic" href="#SimpleSolvers.BierlaireQuadratic"><code>SimpleSolvers.BierlaireQuadratic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BierlaireQuadratic &lt;: LinesearchMethod</code></pre><p>Algorithm taken from [<a href="references/#bierlaire2015optimization">2</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BierlaireQuadraticState" href="#SimpleSolvers.BierlaireQuadraticState"><code>SimpleSolvers.BierlaireQuadraticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BierlaireQuadraticState &lt;: LinesearchState</code></pre><p><strong>Extended help</strong></p><p>Note that the performance of <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a> may heavily depend on the choice of <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ε"><code>DEFAULT_BIERLAIRE_ε</code></a> (i.e. the precision) and <a href="#SimpleSolvers.DEFAULT_BIERLAIRE_ξ"><code>DEFAULT_BIERLAIRE_ξ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bierlaire_quadratic.jl#LL18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Bisection" href="#SimpleSolvers.Bisection"><code>SimpleSolvers.Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bisection &lt;: LinesearchMethod</code></pre><p>The <em>bisection</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Bisection()</code></pre><p><strong>Extended help</strong></p><p>The bisection algorithm starts with an interval and successively bisects it into smaller intervals until a root is found. See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL55-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BisectionState" href="#SimpleSolvers.BisectionState"><code>SimpleSolvers.BisectionState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BisectionState &lt;: LinesearchState</code></pre><p>Corresponding <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> to <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>.</p><p>See <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> for the implementation of the algorithm.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">BisectionState(options)
BisectionState(; options)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bisection.jl#LL86-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.BracketMinimumCriterion" href="#SimpleSolvers.BracketMinimumCriterion"><code>SimpleSolvers.BracketMinimumCriterion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BracketMinimumCriterion &lt;: BracketingCriterion</code></pre><p>The criterion used for <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>.</p><p><strong>Functor</strong></p><pre><code class="language-julia hljs">bc(yb, yc)</code></pre><p>This checks whether <code>yc</code> is bigger than <code>yb</code>, i.e. whether <code>c</code> is <em>past the minimum</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.CurvatureCondition" href="#SimpleSolvers.CurvatureCondition"><code>SimpleSolvers.CurvatureCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CurvatureCondition &lt;: LinesearchCondition</code></pre><p>The second of the Wolfe conditions [<a href="references/#nocedal2006numerical">3</a>]. The first one is the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a>.</p><p>This encompasses the <em>standard curvature condition</em> and the <em>strong curvature condition</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CurvatureCondition(c, xₖ, gradₖ, pₖ, obj, grad; mode)</code></pre><p>Here <code>grad</code> has to be a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>obj</code> an <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a>. The other inputs are either arrays or numbers.</p><p><strong>Implementation</strong></p><p>For computational reasons <code>CurvatureCondition</code> also has a field <code>gradₖ₊₁</code> in which the temporary new gradient is saved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/curvature_condition.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Gradient" href="#SimpleSolvers.Gradient"><code>SimpleSolvers.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient</code></pre><p>Abstract type. <code>strcut</code>s that are derived from this need an assoicated functor that computes the gradient of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Gradient</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (grad::Gradient)(g::AbstractVector, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.GradientFunction"><code>GradientFunction</code></a></li><li><a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a></li><li><a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientAutodiff" href="#SimpleSolvers.GradientAutodiff"><code>SimpleSolvers.GradientAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientAutodiff &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>∇config</code>: result of applying <code>ForwardDiff.GradientConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GradientAutodiff(F, x::AbstractVector)
GradientAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = ForwardDiff.gradient!(g, grad.F, x, grad.∇config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL139-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientFiniteDifferences" href="#SimpleSolvers.GradientFiniteDifferences"><code>SimpleSolvers.GradientFiniteDifferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientFiniteDifferences &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>e</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">GradientFiniteDifferences{T}(F, nx::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_GRADIENT_ϵ"><code>DEFAULT_GRADIENT_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x,g)
    ϵⱼ = grad.ϵ * x[j] + grad.ϵ
    fill!(grad.e, 0)
    grad.e[j] = 1
    grad.tx .= x .- ϵⱼ .* grad.e
    f1 = grad.F(grad.tx)
    grad.tx .= x .+ ϵⱼ .* grad.e
    f2 = grad.F(grad.tx)
    g[j] = (f2 - f1) / (2ϵⱼ)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL195-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.GradientFunction" href="#SimpleSolvers.GradientFunction"><code>SimpleSolvers.GradientFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientFunction &lt;: Gradient</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>∇F!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">grad(g, x) = grad.∇F!(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Hessian" href="#SimpleSolvers.Hessian"><code>SimpleSolvers.Hessian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian</code></pre><p>Abstract type. <code>struct</code>s derived from this need an associated functor that computes the Hessian of a function (in-place).</p><p>Also see <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Implementation</strong></p><p>When a custom <code>Hessian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (hessian::Hessian)(h::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.HessianFunction"><code>HessianFunction</code></a></li><li><a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a></li><li><a href="#SimpleSolvers.HessianBFGS"><code>HessianBFGS</code></a></li><li><a href="#SimpleSolvers.HessianDFP"><code>HessianDFP</code></a></li></ul><p>These examples can also be called with e.g. <code>Hessian(x; mode = :autodiff)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianAutodiff" href="#SimpleSolvers.HessianAutodiff"><code>SimpleSolvers.HessianAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianAutodiff &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes <a href="update/#Hessian"><code>Hessian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>H</code>: a matrix in which the (updated) <a href="update/#Hessian"><code>Hessian</code></a> is stored. </li><li><code>Hconfig</code>: result of applying <code>ForwardDiff.HessianConfig</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HessianAutodiff(F, x::AbstractVector)
HessianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(g, x) = ForwardDiff.hessian!(hes.H, hes.F, x, grad.Hconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL123-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianBFGS" href="#SimpleSolvers.HessianBFGS"><code>SimpleSolvers.HessianBFGS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianBFGS &lt;: Hessian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/hessian_bfgs.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianDFP" href="#SimpleSolvers.HessianDFP"><code>SimpleSolvers.HessianDFP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianDFP &lt;: Hessian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/hessian_dfp.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.HessianFunction" href="#SimpleSolvers.HessianFunction"><code>SimpleSolvers.HessianFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HessianFunction &lt;: Hessian</code></pre><p>A <code>struct</code> that realizes a <a href="update/#Hessian"><code>Hessian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>H!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">hes(H, x) = hes.H!(H, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Jacobian" href="#SimpleSolvers.Jacobian"><code>SimpleSolvers.Jacobian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian</code></pre><p>Abstract type. <code>struct</code>s that are derived from this need an associated functor that computes the Jacobian of a function (in-place).</p><p><strong>Implementation</strong></p><p>When a custom <code>Jacobian</code> is implemented, a functor is needed:</p><pre><code class="language-julia hljs">function (j::Jacobian)(g::AbstractMatrix, x::AbstractVector) end</code></pre><p>This functor can also be called with <a href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><code>compute_jacobian!</code></a>.</p><p><strong>Examples</strong></p><p>Examples include:</p><ul><li><a href="#SimpleSolvers.JacobianFunction"><code>JacobianFunction</code></a></li><li><a href="#SimpleSolvers.JacobianAutodiff"><code>JacobianAutodiff</code></a></li><li><a href="#SimpleSolvers.JacobianFiniteDifferences"><code>JacobianFiniteDifferences</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Jacobian-Tuple{NewtonSolver}" href="#SimpleSolvers.Jacobian-Tuple{NewtonSolver}"><code>SimpleSolvers.Jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian(solver::NewtonSolver)</code></pre><p>Return the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> stored in the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> of <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Jacobian-Tuple{NonlinearSystem}" href="#SimpleSolvers.Jacobian-Tuple{NonlinearSystem}"><code>SimpleSolvers.Jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian(x, nls::NonlinearSystem)</code></pre><p>Return the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> stored in <code>nls</code>. Also see <a href="#SimpleSolvers.jacobian-Tuple{NonlinearSystem}"><code>jacobian(::NonlinearSystem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianAutodiff" href="#SimpleSolvers.JacobianAutodiff"><code>SimpleSolvers.JacobianAutodiff</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianAutodiff &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using <code>ForwardDiff</code>.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>Jconfig</code>: result of applying <code>ForwardDiff.JacobianConfig</code>.</li><li><code>ty</code>: vector that is used for evaluating <code>ForwardDiff.jacobian!</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">JacobianAutodiff(F, y::AbstractVector)
JacobianAutodiff(F, nx::Integer)</code></pre><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(J, x) = ForwardDiff.jacobian!(J, jac.ty, x, grad.Jconfig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL102-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianFiniteDifferences" href="#SimpleSolvers.JacobianFiniteDifferences"><code>SimpleSolvers.JacobianFiniteDifferences</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianFiniteDifferences &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by using finite differences.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>F</code>: a function that has to be differentiated.</li><li><code>ϵ</code>: small constant on whose basis the finite differences are computed.</li><li><code>f1</code>:</li><li><code>f2</code>:</li><li><code>e1</code>: auxiliary vector used for computing finite differences. It&#39;s of the form <span>$e_1 = \begin{bmatrix} 1 &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix}$</span>.</li><li><code>e2</code>:</li><li><code>tx</code>: auxiliary vector used for computing finite differences. It stores the offset in the <code>x</code> vector.</li></ul><p><strong>Constructor(s)</strong></p><pre><code class="language-julia hljs">JacobianFiniteDifferences{T}(F, nx::Integer, ny::Integer; ϵ)</code></pre><p>By default for <code>ϵ</code> is <a href="#SimpleSolvers.DEFAULT_JACOBIAN_ϵ"><code>DEFAULT_JACOBIAN_ϵ</code></a>.</p><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">for j in eachindex(x)
    ϵⱼ = jac.ϵ * x[j] + jac.ϵ
    fill!(jac.e, 0)
    jac.e[j] = 1
    jac.tx .= x .- ϵⱼ .* jac.e
    f(jac.f1, jac.tx)
    jac.tx .= x .+ ϵⱼ .* jac.e
    f(jac.f2, jac.tx)
    for i in eachindex(x)
        J[i,j] = (jac.f2[i] - jac.f1[i]) / (2ϵⱼ)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL156-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.JacobianFunction" href="#SimpleSolvers.JacobianFunction"><code>SimpleSolvers.JacobianFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JacobianFunction &lt;: Jacobian</code></pre><p>A <code>struct</code> that realizes a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> by explicitly supplying a function.</p><p><strong>Keys</strong></p><p>The <code>struct</code> stores:</p><ul><li><code>DF!</code>: a function that can be applied in place.</li></ul><p><strong>Functor</strong></p><p>The functor does:</p><pre><code class="language-julia hljs">jac(g, x) = jac.DF!(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL65-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LU" href="#SimpleSolvers.LU"><code>SimpleSolvers.LU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LU &lt;: LinearSolverMethod</code></pre><p>A custom implementation of an LU solver, meant to solve a <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a>.</p><p>Routines that use the LU solver include <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>, <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> and <a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>solve!</code></a>. In practice the <code>LU</code> solver is used by calling the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> constructor and <a href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>ldiv!</code></a> or <a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>solve!</code></a>, or with an instance of <code>LU</code> as an argument directly, as shown in the <em>Example section</em> of this docstring.</p><p><strong>constructor</strong></p><p>The constructor is called with either no argument:</p><pre><code class="language-julia hljs">LU()

# output

LU{Missing}(missing, true)</code></pre><p>or with <code>pivot</code> and <code>static</code> as optional booleans:</p><pre><code class="language-julia hljs">LU(; pivot=true, static=true)

# output

LU{Bool}(true, true)</code></pre><p>Note that if we do not supply an explicit keyword <code>static</code>, the corresponding field is <code>missing</code> (as in the first case). Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p><p><strong>Example</strong></p><p>We use the <code>LU</code> together with <a href="#SimpleSolvers.solve-Tuple{LinearSystem, SimpleSolvers.LinearSolverMethod}"><code>solve</code></a> to solve a linear system:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
v = rand(3)
ls = LinearSystem(A, v)
update!(ls, A, v)

lu = LU()

solve(lu, ls) ≈ inv(A) * v

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LUSolverCache" href="#SimpleSolvers.LUSolverCache"><code>SimpleSolvers.LUSolverCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LUSolverCache &lt;: LinearSolverCache</code></pre><p><strong>Keys</strong></p><ul><li><code>A</code>: the factorized matrix <code>A</code>,</li><li><code>pivots</code>:</li><li><code>perms</code>:</li><li><code>info</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL73-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LUSolverLAPACK" href="#SimpleSolvers.LUSolverLAPACK"><code>SimpleSolvers.LUSolverLAPACK</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LUSolverLAPACK &lt;: LinearSolver</code></pre><p>The LU Solver taken from <code>LinearAlgebra.BLAS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver_lapack.jl#LL4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinearSolver" href="#SimpleSolvers.LinearSolver"><code>SimpleSolvers.LinearSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSolver &lt;: AbstractSolver</code></pre><p>A struct that stores <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>s and <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>s. <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s are used to solve <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a>s.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LinearSolver(method, cache)
LinearSolver(method, A)
LinearSolver(method, ls::LinearSystem)
LinearSolver(method, x)</code></pre><div class="admonition is-info" id="Info-b2f1a0368587c358"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-b2f1a0368587c358" title="Permalink"></a></header><div class="admonition-body"><p>We note that the constructors do not call the function <code>factorize</code>, so only allocate a new matrix. The factorization needs to be done manually.</p></div></div><p>You can manually factorize by either calling <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a> or <a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>solve!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinearSolverCache" href="#SimpleSolvers.LinearSolverCache"><code>SimpleSolvers.LinearSolverCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSolverCache</code></pre><p>An abstract type that summarizes all the caches used for <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>s. See e.g. <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solver_cache.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinearSolverMethod" href="#SimpleSolvers.LinearSolverMethod"><code>SimpleSolvers.LinearSolverMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSolverMethod &lt;: SolverMethod</code></pre><p>Summarizes all the methods used for solving <em>linear systems of equations</em> such as the <a href="#SimpleSolvers.LU"><code>LU</code></a> method.</p><p><strong>Extended help</strong></p><p>The abstract type <code>SolverMethod</code> was imported from <code>GeometricBase</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solver_method.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinearSystem" href="#SimpleSolvers.LinearSystem"><code>SimpleSolvers.LinearSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearSystem</code></pre><p>A <code>LinearSystem</code> describes <span>$Ax = y$</span>, where we want to solve for <span>$x$</span>.</p><p><strong>Keys</strong></p><ul><li><code>A</code></li><li><code>y</code></li></ul><p><strong>Constructors</strong></p><p>A <code>LinearSystem</code> can be allocated by calling:</p><pre><code class="language-julia hljs">LinearSystem(A, y)
LinearSystem)(A)
LinearSystem(y)
LinearSystem{T}(n, m)
LinearSystem{T}(n)</code></pre><p>Note that in any case the allocated system is initialized with <code>NaN</code>s:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 4. 5. 6.; 7. 8. 9.]
y = [1., 2., 3.]
ls = LinearSystem(A, y)

# output

LinearSystem{Float64, Vector{Float64}, Matrix{Float64}}([NaN NaN NaN; NaN NaN NaN; NaN NaN NaN], [NaN, NaN, NaN])</code></pre><p>In order to initialize the system with values, we have to call <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!</code></a>:</p><pre><code class="language-julia hljs">update!(ls, A, y)

# output

LinearSystem{Float64, Vector{Float64}, Matrix{Float64}}([1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0], [1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Linesearch" href="#SimpleSolvers.Linesearch"><code>SimpleSolvers.Linesearch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Linesearch</code></pre><p>A <code>struct</code> that stores the <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a>, the <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>state::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li></ul><p><strong>Constructors</strong></p><p>The following constructors can be used:</p><pre><code class="language-julia hljs">Linesearch(alg, config, state)
Linesearch(; algorithm, config, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/linesearch.jl#LL56-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinesearchMethod" href="#SimpleSolvers.LinesearchMethod"><code>SimpleSolvers.LinesearchMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinesearchMethod</code></pre><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.Backtracking"><code>Backtracking</code></a>, <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a> and <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>. See these examples for specific information on linesearch algorithms.</p><p><strong>Extended help</strong></p><p>A <code>LinesearchMethod</code> always goes together with a <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and each of those <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a>s has a functor implemented:</p><pre><code class="language-julia hljs">ls(obj, α)</code></pre><p>where obj is a <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> and <code>α</code> is an initial <em>step size</em>. The output of this functor is then a final step size that is used for updating the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.LinesearchState" href="#SimpleSolvers.LinesearchState"><code>SimpleSolvers.LinesearchState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinesearchState</code></pre><p>Abstract type. </p><p>Examples include <a href="#SimpleSolvers.StaticState"><code>StaticState</code></a>, <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>, <a href="#SimpleSolvers.BisectionState"><code>BisectionState</code></a> and <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>.</p><p><strong>Implementation</strong></p><p>A <code>struct</code> that is subtyped from <code>LinesearchState</code> needs to implement the functors:</p><pre><code class="language-julia hljs">ls(x; kwargs...)
ls(obj::AbstractUnivariateObjective, x; kwargs...)</code></pre><p>Additionaly the following function needs to be extended:</p><pre><code class="language-julia hljs">LinesearchState(algorithm::LinesearchMethod; kwargs...)</code></pre><p><strong>Constructors</strong></p><p>The following is used to construct a specific line search state based on a <a href="#SimpleSolvers.LinesearchMethod"><code>LinesearchMethod</code></a>:</p><pre><code class="language-julia hljs">LinesearchState(algorithm::LinesearchMethod; T::DataType=Float64, kwargs...)</code></pre><p>where the data type should be specified each time the constructor is called. This is done automatically when calling the constructor of <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> for example.</p><p><strong>Functors</strong></p><p>The following functors are auxiliary helper functions:</p><pre><code class="language-julia hljs">ls(f::Callable; kwargs...) = ls(TemporaryUnivariateObjective(f, missing); kwargs...)
ls(f::Callable, x::Number; kwargs...) = ls(TemporaryUnivariateObjective(f, missing), x; kwargs...)
ls(f::Callable, g::Callable; kwargs...) = ls(TemporaryUnivariateObjective(f, g); kwargs...)
ls(f::Callable, g::Callable, x::Number; kwargs...) = ls(TemporaryUnivariateObjective(f, g), x; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/linesearch.jl#LL4-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.MultivariateObjective" href="#SimpleSolvers.MultivariateObjective"><code>SimpleSolvers.MultivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultivariateObjective &lt;: AbstractObjective</code></pre><p>Like <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>, but stores <em>gradients</em> instead of <em>derivatives</em>. Also compare this to <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a>.</p><p>The type of the <em>stored gradient</em> has to be a subtype of <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a>.</p><p><strong>Functor</strong></p><p>If <code>MultivariateObjective</code> is called on a single function, the gradient is generated with <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL293-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonOptimizerCache" href="#SimpleSolvers.NewtonOptimizerCache"><code>SimpleSolvers.NewtonOptimizerCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonOptimizerCache</code></pre><p><strong>Keys</strong></p><ul><li><code>x̄</code>: the previous iterate,</li><li><code>x</code>: current iterate (this stores the guess called by the functions generated with <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>),</li><li><code>δ</code>: direction of optimization step (difference between <code>x</code> and <code>x̄</code>); this is obtained by multiplying <code>rhs</code> with the inverse of the Hessian,</li><li><code>g</code>: gradient value (this stores the gradient associated with <code>x</code> called by the <em>derivative part</em> of <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>),</li><li><code>rhs</code>: the right hand side used to compute the update.</li></ul><p>To understand how these are used in practice see e.g. <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>.</p><p>Also compare this to <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonOptimizerState" href="#SimpleSolvers.NewtonOptimizerState"><code>SimpleSolvers.NewtonOptimizerState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonOptimizerState &lt;: OptimizationAlgorithm</code></pre><p>The optimizer state is needed to update the <a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a>. This is different to <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> and <a href="update/#OptimizerResult"><code>OptimizerResult</code></a> which serve as diagnostic tools. It stores a <a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a> and a <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> which is used to compute the line search objective at each iteration.</p><p><strong>Keys</strong></p><ul><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>cache::</code><a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_state.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonSolver" href="#SimpleSolvers.NewtonSolver"><code>SimpleSolvers.NewtonSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonSolver</code></pre><p>A <code>struct</code> that comprises all Newton solvers. Those typically differ in the way the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is computed.</p><p><strong>Constructors</strong></p><p>The <code>NewtonSolver</code> can be called with an <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> or with a <code>Callable</code>. Note however that the latter will probably be deprecated in the future.</p><pre><code class="language-julia hljs">linesearch = Quadratic()
F(y, x, params) = y .= tanh.(x)
x = [.5, .5]
y = zero(x)
F(y, x, nothing)

NewtonSolver(x, y; F = F, linesearch = linesearch)

# output

i=   0,
x= NaN,
f= NaN,
rxₐ= NaN,
rfₐ= NaN</code></pre><p>What is shown here is the status of the <code>NewtonSolver</code>, i.e. an instance of <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>nonlinearsystem::</code><a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a>: the system that has to be solved. This can be accessed by calling <a href="#SimpleSolvers.nonlinearsystem-Tuple{NewtonSolver}"><code>nonlinearsystem</code></a>,</li><li><code>jacobian::</code><a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a></li><li><code>linear::</code><a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>: the linear solver is used to compute the <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>direction</code></a> of the solver step (see <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a>). This can be accessed by calling <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver}"><code>linearsolver</code></a>,</li><li><code>linesearch::</code><a href="#SimpleSolvers.LinesearchState"><code>LinesearchState</code></a></li><li><code>refactorize::Int</code>: determines after how many steps the Jacobian is updated and refactored (see <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>). If we have <code>refactorize &gt; 1</code>, then we speak of a <a href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>QuasiNewtonSolver</code></a>,</li><li><code>cache::</code><a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a></li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}" href="#SimpleSolvers.NewtonSolver-Union{Tuple{AT}, Tuple{T}, Tuple{AT, Union{Function, Type}, AT}} where {T, AT&lt;:AbstractVector{T}}"><code>SimpleSolvers.NewtonSolver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonSolver(x, F, y)</code></pre><p><strong>Keywords</strong></p><ul><li><code>linear_solver_method</code></li><li><code>DF!</code></li><li><code>linesearch</code></li><li><code>mode</code></li><li><code>options_kwargs</code>: see <a href="#SimpleSolvers.Options"><code>Options</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NewtonSolverCache" href="#SimpleSolvers.NewtonSolverCache"><code>SimpleSolvers.NewtonSolverCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonSolverCache</code></pre><p>Stores <code>x̄</code>, <code>x</code>, <code>δx</code>, <code>rhs</code>, <code>y</code> and <code>J</code>.</p><p>Compare this to <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>x̄</code>: the previous iterate,</li><li><code>x</code>: the next iterate (or <em>guess</em> thereof). The <em>guess</em> is computed when calling the functions created by <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>,</li><li><code>δx</code>: search direction. This is updated when calling <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a> via the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> stored in the <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>,</li><li><code>rhs</code>: the right-hand-side (this can be accessed by calling <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>rhs</code></a>), </li><li><code>y</code>: the objective evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>,</li><li><code>J::AbstractMatrix</code>: the Jacobian evaluated at <code>x</code>. This is used in <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>. Note that this is not of type <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a>!</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">NewtonSolverCache(x, y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_cache.jl#LL1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearMethod" href="#SimpleSolvers.NonlinearMethod"><code>SimpleSolvers.NonlinearMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A supertype collecting all nonlinear methods, including <code>NewtonMethod</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/methods.jl#LL4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSolver" href="#SimpleSolvers.NonlinearSolver"><code>SimpleSolvers.NonlinearSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSolver &lt;: AbstractSolver</code></pre><p>A supertype that comprises e.g. <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSolverStatus" href="#SimpleSolvers.NonlinearSolverStatus"><code>SimpleSolvers.NonlinearSolverStatus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSolverStatus</code></pre><p>Stores absolute, relative and successive residuals for <code>x</code> and <code>f</code>. It is used as a diagnostic tool in <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>i::Int</code>: iteration number,</li><li><code>rxₐ</code>: absolute residual in <code>x</code>,</li><li><code>rxₛ</code>: successive residual in <code>x</code>,</li><li><code>rfₐ</code>: absolute residual in <code>f</code>,</li><li><code>rfₛ</code>: successive residual in <code>f</code>,</li><li><code>x</code>: the <em>current solution</em> (can also be accessed by calling <a href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>solution</code></a>),</li><li><code>x̄</code>: previous solution</li><li><code>δ</code>: change in solution (see <a href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>direction</code></a>). This is updated by calling <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearSystem)</code></a>,</li><li><code>x̃</code>: a variable that gives the <em>component-wise change</em> via <span>$\delta/x$</span>,</li><li><code>f₀</code>: initial function value,</li><li><code>f</code>: current function value,</li><li><code>f̄</code>: previous function value,</li><li><code>γ</code>: records change in <code>f</code>. This is updated by calling <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearSystem)</code></a>,</li><li><code>x_converged::Bool</code></li><li><code>f_converged::Bool</code></li><li><code>g_converged::Bool</code></li><li><code>f_increased::Bool</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">NonlinearSolverStatus{Float64}(3)

# output

i=   0,
x= NaN,
f= NaN,
rxₐ= NaN,
rfₐ= NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSystem" href="#SimpleSolvers.NonlinearSystem"><code>SimpleSolvers.NonlinearSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSystem</code></pre><p>A <code>NonlinearSystem</code> describes <span>$F(x) = y$</span>, where we want to solve for <span>$x$</span> and <span>$F$</span> is in nonlinear in general (also compare this to <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a> and <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>).</p><div class="admonition is-info" id="Info-c6ac5ec5e1ff9e6d"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-c6ac5ec5e1ff9e6d" title="Permalink"></a></header><div class="admonition-body"><p><code>NonlinearSystem</code>s are used for <em>solvers</em> whereas <code>MultivariateObjective</code>s are their equivalent for <em>optimizers</em>.</p></div></div><p><strong>Keys</strong></p><ul><li><code>F</code>: accessed by calling <code>Function(nls)</code>,</li><li><code>J::</code><a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a>: accessed by calling <code>Jacobian(nls)</code>,</li><li><code>f</code>: accessed by calling <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a><code>(nls)</code>,</li><li><code>j</code>: accessed by calling <a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver}"><code>jacobian</code></a><code>(nls)</code>,</li><li><code>x_f</code>: accessed by calling <a href="#SimpleSolvers.f_argument-Tuple{NonlinearSystem}"><code>f_argument</code></a><code>(nls)</code>,</li><li><code>x_j</code>: accessed by calling <a href="#SimpleSolvers.j_argument-Tuple{NonlinearSystem}"><code>j_argument</code></a><code>(nls)</code>,</li><li><code>f_calls</code>: accessed by calling <a href="#SimpleSolvers.f_calls-Tuple{NonlinearSystem}"><code>f_calls</code></a><code>(nls)</code>,</li><li><code>j_calls</code>: accessed by calling <a href="#SimpleSolvers.j_calls-Tuple{NonlinearSystem}"><code>j_calls</code></a><code>(nls)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL119-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSystem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}" href="#SimpleSolvers.NonlinearSystem-Tuple{Union{Function, Type}, AbstractArray, AbstractArray}"><code>SimpleSolvers.NonlinearSystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSystem(F, x, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL173-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.NonlinearSystem-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#SimpleSolvers.NonlinearSystem-Union{Tuple{T}, Tuple{Union{Function, Type}, Union{Function, Type}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>SimpleSolvers.NonlinearSystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonlinearSystem(F, J!, x, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL163-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizationAlgorithm" href="#SimpleSolvers.OptimizationAlgorithm"><code>SimpleSolvers.OptimizationAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OptimizationAlgorithm</code> is a data structure that is used to dispatch on different algorithms.</p><p>It needs to implement three methods,</p><pre><code class="nohighlight hljs">initialize!(alg::OptimizationAlgorithm, ::AbstractVector)
update!(alg::OptimizationAlgorithm, ::AbstractVector)
solver_step!(::AbstractVector, alg::OptimizationAlgorithm)</code></pre><p>that initialize and update the state of the algorithm and perform an actual optimization step.</p><p>Further the following convenience methods should be implemented,</p><pre><code class="nohighlight hljs">objective(alg::OptimizationAlgorithm)
gradient(alg::OptimizationAlgorithm)
hessian(alg::OptimizationAlgorithm)
linesearch(alg::OptimizationAlgorithm)</code></pre><p>which return the objective to optimize, its gradient and (approximate) Hessian as well as the linesearch algorithm used in conjunction with the optimization algorithm if any.</p><p>See <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> for a <code>struct</code> that was derived from <code>OptimizationAlgorithm</code>.</p><div class="admonition is-info" id="Info-46a8913fbf1b0026"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-46a8913fbf1b0026" title="Permalink"></a></header><div class="admonition-body"><p>Note that a <code>OptimizationAlgorithm</code> is not necessarily a <code>NewtonOptimizerState</code> as we can also have other optimizers, <em>Adam</em> for example.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Optimizer" href="#SimpleSolvers.Optimizer"><code>SimpleSolvers.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer</code></pre><p>The optimizer that stores all the information needed for an optimization problem. This problem can be solved by calling <a href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>solve!(::AbstractVector, ::Optimizer)</code></a>.</p><p><strong>Keys</strong></p><ul><li><code>algorithm::</code><a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a>,</li><li><code>objective::</code><a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>,</li><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a>,</li><li><code>result::</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>,</li><li><code>state::</code><a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL51-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizerResult" href="#SimpleSolvers.OptimizerResult"><code>SimpleSolvers.OptimizerResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerResult</code></pre><p>Stores an <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> as well as <code>x</code>, <code>f</code> and <code>g</code> (as keys). <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> stores all other information (apart form <code>x</code> ,<code>f</code> and <code>g</code>); i.e. residuals etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_result.jl#LL2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.OptimizerStatus" href="#SimpleSolvers.OptimizerStatus"><code>SimpleSolvers.OptimizerStatus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerStatus</code></pre><p>Stores residuals (relative and absolute) and various convergence properties.</p><p>See <a href="update/#OptimizerResult"><code>OptimizerResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Options" href="#SimpleSolvers.Options"><code>SimpleSolvers.Options</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Options</code></pre><p><strong>Keys</strong></p><p>Configurable options with defaults (values 0 and NaN indicate unlimited):</p><ul><li><code>x_abstol = 2eps(T)</code>: absolute tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>,</li><li><code>x_reltol = 2eps(T)</code>: relative tolerance for <code>x</code> (the function argument). Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>x_suctol = 2eps(T)</code>: succesive tolerance for <code>x</code>. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_abstol = zero(T)</code>: absolute tolerance for how close the function value should be to zero. See <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>. Used in e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_reltol = 2eps(T)</code>: relative tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_suctol = 2eps(T)</code>: succesive tolerance for the function value. Used in e.g. <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>,</li><li><code>f_mindec = T(10)^-4</code>: minimum value by which the function has to decrease (also see <a href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>minimum_decrease_threshold</code></a>),</li><li><code>g_restol = 2eps(T)</code>: tolerance for the residual (?) of the gradient,</li><li><code>x_abstol_break = -Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>x_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_abstol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>,</li><li><code>f_reltol_break = Inf</code>: see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>.,</li><li><code>g_restol_break = Inf</code>,</li><li><code>f_calls_limit = 0</code>,</li><li><code>g_calls_limit = 0</code>,</li><li><code>h_calls_limit = 0</code>,</li><li><code>allow_f_increases = true</code>,</li><li><code>min_iterations = 0</code>,</li><li><code>max_iterations = 1000</code>: the maximum number of iterations used in an alorithm, e.g. <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a> and the functor for <a href="#SimpleSolvers.BacktrackingState"><code>BacktrackingState</code></a>,</li><li><code>warn_iterations = 1000</code>,</li><li><code>show_trace = false</code>,</li><li><code>store_trace = false</code>,</li><li><code>extended_trace = false</code>,</li><li><code>show_every = 1</code>,</li><li><code>verbosity = 1</code></li></ul><p>Some of the constants are defined by the functions <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> and <a href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>absolute_tolerance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/options.jl#LL107-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Quadratic" href="#SimpleSolvers.Quadratic"><code>SimpleSolvers.Quadratic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadratic &lt;: LinesearchMethod</code></pre><p>The <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.BierlaireQuadratic"><code>BierlaireQuadratic</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Quadratic()</code></pre><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Quadratic2" href="#SimpleSolvers.Quadratic2"><code>SimpleSolvers.Quadratic2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadratic2 &lt;: LinesearchMethod</code></pre><p>The second <em>quadratic</em> method. Compare this to <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a>.</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.QuadraticState" href="#SimpleSolvers.QuadraticState"><code>SimpleSolvers.QuadraticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticState &lt;: LinesearchState</code></pre><p>Quadratic Polynomial line search.</p><p><em>Quadratic line search</em> works by fitting a polynomial to a univariate objective (see <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>) and then finding the minimum of that polynomial. Also compare this to <a href="#SimpleSolvers.BierlaireQuadraticState"><code>BierlaireQuadraticState</code></a>. The algorithm is taken from [<a href="references/#kelley1995iterative">1</a>].</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>α₀</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_α₀"><code>DEFAULT_ARMIJO_α₀</code></a></li><li><code>σ₀</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a></li><li><code>σ₁</code>: by default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a></li><li><code>c</code>: by default <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/quadratic.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.QuadraticState2" href="#SimpleSolvers.QuadraticState2"><code>SimpleSolvers.QuadraticState2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticState2 &lt;: LinesearchState</code></pre><p>Quadratic Polynomial line search. This is similar to <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>, but performs multiple iterations in which all parameters <span>$p_0$</span>, <span>$p_1$</span> and <span>$p_2$</span> are changed. This is different from <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), where only <span>$p_2$</span> is changed. We further do not check the <a href="#SimpleSolvers.SufficientDecreaseCondition"><code>SufficientDecreaseCondition</code></a> but rather whether the derivative is <em>small enough</em>.</p><p>This algorithm repeatedly builds new quadratic polynomials until a minimum is found (to sufficient accuracy). The iteration may also stop after we reaches the maximum number of iterations (see <a href="#SimpleSolvers.MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH"><code>MAX_NUMBER_OF_ITERATIONS_FOR_QUADRATIC_LINESEARCH</code></a>).</p><p><strong>Keywords</strong></p><ul><li><code>config::</code><a href="#SimpleSolvers.Options"><code>Options</code></a></li><li><code>ε</code>: A constant that checks the <em>precision</em>/<em>tolerance</em>.</li><li><code>s</code>: A constant that determines the initial interval for bracketing. By default this is <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a>.</li><li><code>s_reduction:</code> A constant that determines the factor by which <code>s</code> is decreased in each new <em>bracketing iteration</em>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/custom_quadratic.jl#LL11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.Static" href="#SimpleSolvers.Static"><code>SimpleSolvers.Static</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Static &lt;: LinesearchMethod</code></pre><p>The <em>static</em> method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Static(α)</code></pre><p><strong>Keys</strong></p><p>Keys include: -<code>α</code>: equivalent to a step size. The default is <code>1</code>.</p><p><strong>Extended help</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/methods.jl#LL104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.StaticState" href="#SimpleSolvers.StaticState"><code>SimpleSolvers.StaticState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticState &lt;: LinesearchState</code></pre><p>The state for <a href="#SimpleSolvers.Static"><code>Static</code></a>.</p><p><strong>Functors</strong></p><p>For a <code>Number</code> <code>a</code> and an <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a> <code>obj</code> we have the following functors:</p><pre><code class="language-julia hljs">ls.(a) = ls.α
ls.(obj, a) = ls.α</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/static.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.SufficientDecreaseCondition" href="#SimpleSolvers.SufficientDecreaseCondition"><code>SimpleSolvers.SufficientDecreaseCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SufficientDecreaseCondition &lt;: LinesearchCondition</code></pre><p>The condition that determines if <span>$\alpha_k$</span> is <em>big enough</em>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SufficientDecreaseCondition(c₁, xₖ, fₖ, gradₖ, pₖ, obj)</code></pre><p><strong>Functors</strong></p><pre><code class="language-julia hljs">sdc(xₖ₊₁, αₖ)
sdc(αₖ)</code></pre><p>The second functor is shorthand for <code>sdc(compute_new_iterate(sdc.xₖ, αₖ, sdc.pₖ), T(αₖ))</code>, also see <a href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>compute_new_iterate</code></a>.</p><p><strong>Extended help</strong></p><p>We call the constant that pertains to the sufficient decrease condition <span>$c$</span>. This is typically called <span>$c_1$</span> in the literature [<a href="references/#nocedal2006numerical">3</a>]. See <a href="#SimpleSolvers.DEFAULT_WOLFE_c₁"><code>DEFAULT_WOLFE_c₁</code></a> for the relevant constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/sufficient_decrease_condition.jl#LL1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.TemporaryUnivariateObjective" href="#SimpleSolvers.TemporaryUnivariateObjective"><code>SimpleSolvers.TemporaryUnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporaryUnivariateObjective &lt;: AbstractUnivariateObjective</code></pre><p>Like <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> but doesn&#39;t store <code>f</code>, <code>d</code>, <code>x_f</code> and <code>x_d</code> as well as <code>f_calls</code> and <code>d_calls</code>.</p><p>In practice <code>TemporaryUnivariateObjective</code>s are allocated by calling <a href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>linesearch_objective</code></a>.</p><p><strong>Constructors</strong></p><div class="admonition is-category-warn" id="Calling-line-search-objectives-1bed21294969fe67"><header class="admonition-header">Calling line search objectives<a class="admonition-anchor" href="#Calling-line-search-objectives-1bed21294969fe67" title="Permalink"></a></header><div class="admonition-body"><p>Below we show a few constructors that can be used to allocate <code>TemporaryUnivariateObjective</code>s. Note however that in practice one probably should not do that and instead call <code>linesearch_objective</code>.</p></div></div><pre><code class="language-julia hljs">f(x) = x^2 - 1
g(x) = 2x
δx(x) = - g(x) / 2
x₀ = 3.
_f(α) = f(compute_new_iterate(x₀, α, δx(x₀)))
_d(α) = g(compute_new_iterate(x₀, α, δx(x₀)))
ls_obj = TemporaryUnivariateObjective{typeof(x₀)}(_f, _d)

# output

TemporaryUnivariateObjective{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Alternatively one can also do:</p><pre><code class="language-julia hljs">ls_obj = TemporaryUnivariateObjective(_f, _d, x₀)

# output

TemporaryUnivariateObjective{Float64, typeof(_f), typeof(_d)}(_f, _d)</code></pre><p>Here we wrote <code>ls_obj</code> to mean <em>line search objective</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL234-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.UnivariateObjective" href="#SimpleSolvers.UnivariateObjective"><code>SimpleSolvers.UnivariateObjective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnivariateObjective &lt;: AbstractUnivariateObjective</code></pre><p><strong>Keywords</strong></p><p>It stores the following:</p><ul><li><code>F</code>: objective</li><li><code>D</code>: derivative of objective</li><li><code>f</code>: cache for function output</li><li><code>d</code>: cache for derivative output</li><li><code>x_f</code>: x used to evaluate F (stored in f)</li><li><code>x_d</code>: x used to evaluate D (stored in d)</li><li><code>f_calls</code>: number of times <code>F</code> has been called</li><li><code>d_calls</code>: number of times <code>D</code> has been called</li></ul><p><strong>Constructor</strong></p><p>There are several constructors, the most generic (besides the default one) is:</p><pre><code class="language-julia hljs">UnivariateObjective(F, D, x; f, d)</code></pre><p>Where no keys are inferred, except <code>x_f</code> and <code>x_d</code>. <code>f_calls</code> and <code>d_calls</code> are set to zero.</p><p>The most general constructor (i.e. the one the needs the least specification) is:</p><pre><code class="language-julia hljs">f(x::Number) = x ^ 2
UnivariateObjective(f, 1.)

# output

UnivariateObjective:

    f(x)              = NaN
    d(x)              = NaN
    x_f               = NaN
    x_d               = NaN
    number of f calls = 0
    number of d calls = 0</code></pre><p>where <code>ForwardDiff</code> is used to generate the derivative of the (anonymous) function.</p><p><strong>Functor</strong></p><p>The functor calls <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL21-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}" href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(H, x)</code></pre><p>Update a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p>This is identical to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL193-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{MultivariateObjective, AbstractVector}" href="#GeometricBase.update!-Tuple{MultivariateObjective, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(obj, x)</code></pre><p>Call <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a> and <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a> on <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{NewtonSolver, AbstractArray, Any}" href="#GeometricBase.update!-Tuple{NewtonSolver, AbstractArray, Any}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(solver, x, params)</code></pre><p>Update the <code>solver::</code><a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> based on <code>x</code>. This updates the cache (instance of type <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>) and the status (instance of type <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>). In course of updating the latter, we also update the <code>nonlinear</code> stored in <code>solver</code> (and <code>status(solver)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{Optimizer, AbstractVector}" href="#GeometricBase.update!-Tuple{Optimizer, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(opt, x)</code></pre><p>Compute objective and gradient at new solution and update result.</p><p>This first calls <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a> and then <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NewtonOptimizerState, ::AbstractVector)</code></a>. We note that the <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> (unlike the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a>) is updated when calling <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::OptimizerResult, ::AbstractVector, ::AbstractVector, ::AbstractVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(cache, x, g)</code></pre><p>Update the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code> and <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(cache::NewtonOptimizerCache, x, g, hes)</code></pre><p>Update an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> based on <code>x</code>.</p><p>This is used in <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NewtonOptimizerState, ::AbstractVector)</code></a>.</p><p>This sets:</p><p class="math-container">\[\bar{x}^\mathtt{cache} \gets x,
x^\mathtt{cache} \gets x,
g^\mathtt{cache} \gets g,
\mathrm{rhs}^\mathtt{cache} \gets -g,
\delta^\mathtt{cache} \gets H^{-1}\mathrm{rhs}^\mathtt{cache},\]</p><p>where we wrote <span>$H$</span> for the Hessian (i.e. the input argument <code>hes</code>). </p><p>Also see <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NewtonSolverCache, ::AbstractVector)</code></a>. </p><div class="admonition is-category-warn" id="Warn-9e0d91c63ab8a96"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-9e0d91c63ab8a96" title="Permalink"></a></header><div class="admonition-body"><p>Note that this is not updating the Hessian <code>hes</code>. For this call <code>update!</code> on the <code>Hessian</code>.</p></div></div><p><strong>Implementation</strong></p><p>The multiplication by the inverse of <span>$H$</span> is done with <code>LinearAlgebra.ldiv!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL76-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}" href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerState, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(state::NewtonOptimizerState, x, g, hes)</code></pre><p>Update an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> based on <code>x</code>, <code>g</code> and <code>hes</code>, where <code>g</code> can either be an <code>AbstractVector</code> or a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and <code>hes</code> is a <a href="update/#Hessian"><code>Hessian</code></a>. This updates the <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> contained in the <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> by calling <a href="#GeometricBase.update!-Tuple{SimpleSolvers.NewtonOptimizerCache, AbstractVector, Union{Gradient, AbstractVector}, Hessian}"><code>update!(::NewtonOptimizerCache, ::AbstractVector, ::Union{AbstractVector, Gradient}, ::Hessian)</code></a>.</p><div class="admonition is-info" id="Info-30f58328db5c3cde"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-30f58328db5c3cde" title="Permalink"></a></header><div class="admonition-body"><p>An instance of <code>NewtonOptimizerState</code> stores the <code>NewtonOptimizerCache</code> as well as a <code>LinesearchState</code>. The <code>LinesearchState</code> stays the same at every iteration, which is why only the <code>NewtonOptimizerState</code> is updated.</p></div></div><p><strong>Examples</strong></p><p>We show that after initializing, update has to be called together with a <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> and a <a href="update/#Hessian"><code>Hessian</code></a>:</p><p>If we only call <code>update!</code> once there are still <code>NaN</code>s in the ...</p><pre><code class="language-julia hljs">f(x) = sum(x.^2)
x = [1., 2.]
state = NewtonOptimizerState(x)
obj = MultivariateObjective(f, x)
g = gradient!(obj, x)
hes = HessianAutodiff(obj, x)
update!(hes, x)
update!(state, x, g, hes)

# output

NewtonOptimizerState{Float64, SimpleSolvers.BacktrackingState{Float64}, SimpleSolvers.NewtonOptimizerCache{Float64, Vector{Float64}}}(Backtracking with α₀ = 1.0, ϵ = 0.0001and p = 0.5., SimpleSolvers.NewtonOptimizerCache{Float64, Vector{Float64}}([1.0, 2.0], [1.0, 2.0], [-1.0, -2.0], [2.0, 4.0], [-2.0, -4.0]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_state.jl#LL42-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearSystem, Any}" href="#GeometricBase.update!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector, NonlinearSystem, Any}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(status, x, nls)</code></pre><p>Update the <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> based on <code>x</code> for the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> <code>obj</code>. Internally this calls <a href="#SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>next_iteration!</code></a>.</p><div class="admonition is-info" id="Info-356228fc7eed0ed2"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-356228fc7eed0ed2" title="Permalink"></a></header><div class="admonition-body"></div></div><p>This also updates the objective <code>nls</code>!</p><p>The new <code>x</code> and <code>x̄</code> stored in <code>status</code> are used to compute <code>δ</code>. The new <code>f</code> and <code>f̄</code> stored in <code>status</code> are used to compute <code>γ</code>. See <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> for an explanation of those variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL278-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}" href="#GeometricBase.update!-Tuple{SimpleSolvers.OptimizerResult, AbstractVector, Number, AbstractVector}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(result, x, f, g)</code></pre><p>Update the <a href="update/#OptimizerResult"><code>OptimizerResult</code></a> based on <code>x</code>, <code>f</code> and <code>g</code> (all vectors). This involves updating the <a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a> stored in <code>result</code> (by calling <a href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>residual!</code></a>).</p><p>This also calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>increase_iteration_number!(::OptimizerResult)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_result.jl#LL63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian" href="#GeometricBase.update!-Union{Tuple{HT}, Tuple{HT, AbstractVector}} where HT&lt;:Hessian"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(hessian, x)</code></pre><p>Update the <a href="update/#Hessian"><code>Hessian</code></a> based on the vector <code>x</code>. For an explicit example see e.g. <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::HessianAutodiff)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Union{Tuple{T}, Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}, AbstractMatrix{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(ls, A, y)</code></pre><p>Set the <a href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>rhs</code></a> vector to <code>y</code> and the matrix stored in <code>ls</code> to <code>A</code>.</p><div class="admonition is-info" id="Info-8c9015388502bb64"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-8c9015388502bb64" title="Permalink"></a></header><div class="admonition-body"><p>Calling <code>update!</code> doesn&#39;t solve the <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a>, you still have to call <code>solve!</code> in combination with a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T" href="#GeometricBase.update!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(cache, x)</code></pre><p>Update the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>, i.e.:</p><ol><li><code>cache.x̄</code> <span>$\gets$</span> x,</li><li><code>cache.x</code> <span>$\gets$</span> x,</li><li><code>cache.δx</code> <span>$\gets$</span> 0.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_cache.jl#LL41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}" href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>GeometricBase.value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value(obj::AbstractObjective, x)</code></pre><p>Evaluates the objective value at <code>x</code> (i.e. computes <code>obj.F(x)</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

obj = UnivariateObjective(x::Number -&gt; x^2, 1.)
value(obj, 2.)
obj.f_calls

# output

1</code></pre><p>Note that the <code>f_calls</code> counter increased by one!</p><p>If <code>value</code> is called on <code>obj</code> (an <a href="#SimpleSolvers.AbstractObjective"><code>AbstractObjective</code></a>) without supplying <code>x</code> than the output of the last <code>obj.F</code> call is returned:</p><pre><code class="language-julia hljs">using SimpleSolvers

obj = UnivariateObjective(x::Number -&gt; x^2, 1.)
value(obj)

# output

NaN</code></pre><p>In this example this is <code>NaN</code> since the function hasn&#39;t been called yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL108-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}" href="#LinearAlgebra.ldiv!-Union{Tuple{LUT}, Tuple{T}, Tuple{AbstractVector{T}, LinearSolver{T, LUT}, AbstractVector{T}}} where {T, LUT&lt;:LU}"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldiv!(x, lu, b)</code></pre><p>Compute <code>inv(cache(lsolver).A) * b</code> by utilizing the factorization of the lu solver (see <a href="#SimpleSolvers.LU"><code>LU</code></a> and <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) and store the result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.QuasiNewtonSolver-Tuple" href="#SimpleSolvers.QuasiNewtonSolver-Tuple"><code>SimpleSolvers.QuasiNewtonSolver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiNewtonSolver</code></pre><p>A convenience constructor for <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>. Also see <a href="#SimpleSolvers.DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER"><code>DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER</code></a>.</p><p>Calling <code>QuasiNewtonSolver</code> hence produces an instance of <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> with the difference that <code>refactorize ≠ 1</code>. The <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> is thus not evaluated and refactored in every step.</p><p><strong>Implementation</strong></p><p>It does:</p><pre><code class="language-julia hljs">QuasiNewtonSolver(args...; kwargs...) = NewtonSolver(args...; refactorize=DEFAULT_ITERATIONS_QUASI_NEWTON_SOLVER, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL110-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers._static-Tuple{AbstractMatrix}" href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>SimpleSolvers._static</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_static(A)</code></pre><p>Determine whether to allocate a <code>StaticArray</code> or simply copy the input array. This is used when calling <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> on <a href="#SimpleSolvers.LU"><code>LU</code></a>. Every matrix that is smaller or equal to <a href="#SimpleSolvers.N_STATIC_THRESHOLD"><code>N_STATIC_THRESHOLD</code></a> is turned into a <code>StaticArray</code> as a consequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SimpleSolvers.absolute_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.absolute_tolerance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">absolute_tolerance(T)</code></pre><p>Determine the absolute tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p>In comparison to <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>, this should return a very small number, close to zero (i.e. not just machine precision).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">absolute_tolerance(Float64)

# output

0.0</code></pre><pre><code class="language-julia hljs">absolute_tolerance(Float32)

# output

0.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/options.jl#LL36-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T" href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>SimpleSolvers.adjust_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjust_α(ls, αₜ, α)</code></pre><p>Check which conditions the new <code>αₜ</code> is in <span>$[\sigma_0\alpha_0, \simga_1\alpha_0]$</span> and return the updated <code>α</code> accordingly (it is updated if it does not lie in the interval).</p><p>We first check the following:</p><p class="math-container">\[    \alpha_t  &lt; \alpha_0\alpha,\]</p><p>where <span>$\sigma_0$</span> is stored in <code>ls</code> (i.e. in an instance of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>). If this is not true we check:</p><p class="math-container">\[    \alpha_t &gt; \sigma_1\alpha,\]</p><p>where <span>$\sigma_1$</span> is again stored in <code>ls</code>. If this second condition is also not true we simply return the unchanged <span>$\alpha_t$</span>. So if <code>\alpha_t</code> does not lie in the interval <span>$(\sigma_0\alpha, \sigma_1\alpha)$</span> the interval is made bigger by either multiplying with <span>$\sigma_0$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a>) or <span>$\sigma_1$</span> (default <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/quadratic.jl#LL39-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T" href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}} where T"><code>SimpleSolvers.adjust_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjust_α(αₜ, α)</code></pre><p>Adjust <code>αₜ</code> based on the previous <code>α</code>. Also see <a href="#SimpleSolvers.adjust_α-Union{Tuple{T}, Tuple{SimpleSolvers.QuadraticState{T}, T, T}} where T"><code>adjust_α(::QuadraticState{T}, ::T, ::T) where {T}</code></a>.</p><p>The check that <span>$\alpha \in [\sigma_0\alpha_\mathrm{old}, \sigma_1\alpha_\mathrm{old}]$</span> should <em>safeguard against stagnation in the iterates</em> as well as checking that <span>$\alpha$</span> decreases at least by a factor <span>$\sigma_1$</span>. The defaults for <code>σ₀</code> and <code>σ₁</code> are <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a> respectively.</p><p><strong>Implementation</strong></p><p>Wee use defaults <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₀"><code>DEFAULT_ARMIJO_σ₀</code></a> and <a href="#SimpleSolvers.DEFAULT_ARMIJO_σ₁"><code>DEFAULT_ARMIJO_σ₁</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/quadratic.jl#LL60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_d" href="#SimpleSolvers.alloc_d"><code>SimpleSolvers.alloc_d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_d(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the derivative of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.AbstractUnivariateObjective"><code>AbstractUnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/utils.jl#LL15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_f" href="#SimpleSolvers.alloc_f"><code>SimpleSolvers.alloc_f</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_f(x)</code></pre><p>Allocate <code>NaN</code>s of the size the size of <code>f</code> (evaluated at <code>x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/utils.jl#LL8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_g" href="#SimpleSolvers.alloc_g"><code>SimpleSolvers.alloc_g</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_g(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the gradient of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/utils.jl#LL24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_h" href="#SimpleSolvers.alloc_h"><code>SimpleSolvers.alloc_h</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_h(x)</code></pre><p>Allocate <code>NaN</code>s of the size of the Hessian of <code>f</code> (with respect to <code>x</code>).</p><p>This is used in combination with a <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/utils.jl#LL33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.alloc_x" href="#SimpleSolvers.alloc_x"><code>SimpleSolvers.alloc_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_x(x)</code></pre><p>Allocate <code>NaN</code>s of the size of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/utils.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}" href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess_convergence!(status, config)</code></pre><p>Check if one of the following is true for <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><ul><li><code>status.rxₐ ≤ config.x_abstol</code>,</li><li><code>status.rxₛ ≤ config.x_suctol</code>,</li><li><code>status.rfₐ ≤ config.f_abstol</code>,</li><li><code>status.rfₛ ≤ config.f_suctol</code>.</li></ul><p>Also see <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>. The tolerances are by default determined with <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL160-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}" href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.assess_convergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess_convergence!(status, config)</code></pre><p>Checks if the optimizer converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bisection-Tuple{Any, Number}" href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bisection(f, x)</code></pre><p>Use <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> to find a starting interval and then do bisections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bisection.jl#LL79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number" href="#SimpleSolvers.bisection-Union{Tuple{T}, Tuple{Union{Function, Type}, T, T}} where T&lt;:Number"><code>SimpleSolvers.bisection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bisection(f, xmin, xmax; config)</code></pre><p>Perform bisection of <code>f</code> in the interval [<code>xmin</code>, <code>xmax</code>] with <a href="#SimpleSolvers.Options"><code>Options</code></a> <code>config</code>.</p><p>The algorithm is repeated until a root is found (up to tolerance <code>config.f_abstol</code> which is determined by <a href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>default_tolerance</code></a> by default).</p><p><strong>implementation</strong></p><p>When calling <code>bisection</code> it first checks if <span>$x_\mathrm{min} &lt; x_\mathrm{max}$</span> and else flips the two entries.</p><p><strong>Extended help</strong></p><p>The bisection algorithm divides an interval into equal halves until a root is found (up to a desired accuracy).</p><p>We first initialize:</p><p class="math-container">\[\begin{aligned}
x_0 \gets &amp; x_\mathrm{min},
x_1 \gets &amp; x_\mathrm{max},
\end{aligned}\]</p><p>and then repeat:</p><p class="math-container">\[\begin{aligned}
&amp; x \gets \frac{x_0 + x_1}{2}, \\
&amp; \text{if $f(x_0)f(x) &gt; 0$} \\
&amp; \qquad x_0 \gets x, \\
&amp; \text{else} \\
&amp; \qquad x_1 \gets x, \\
&amp; \text{end}
\end{aligned}\]</p><p>So the algorithm checks in each step where the sign change occurred and moves the <span>$x_0$</span> or <span>$x_1$</span> accordingly. The loop is terminated (and errors) if <code>config.max_iterations</code> is reached (by default1000 and the <a href="#SimpleSolvers.Options"><code>Options</code></a> struct).</p><div class="admonition is-warning" id="Warning-2ade81735dfddc94"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2ade81735dfddc94" title="Permalink"></a></header><div class="admonition-body"><p>The obvious danger with using bisections is that the supplied interval can have multiple roots (or no roots). One should be careful to avoid this when fixing the interval.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bisection.jl#LL1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_minimum(f, x)</code></pre><p>Move a bracket successively in the search direction (starting at <code>x</code>) and increase its size until a local minimum of <code>f</code> is found.  This is used for performing <a href="#SimpleSolvers.Bisection"><code>Bisection</code></a>s when only one <code>x</code> is given (and not an entire interval).  This bracketing algorithm is taken from [<a href="references/#kochenderfer2019algorithms">4</a>]. Also compare it to <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>s::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a></li><li><code>k::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a></li><li><code>nmax::</code><a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a></li></ul><p><strong>Extended help</strong></p><p>For bracketing we need two constants <span>$s$</span> and <span>$k$</span> (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>). </p><p>Before we start the algorithm we <em>initialize</em> it, i.e. we check that we indeed have a descent direction:</p><p class="math-container">\[\begin{aligned}
&amp; a \gets x, \\
&amp; b \gets a + s, \\
&amp; \mathrm{if} \quad f(b) &gt; f(a)\\
&amp; \qquad\text{Flip $a$ and $b$ and set $s\gets-s$.}\\
&amp; \mathrm{end}
\end{aligned}\]</p><p>The algorithm then successively computes:</p><p class="math-container">\[c \gets b + s,\]</p><p>and then checks whether <span>$f(c) &gt; f(b)$</span>. If this is true it returns <span>$(a, c)$</span> or <span>$(c, a)$</span>, depending on whether <span>$a&lt;c$</span> or <span>$c&lt;a$</span> respectively. If this is not satisfied <span>$a,$</span> <span>$b$</span> and <span>$s$</span> are updated:</p><p class="math-container">\[\begin{aligned}
a \gets &amp; b, \\
b \gets &amp; c, \\
s \gets &amp; sk, 
\end{aligned}\]</p><p>and the algorithm is continued. If we have not found a sign chance after <span>$n_\mathrm{max}$</span> iterations (see <a href="#SimpleSolvers.DEFAULT_BRACKETING_nmax"><code>DEFAULT_BRACKETING_nmax</code></a>) the algorithm is terminated and returns an error. The interval that is returned by <code>bracket_minimum</code> is then typically used as a starting point for <a href="#SimpleSolvers.bisection-Tuple{Any, Number}"><code>bisection</code></a>.</p><div class="admonition is-info" id="Info-d2bfb17d476806f1"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-d2bfb17d476806f1" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>bracket_root</code> is equivalent to <code>bracket_minimum</code> with the only difference that the criterion we check for is:</p><p class="math-container">\[f(c)f(b) &lt; 0,\]</p><p>i.e. that a sign change in the function occurs.</p></div></div><p>See <a href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_root</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL64-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_minimum_with_fixed_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_minimum_with_fixed_point(f, x)</code></pre><p>Find a bracket while keeping the left side (i.e. <code>x</code>) fixed.  The algorithm is similar to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a> (also based on <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> and <a href="#SimpleSolvers.DEFAULT_BRACKETING_k"><code>DEFAULT_BRACKETING_k</code></a>) with the difference that for the latter the left side is also moving.</p><p>The function <code>bracket_minimum_with_fixed_point</code> is used as a starting point for <a href="#SimpleSolvers.Quadratic"><code>Quadratic</code></a> (taken from [<a href="references/#kelley1995iterative">1</a>]), as the minimum of the polynomial approximation is:</p><p class="math-container">\[p_2 = \frac{f(b) - f(a) - f&#39;(0)b}{b^2},\]</p><p>where <span>$b = \mathtt{bracket\_minimum\_with\_fixed\_point}(a)$</span>. We check that <span>$f(b) &gt; f(a)$</span> in order to ensure that the curvature of the polynomial (i.e. <span>$p_2$</span> is positive) and we have a minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL140-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number" href="#SimpleSolvers.bracket_root-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>SimpleSolvers.bracket_root</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bracket_root(f, x)</code></pre><p>Make a bracket for the function based on <code>x</code> (for root finding).</p><p>This is largely equivalent to <a href="#SimpleSolvers.bracket_minimum-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum</code></a>. See the end of that docstring for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/bracket_minimum.jl#LL190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.cache-Tuple{LinearSolver}" href="#SimpleSolvers.cache-Tuple{LinearSolver}"><code>SimpleSolvers.cache</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cache(ls)</code></pre><p>Return the cache (of type <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_gradient-Tuple{AbstractVector}" href="#SimpleSolvers.check_gradient-Tuple{AbstractVector}"><code>SimpleSolvers.check_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_gradient(g)</code></pre><p>Check norm, maximum value and minimum value of a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SimpleSolvers

g = [1., 1., 1., 2., 0.9, 3.]
SimpleSolvers.check_gradient(g; digits=3)

# output

norm(Gradient):               4.1
minimum(|Gradient|):          0.9
maximum(|Gradient|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL71-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_hessian-Tuple{AbstractMatrix}" href="#SimpleSolvers.check_hessian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_hessian(H)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="update/#Hessian"><code>Hessian</code></a> <code>H</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

H = [1. √2.; √2. 3.]
SimpleSolvers.check_hessian(H)

# output

Condition Number of Hessian: 13.9282
Determinant of Hessian:      1.0
minimum(|Hessian|):          1.0
maximum(|Hessian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL56-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}" href="#SimpleSolvers.check_jacobian-Tuple{AbstractMatrix}"><code>SimpleSolvers.check_jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_jacobian(J)</code></pre><p>Check the condition number, determinant, max and min value of the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> <code>J</code>.</p><pre><code class="language-julia hljs">using SimpleSolvers

J = [1. √2.; √2. 3.]
SimpleSolvers.check_jacobian(J)

# output

Condition Number of Jacobian: 13.9282
Determinant of Jacobian:      1.0
minimum(|Jacobian|):          1.0
maximum(|Jacobian|):          3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL38-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Tuple{MultivariateObjective}" href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but with only one input argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Tuple{NonlinearSystem}" href="#SimpleSolvers.clear!-Tuple{NonlinearSystem}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(nls::NonlinearSystem)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but with only one input argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}" href="#SimpleSolvers.clear!-Tuple{SimpleSolvers.AbstractUnivariateObjective}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>, but with only one input argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Union{Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T" href="#SimpleSolvers.clear!-Union{Tuple{LinearSystem{T, VT, AT} where {VT&lt;:AbstractVector{T}, AT&lt;:AbstractMatrix{T}}}, Tuple{T}} where T"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(ls)</code></pre><p>Write <code>NaN</code>s into <code>Matrix(ls)</code> and <code>Vector(ls)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerResult{XT, YT, VT, OST} where {VT&lt;:(AbstractArray{XT}), OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(result)</code></pre><p>Clear all the information contained in <code>result::</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>. This also calls <a href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>clear!(::OptimizerStatus)</code></a>.</p><div class="admonition is-info" id="Info-356228fc7eed0ed2"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-356228fc7eed0ed2" title="Permalink"></a></header><div class="admonition-body"></div></div><p>Calling <code>initialize!</code> on an <code>OptimizerResult</code> calls <code>clear!</code> internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_result.jl#LL39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#SimpleSolvers.clear!-Union{Tuple{SimpleSolvers.OptimizerStatus{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>SimpleSolvers.clear!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clear!(obj)</code></pre><p>Similar to <a href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>initialize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_gradient!" href="#SimpleSolvers.compute_gradient!"><code>SimpleSolvers.compute_gradient!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_gradient!</code></pre><p>Alias for <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>. Will probably be deprecated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>SimpleSolvers.compute_hessian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian!(h, x, ForH)</code></pre><p>Compute the hessian of function <code>ForH</code> at <code>x</code> and store it in <code>h</code>.</p><p><strong>Implementation</strong></p><p>Internally this allocates a <a href="update/#Hessian"><code>Hessian</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL240-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}" href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Hessian}"><code>SimpleSolvers.compute_hessian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian!(h, x, hessian)</code></pre><p>Compute the Hessian and store it in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian-Tuple{Any, Hessian}" href="#SimpleSolvers.compute_hessian-Tuple{Any, Hessian}"><code>SimpleSolvers.compute_hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian(x, hessian)</code></pre><p>Compute the Hessian at point <code>x</code> and return the result.</p><p>Internally this calls <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}" href="#SimpleSolvers.compute_hessian_ad!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.compute_hessian_ad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>H</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> version.</p><p><strong>Implementation</strong></p><p>This is using <a href="#SimpleSolvers.compute_hessian!-Tuple{AbstractMatrix, AbstractVector, Any}"><code>compute_hessian!</code></a> with the keyword <code>mode</code> set to <code>autodiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Jacobian{T}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, jacobian::Jacobian, params)</code></pre><p>Apply the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> and store the result in <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}, Any}} where T" href="#SimpleSolvers.compute_jacobian!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, Union{Function, Type}, Any}} where T"><code>SimpleSolvers.compute_jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_jacobian!(j, x, ForJ, params)</code></pre><p>Allocate a <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> object, apply it to <code>x</code>, and store the result in <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/jacobian.jl#LL251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}" href="#SimpleSolvers.compute_new_iterate-Union{Tuple{TVT}, Tuple{VT}, Tuple{T}, Tuple{VT, T, TVT}} where {T, VT, TVT}"><code>SimpleSolvers.compute_new_iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_new_iterate(xₖ, αₖ, pₖ)</code></pre><p>Compute <code>xₖ₊₁</code> based on a <em>direction</em> <code>pₖ</code> and a <em>step length</em> <code>αₖ</code>.</p><p><strong>Extended help</strong></p><p>In the case of vector spaces this function simply does:</p><pre><code class="language-julia hljs">xₖ + αₖ * pₖ</code></pre><p>For manifolds we instead perform a <em>retraction</em> [<a href="references/#absil2008optimization">5</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/backtracking/condition.jl#LL10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SimpleSolvers.default_tolerance-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.default_tolerance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_tolerance(T)</code></pre><p>Determine the default tolerance for a specific data type. This is used in the constructor of <a href="#SimpleSolvers.Options"><code>Options</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">default_tolerance(Float64)

# output

4.440892098500626e-16</code></pre><pre><code class="language-julia hljs">default_tolerance(Float32)

# output

2.3841858f-7</code></pre><pre><code class="language-julia hljs">default_tolerance(Float16)

# output

Float16(0.001953)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/options.jl#LL1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative!!(obj::AbstractObjective, x)</code></pre><p>Similar to <a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>value!!</code></a>, but fo the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> and <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative!(obj, x)</code></pre><p>Similar to <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a>, but fo the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}" href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>SimpleSolvers.derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative(obj::AbstractObjective, x)</code></pre><p>Similar to <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a>, but for the derivative part (see <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T, T}} where T" href="#SimpleSolvers.determine_initial_α-Union{Tuple{T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T}, Tuple{SimpleSolvers.AbstractUnivariateObjective, T, T, T}} where T"><code>SimpleSolvers.determine_initial_α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">determine_initial_α(y₀, obj, α₀)</code></pre><p>Check whether <code>α₀</code> satisfies the <a href="#SimpleSolvers.BracketMinimumCriterion"><code>BracketMinimumCriterion</code></a> for <code>obj</code>. If the criterion is not satisfied we call <a href="#SimpleSolvers.bracket_minimum_with_fixed_point-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T&lt;:Number"><code>bracket_minimum_with_fixed_point</code></a>. This is used as a starting point for using the functor of <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a> and makes sure that <code>α</code> describes <em>a point past the minimum</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/quadratic.jl#LL81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.direction-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.direction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direction(::NewtonOptimizerCache)</code></pre><p>Return the direction of the gradient step (i.e. <code>δ</code>) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.f_argument-Tuple{NonlinearSystem}" href="#SimpleSolvers.f_argument-Tuple{NonlinearSystem}"><code>SimpleSolvers.f_argument</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>f_argument(nls)</p><p>Return the argument that was last used for evaluating <a href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value!</code></a> for the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> <code>nls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.f_calls-Tuple{NonlinearSystem}" href="#SimpleSolvers.f_calls-Tuple{NonlinearSystem}"><code>SimpleSolvers.f_calls</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f_calls(nls)</code></pre><p>Tell how many times <code>Function(nls)</code> has been called.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">F(x) = tanh.(x)
x = [1., 2., 3.]
F!(y, x, params) = y .= F(x)
nls = NonlinearSystem(F!, x, F(x))

f_calls(nls)

# output

0</code></pre><p>After calling <a href="#GeometricBase.value-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>value</code></a> once we get:</p><pre><code class="language-julia hljs">value!(nls, x, nothing)

f_calls(nls)

# output

1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL304-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.factorize!-Tuple{LinearSolver}" href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>SimpleSolvers.factorize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorize!(lsolver)</code></pre><p>Factorize the matrix stored in the <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a> in <code>lsolver</code>.</p><p>See <a href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>factorize!(::LinearSolver{T, LUT}) where {T, LUT &lt;: LU}</code></a> for a concrete example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}" href="#SimpleSolvers.factorize!-Union{Tuple{LinearSolver{T, LUT}}, Tuple{LUT}, Tuple{T}} where {T, LUT&lt;:LU}"><code>SimpleSolvers.factorize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorize!(lsolver::LinearSolver, A)</code></pre><p>Factorize the matrix <code>A</code> and store the result in <code>cache(lsolver).A</code>. Note that calling <code>cache</code> on <code>lsolver</code> returns the instance of <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a> stored in <code>lsolver</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]
x = similar(y)

lsolver = LinearSolver(LU(; static=false), x)
factorize!(lsolver, A)
cache(lsolver).A

# output

3×3 Matrix{Float64}:
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Here <code>cache(lsolver).A</code> stores the factorized matrix. If we call <code>factorize!</code> with two input arguments as above, the method first copies the matrix <code>A</code> into the <a href="#SimpleSolvers.LUSolverCache"><code>LUSolverCache</code></a>. We can equivalently also do:</p><pre><code class="language-julia hljs">A = [1. 2. 3.; 5. 7. 11.; 13. 17. 19.]
y = [1., 0., 0.]

lsolver = LinearSolver(LU(), A)
factorize!(lsolver)
cache(lsolver).A

# output

3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
 13.0        17.0       19.0
  0.0769231   0.692308   1.53846
  0.384615    0.666667   2.66667</code></pre><p>Also note the difference between the output types of the two refactorized matrices. This is because we set the keyword <code>static</code> to false when calling <a href="#SimpleSolvers.LU"><code>LU</code></a>. Also see <a href="#SimpleSolvers._static-Tuple{AbstractMatrix}"><code>_static</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL141-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number" href="#SimpleSolvers.find_maximum_value-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>SimpleSolvers.find_maximum_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_maximum_value(v, k)</code></pre><p>Find the maximum value of vector <code>v</code> starting from the index <code>k</code>.  This is used for <em>pivoting</em> in <a href="#SimpleSolvers.factorize!-Tuple{LinearSolver}"><code>factorize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/lu_solver.jl#LL234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}" href="#SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient!!(obj::MultivariateObjective, x)</code></pre><p>Like <a href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>derivative!!</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}" href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>SimpleSolvers.gradient!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient!(g, x, grad)</code></pre><p>Apply the <a href="#SimpleSolvers.Gradient"><code>Gradient</code></a> <code>grad</code> to <code>x</code> and store the result in <code>g</code>.</p><p><strong>Implementation</strong></p><p>This is equivalent to doing</p><pre><code class="language-julia hljs">grad(g, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}" href="#SimpleSolvers.gradient!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>SimpleSolvers.gradient!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>gradient!(obj::MultivariateObjective, x)</p><p>Like <a href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>derivative!</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{Any, Gradient}" href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(x, grad)</code></pre><p>Apply <code>grad</code> to <code>x</code> and return the result. </p><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{MultivariateObjective}" href="#SimpleSolvers.gradient-Tuple{MultivariateObjective}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(x, obj::MultivariateObjective)</code></pre><p>Like <a href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>derivative</code></a>, but for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>, not <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.gradient-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(::NewtonOptimizerCache)</code></pre><p>Return the stored gradient (array) of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number" href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>SimpleSolvers.gradient_ad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_ad!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientAutodiff"><code>GradientAutodiff</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>gradient_fd!</code></a> for the finite differences version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}" href="#SimpleSolvers.gradient_fd!-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FT}} where {T, FT}"><code>SimpleSolvers.gradient_fd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_fd!(g, x, F)</code></pre><p>Build a <a href="#SimpleSolvers.GradientFiniteDifferences"><code>GradientFiniteDifferences</code></a> object based on <code>F</code> and apply it to <code>x</code>. The result is stored in <code>g</code>.</p><p>Also see <a href="#SimpleSolvers.gradient_ad!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, Type}}} where T&lt;:Number"><code>gradient_ad!</code></a> for the autodiff version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/gradient.jl#LL261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increase_iteration_number!(status)</code></pre><p>Increase iteration number of <code>status</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
increase_iteration_number!(status)
iteration_number(status)

# output

1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL139-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerResult}"><code>SimpleSolvers.increase_iteration_number!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increase_iteration_number!(result)</code></pre><p>Increase the iteration number of <code>result</code><a href="update/#OptimizerResult"><code>OptimizerResult</code></a>. This calls <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>increase_iteration_number!(::OptimizerStatus)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_result.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}" href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.OptimizerStatus}"><code>SimpleSolvers.increase_iteration_number!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increase_iteration_number!(status)</code></pre><p>Increase the iteration number of a <code>status</code><a href="#SimpleSolvers.OptimizerStatus"><code>OptimizerStatus</code></a>. See <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!(::NonlinearSolverStatus)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{Hessian, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(hessian, x)</code></pre><p>See e.g. <a href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>initialize!(::HessianAutodiff, ::AbstractVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{HessianAutodiff, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(H, x)</code></pre><p>Initialize a <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> object <code>H</code>.</p><p><strong>Implementation</strong></p><p>Internally this is calling the <a href="#SimpleSolvers.HessianAutodiff"><code>HessianAutodiff</code></a> functor and therefore also <code>ForwardDiff.hessian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/hessian.jl#LL179-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{LinearSystem, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{LinearSystem, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(ls, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a> <code>ls</code>. See <a href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>clear!(::LinearSystem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}" href="#SimpleSolvers.initialize!-Tuple{SimpleSolvers.NonlinearSolverStatus, AbstractVector}"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(status, x)</code></pre><p>Clear <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> (via the function <a href="#SimpleSolvers.clear!-Tuple{MultivariateObjective}"><code>clear!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T" href="#SimpleSolvers.initialize!-Union{Tuple{T}, Tuple{SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, AbstractVector{T}}} where T"><code>SimpleSolvers.initialize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(cache, x)</code></pre><p>Initialize the <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a> based on <code>x</code>.</p><p><strong>Implementation</strong></p><p>This calls <a href="#SimpleSolvers.alloc_x"><code>alloc_x</code></a> to do all the initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_cache.jl#LL57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}" href="#SimpleSolvers.isaOptimizationAlgorithm-Tuple{Any}"><code>SimpleSolvers.isaOptimizationAlgorithm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isaOptimizationAlgorithm(alg)</code></pre><p>Verify if an object implements the <a href="#SimpleSolvers.OptimizationAlgorithm"><code>OptimizationAlgorithm</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.j_argument-Tuple{NonlinearSystem}" href="#SimpleSolvers.j_argument-Tuple{NonlinearSystem}"><code>SimpleSolvers.j_argument</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>j_argument(nls)</p><p>Return the argument that was last used for evaluating <a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T&lt;:Number"><code>jacobian!</code></a> for the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> <code>nls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.j_calls-Tuple{NonlinearSystem}" href="#SimpleSolvers.j_calls-Tuple{NonlinearSystem}"><code>SimpleSolvers.j_calls</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">j_calls(nls)</code></pre><p>Like <a href="#SimpleSolvers.f_calls-Tuple{NonlinearSystem}"><code>f_calls</code></a> in relation to a <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> <code>nls</code>, but for <a href="#SimpleSolvers.jacobian-Tuple{NewtonSolver}"><code>jacobian</code></a> (or <a href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T&lt;:Number"><code>jacobian!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T" href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T"><code>SimpleSolvers.jacobian!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian!!(nls::NonlinearSystem, x)</code></pre><p>Force the evaluation of the jacobian for a <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a>. Like <a href="#SimpleSolvers.derivative!!-Tuple{UnivariateObjective, Number}"><code>derivative!!</code></a> for <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> or <a href="#SimpleSolvers.gradient!!-Tuple{MultivariateObjective, AbstractArray{&lt;:Number}}"><code>gradient!!</code></a> for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T&lt;:Number" href="#SimpleSolvers.jacobian!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian!(nls::NonlinearSystem, x)</code></pre><p>Compute the Jacobian of <code>nls</code> at <code>x</code> and store it in <code>jacobian(nls)</code>. Note that the evaluation of the Jacobian is not necessarily enforced here (unlike calling <a href="#SimpleSolvers.jacobian!!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractArray{T}, Any}} where T"><code>jacobian!!</code></a>). Like <a href="#SimpleSolvers.derivative!-Tuple{UnivariateObjective, Number}"><code>derivative!</code></a> for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a> and <a href="#SimpleSolvers.gradient!-Tuple{AbstractVector, AbstractVector, Gradient}"><code>gradient!</code></a> for <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.jacobian-Tuple{NewtonSolver}" href="#SimpleSolvers.jacobian-Tuple{NewtonSolver}"><code>SimpleSolvers.jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(solver::NewtonSolver)</code></pre><p>Return the evaluated Jacobian (a Matrix) stored in the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> of <code>solver</code>.</p><p>Also see <a href="#SimpleSolvers.jacobian-Tuple{NonlinearSystem}"><code>jacobian(::NonlinearSystem)</code></a> and <a href="#SimpleSolvers.Jacobian-Tuple{NonlinearSystem}"><code>Jacobian(::NonlinearSystem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.jacobian-Tuple{NonlinearSystem}" href="#SimpleSolvers.jacobian-Tuple{NonlinearSystem}"><code>SimpleSolvers.jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(nls::NonlinearSystem)</code></pre><p>Return the value of the jacobian stored in <code>nls</code> (instance of <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a>). Like <a href="#SimpleSolvers.derivative-Tuple{UnivariateObjective, Number}"><code>derivative</code></a> for <a href="#SimpleSolvers.UnivariateObjective"><code>UnivariateObjective</code></a> or <a href="#SimpleSolvers.gradient-Tuple{Any, Gradient}"><code>gradient</code></a> for <a href="#SimpleSolvers.MultivariateObjective"><code>MultivariateObjective</code></a>.</p><p>Also see <a href="#SimpleSolvers.Jacobian-Tuple{NonlinearSystem}"><code>Jacobian(::NonlinearSystem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linearsolver-Tuple{NewtonSolver}" href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver}"><code>SimpleSolvers.linearsolver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linearsolver(solver)</code></pre><p>Return the linear part (i.e. a <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>) of an <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = rand(3)
y = rand(3)
F(x) = tanh.(x)
F!(y, x, params) = y .= F(x)
s = NewtonSolver(x, y; F = F!)
linearsolver(s)

# output

LinearSolver{Float64, LU{Missing}, SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}}(LU{Missing}(missing, true), SimpleSolvers.LUSolverCache{Float64, StaticArraysCore.MMatrix{3, 3, Float64, 9}}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], [0, 0, 0], [0, 0, 0], 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL159-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}" href="#SimpleSolvers.linesearch_objective-Tuple{NonlinearSolver, Any}"><code>SimpleSolvers.linesearch_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linesearch_objective(nl::NonlinearSolver, params)</code></pre><p>Build a line search objective based on a <a href="#SimpleSolvers.NonlinearSolver"><code>NonlinearSolver</code></a> (almost always a <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a> in practice).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_linesearch_objective.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T" href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>SimpleSolvers.linesearch_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linesearch_objective(objective, cache)</code></pre><p>Create <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a> for linesearch algorithm. The variable on which this objective depends is <span>$\alpha$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = [1, 0., 0.]
f = x -&gt; sum(x .^ 3 / 6 + x .^ 2 / 2)
obj = MultivariateObjective(f, x)
gradient!(obj, x)
value!(obj, x)
cache = NewtonOptimizerCache(x)
hess = Hessian(obj, x; mode = :autodiff)
update!(hess, x)
update!(cache, x, obj.g, hess)
x₂ = [.9, 0., 0.]
gradient!(obj, x₂)
value!(obj, x₂)
update!(hess, x₂)
update!(cache, x₂, obj.g, hess)
ls_obj = linesearch_objective(obj, cache)
α = .1
(ls_obj.F(α), ls_obj.D(α))

# output

(0.4412947468016475, -0.8083161485821551)</code></pre><p>In the example above we have to apply <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!</code></a> twice on the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a> because it needs to store the current <em>and</em> the previous iterate.</p><p><strong>Implementation</strong></p><p>Calling the function and derivative stored in the <a href="#SimpleSolvers.TemporaryUnivariateObjective"><code>TemporaryUnivariateObjective</code></a> created with <code>linesearch_objective</code> does not allocate a new array, but uses the one stored in the instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_linesearch_objective.jl#LL1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T" href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, SimpleSolvers.NewtonSolverCache{T, AT} where AT&lt;:AbstractVector{T}, Any}} where T"><code>SimpleSolvers.linesearch_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linesearch_objective(nls, cache, params)</code></pre><p>Make a line search objective for a <em>Newton solver</em> (the <code>cache</code> here is an instance of <a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>).</p><p><strong>Implementation</strong></p><div class="admonition is-info" id="Producing-a-single-valued-output-1802c227a264436d"><header class="admonition-header">Producing a single-valued output<a class="admonition-anchor" href="#Producing-a-single-valued-output-1802c227a264436d" title="Permalink"></a></header><div class="admonition-body"><p>Different from the <code>linesearch_objective</code> for <code>NewtonOptimizerCache</code>s, we apply <code>l2norm</code> to the output of <code>objective!</code>. This is because the solver operates on an objective with multiple outputs from which we have to find roots, whereas an optimizer operates on an objective with a single output of which we should find a minimum.</p></div></div><p>Also see <a href="#SimpleSolvers.linesearch_objective-Union{Tuple{T}, Tuple{MultivariateObjective{T, Tx, TF, TG} where {Tx&lt;:AbstractVector{T}, TF&lt;:Union{Function, Type}, TG&lt;:Gradient{T}}, SimpleSolvers.NewtonOptimizerCache{T, AT} where AT&lt;:(AbstractArray{T})}} where T"><code>linesearch_objective(::MultivariateObjective{T}, ::NewtonOptimizerCache{T}) where {T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_linesearch_objective.jl#LL1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Determines whether the iteration stops based on the current <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>.</p><div class="admonition is-category-warn" id="Warn-a45a7f5f28c0edc"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-a45a7f5f28c0edc" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>meets_stopping_criteria</code> may return <code>true</code> even if the solver has not converged. To check convergence, call <code>assess_convergence!</code> (with the same input arguments).</p></div></div><p>The function <code>meets_stopping_criteria</code> returns <code>true</code> if one of the following is satisfied:</p><ul><li>the <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a> is converged (checked with <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>) and <code>iteration_number(status) ≥ config.min_iterations</code>,</li><li><code>status.f_increased</code> and <code>config.allow_f_increases = false</code> (i.e. <code>f</code> increased even though we do not allow it),</li><li><code>iteration_number(status) ≥ config.max_iterations</code>,</li><li>if any component in <code>solution(status)</code> is <code>NaN</code>,</li><li>if any component in <code>status.f</code> is <code>NaN</code>,</li><li><code>status.rxₐ &gt; config.x_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li><li><code>status.rfₐ &gt; config.f_abstol_break</code> (by default <code>Inf</code>. In theory this returns <code>true</code> if the residual gets too big,</li></ul><p>So convergence is only one possible criterion for which <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>. We may also satisfy a stopping criterion without having convergence!</p><p><strong>Examples</strong></p><p>In the following example we show that <code>meets_stopping_criteria</code> evaluates to true when used on a freshly allocated <a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>:</p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
config = Options()
meets_stopping_criteria(status, config)

# output

true</code></pre><p>This obviously has not converged. To check convergence we can use <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>:</p><pre><code class="language-julia hljs">status = NonlinearSolverStatus{Float64}(5)
config = Options()
assess_convergence!(status, config)

# output

false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL185-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}" href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.OptimizerStatus, Options}"><code>SimpleSolvers.meets_stopping_criteria</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meets_stopping_criteria(status, config)</code></pre><p>Check if the optimizer has converged.</p><p><strong>Implementation</strong></p><p><code>meets_stopping_criteria</code> first calls <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and then checks if one of the following is true:</p><ul><li><code>converged</code> (the output of <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a>) is <code>true</code> and <code>status.i</code> <span>$\geq$</span> <code>config.min_iterations</code>,</li><li>if <code>config.allow_f_increases</code> is <code>false</code>: <code>status.f_increased</code> is <code>true</code>,</li><li><code>status.i</code> <span>$\geq$</span> <code>config.max_iterations</code>,</li><li><code>status.rxₐ</code> <span>$&gt;$</span> <code>config.x_abstol_break</code></li><li><code>status.rxᵣ</code> <span>$&gt;$</span> <code>config.x_reltol_break</code></li><li><code>status.rfₐ</code> <span>$&gt;$</span> <code>config.f_abstol_break</code></li><li><code>status.rfᵣ</code> <span>$&gt;$</span> <code>config.f_reltol_break</code></li><li><code>status.rg</code>  <span>$&gt;$</span> <code>config.g_restol_break</code></li><li><code>status.x_isnan</code></li><li><code>status.f_isnan</code></li><li><code>status.g_isnan</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL168-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.method-Tuple{LinearSolver}" href="#SimpleSolvers.method-Tuple{LinearSolver}"><code>SimpleSolvers.method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">method(ls)</code></pre><p>Return the method (of type <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a>) of the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SimpleSolvers.minimum_decrease_threshold-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SimpleSolvers.minimum_decrease_threshold</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum_decrease_threshold(T)</code></pre><p>The minimum value by which a function <span>$f$</span> should decrease during an iteration.</p><p>The default value of <span>$10^-4$</span> is often used in the literature [bierlaire2015optimization], nocedal2006numerical(@cite).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">minimum_decrease_threshold(Float64)

# output

0.0001</code></pre><pre><code class="language-julia hljs">minimum_decrease_threshold(Float32)

# output

0.0001f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/options.jl#LL65-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.next_iteration!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.next_iteration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">next_iteration!(status)</code></pre><p>Call <a href="#SimpleSolvers.increase_iteration_number!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>increase_iteration_number!</code></a>, set <code>x̄</code> and <code>f̄</code> to <code>x</code> and <code>f</code> respectively and <code>δ</code> as well as <code>γ</code> to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.nonlinearsystem-Tuple{NewtonSolver}" href="#SimpleSolvers.nonlinearsystem-Tuple{NewtonSolver}"><code>SimpleSolvers.nonlinearsystem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonlinearsystem(solver)</code></pre><p>Return the <a href="#SimpleSolvers.NonlinearSystem"><code>NonlinearSystem</code></a> contained in the <a href="#SimpleSolvers.NewtonSolver"><code>NewtonSolver</code></a>. Compare this to <a href="#SimpleSolvers.linearsolver-Tuple{NewtonSolver}"><code>linearsolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}" href="#SimpleSolvers.print_status-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>SimpleSolvers.print_status</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_status(status, config)</code></pre><p>Print the solver status if:</p><ol><li>The following three are satisfied: (i) <code>config.verbosity</code> <span>$\geq1$</span> (ii) <code>assess_convergence!(status, config)</code> is <code>false</code> (iii) <code>iteration_number(status) &gt; config.max_iterations</code></li><li><code>config.verbosity &gt; 1</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.residual!-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(status)</code></pre><p>Compute the residuals for <code>status::</code><a href="#SimpleSolvers.NonlinearSolverStatus"><code>NonlinearSolverStatus</code></a>. Note that this does not update <code>x</code>, <code>f</code>, <code>δ</code> or <code>γ</code>. These are updated with <a href="#GeometricBase.update!-Tuple{HessianAutodiff, AbstractVector}"><code>update!(::NonlinearSolverStatus, ::AbstractVector, ::NonlinearSystem)</code></a>. The computed residuals are the following:</p><ul><li><code>rxₐ</code>: absolute residual in <span>$x$</span>,</li><li><code>rxₛ</code> : successive residual (the norm of <span>$\delta$</span>),</li><li><code>rfₐ</code>: absolute residual in <span>$f$</span>,</li><li><code>rfₛ</code> : successive residual (the norm of <span>$\gamma$</span>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL245-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}" href="#SimpleSolvers.residual!-Union{Tuple{GT}, Tuple{FT}, Tuple{XT}, Tuple{OS}, Tuple{OS, XT, XT, FT, FT, GT, GT}} where {OS&lt;:SimpleSolvers.OptimizerStatus, XT, FT, GT}"><code>SimpleSolvers.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(status, x, x̄, f, f̄, g, ḡ)</code></pre><p>Compute the residual based on previous iterates (<code>x̄</code>, <code>f̄</code>, <code>ḡ</code>) and current iterates (<code>x</code>, <code>f</code>, <code>g</code>).</p><p>Also see <a href="#SimpleSolvers.assess_convergence!-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>assess_convergence!</code></a> and <a href="#SimpleSolvers.meets_stopping_criteria-Tuple{SimpleSolvers.NonlinearSolverStatus, Options}"><code>meets_stopping_criteria</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_status.jl#LL79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}" href="#SimpleSolvers.residual!-Union{Tuple{OR}, Tuple{OST}, Tuple{YT}, Tuple{VT}, Tuple{XT}, Tuple{OR, VT, YT, VT}} where {XT, VT&lt;:(AbstractArray{XT}), YT, OST&lt;:SimpleSolvers.OptimizerStatus{XT, YT}, OR&lt;:SimpleSolvers.OptimizerResult{XT, YT, VT, OST}}"><code>SimpleSolvers.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(result, x, f, g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer_result.jl#LL30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonOptimizerCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right hand side of an instance of <a href="update/#NewtonOptimizerCache"><code>NewtonOptimizerCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/newton_optimizer_cache.jl#LL36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}" href="#SimpleSolvers.rhs-Tuple{SimpleSolvers.NewtonSolverCache}"><code>SimpleSolvers.rhs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rhs(cache)</code></pre><p>Return the right-hand side of the equation, stored in <code>cache::</code><a href="#SimpleSolvers.NewtonSolverCache"><code>NewtonSolverCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver_cache.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T" href="#SimpleSolvers.shift_χ_to_avoid_stalling-Union{Tuple{T}, NTuple{5, T}} where T"><code>SimpleSolvers.shift_χ_to_avoid_stalling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shift_χ_to_avoid_stalling(χ, a, b, c, ε)</code></pre><p>Check whether <code>b</code> is closer to <code>a</code> or <code>c</code> and shift <code>χ</code> accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linesearch/bierlaire_quadratic.jl#LL47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}" href="#SimpleSolvers.solution-Tuple{SimpleSolvers.NonlinearSolverStatus}"><code>SimpleSolvers.solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution(status)</code></pre><p>Return the current value of <code>x</code> (i.e. the current solution).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/nonlinear_solver_status.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractMatrix, AbstractVector}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, A, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$A$</span> and <span>$b$</span> are provided as an input arguments.</p><p><strong>implementation</strong></p><p>Note that, compared to <a href="#SimpleSolvers.solve-Tuple{LinearSystem, SimpleSolvers.LinearSolverMethod}"><code>solve(::LinearSolver, ::AbstractVector)</code></a> this method involves an additional <em>factorization</em> of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL100-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, AbstractVector}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, b)</code></pre><p>Solve the linear system described by:</p><p class="math-container">\[    Ax = b,\]</p><p>and store it in <code>x</code>. Here <span>$b$</span> is provided as an input argument and the factorized <span>$A$</span> is stored in the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> (respectively its <a href="#SimpleSolvers.LinearSolverCache"><code>LinearSolverCache</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearSystem}" href="#SimpleSolvers.solve!-Tuple{AbstractVector, LinearSolver, LinearSystem}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(x, ls::LinearSolver, lsys::LinearSystem)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a> <code>lsys</code> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code> and store the result in <code>x</code>. Also see <a href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>solve!(::LinearSolver, ::LinearSystem)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}" href="#SimpleSolvers.solve!-Tuple{LinearSolver, Vararg{Any}}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(ls::LinearSolver, args...)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a> with the <a href="#SimpleSolvers.LinearSolver"><code>LinearSolver</code></a> <code>ls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solvers.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{NewtonSolver, AbstractArray}" href="#SimpleSolvers.solve!-Tuple{NewtonSolver, AbstractArray}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(s, x)</code></pre><p><strong>Extended help</strong></p><div class="admonition is-info" id="Info-5256dfbcc8959c96"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-5256dfbcc8959c96" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>update!</code> calls <code>next_iteration!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}" href="#SimpleSolvers.solve!-Tuple{Optimizer, AbstractVector}"><code>SimpleSolvers.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(x, opt)</code></pre><p>Solve the optimization problem described by <code>opt::</code><a href="#SimpleSolvers.Optimizer"><code>Optimizer</code></a> and store the result in <code>x</code>.</p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())

solve!(opt, x)

# output
2-element Vector{Float32}:
 4.6478817f-8
 3.0517578f-5</code></pre><p>We can also check how many iterations it took:</p><pre><code class="language-julia hljs">iteration_number(opt)

# output

12</code></pre><p>Too see the value of <code>x</code> after one iteration confer the docstring of <a href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T"><code>solver_step!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL215-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solve-Tuple{LinearSystem, SimpleSolvers.LinearSolverMethod}" href="#SimpleSolvers.solve-Tuple{LinearSystem, SimpleSolvers.LinearSolverMethod}"><code>SimpleSolvers.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(ls, method)</code></pre><p>Solve the <a href="#SimpleSolvers.LinearSystem"><code>LinearSystem</code></a> <code>ls</code> with the <a href="#SimpleSolvers.LinearSolverMethod"><code>LinearSolverMethod</code></a> <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/linear/linear_solver_method.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T" href="#SimpleSolvers.solver_step!-Union{Tuple{T}, Tuple{NewtonSolver, AbstractVector{T}, Any}} where T"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver_step!(s, x, params)</code></pre><p>Compute one Newton step for <code>f</code> based on the <a href="#SimpleSolvers.Jacobian"><code>Jacobian</code></a> <code>jacobian!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/nonlinear/newton_solver.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)" href="#SimpleSolvers.solver_step!-Union{Tuple{VT}, Tuple{Optimizer, VT}} where VT&lt;:(AbstractVector)"><code>SimpleSolvers.solver_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver_step!(x, state)</code></pre><p>Compute a full iterate for an instance of <a href="#SimpleSolvers.NewtonOptimizerState"><code>NewtonOptimizerState</code></a> <code>state</code>.</p><p>This also performs a line search.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f(x) = sum(x .^ 2 + x .^ 3 / 3)
x = [1f0, 2f0]
opt = Optimizer(x, f; algorithm = Newton())

solver_step!(opt, x)

# output

2-element Vector{Float32}:
 0.25
 0.6666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/optimization/optimizer.jl#LL177-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T" href="#SimpleSolvers.triple_point_finder-Union{Tuple{Union{Function, Type}}, Tuple{T}, Tuple{Union{Function, Type}, T}} where T"><code>SimpleSolvers.triple_point_finder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triple_point_finder(f, x)</code></pre><p>Find three points <code>a &gt; b &gt; c</code> s.t. <code>f(a) &gt; f(b)</code> and <code>f(c) &gt; f(b)</code>. This is used for performing a quadratic line search (see <a href="#SimpleSolvers.QuadraticState"><code>QuadraticState</code></a>).</p><p><strong>Implementation</strong></p><p>For <code>δ</code> we take <a href="#SimpleSolvers.DEFAULT_BRACKETING_s"><code>DEFAULT_BRACKETING_s</code></a> as default. For <code>nmax we take [</code>DEFAULT<em>BRACKETING</em>nmax`](@ref) as default.</p><p><strong>Extended help</strong></p><p>The algorithm is taken from [<a href="references/#bierlaire2015optimization">2</a>, Chapter 11.2.1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/bracketing/triple_point_finder.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}" href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>SimpleSolvers.value!!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value!!(obj::AbstractObjective, x)</code></pre><p>Set <code>obj.x_f</code> to <code>x</code> and <code>obj.f</code> to <code>value(obj, x)</code> and return <code>value(obj)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}" href="#SimpleSolvers.value!-Tuple{SimpleSolvers.AbstractObjective, Union{Number, AbstractArray{&lt;:Number}}}"><code>SimpleSolvers.value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value!(obj::AbstractObjective, x)</code></pre><p>Check if <code>x</code> is not equal to <code>obj.x_f</code> and then apply <a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>value!!</code></a>. Else simply return <code>value(obj)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/objectives.jl#LL160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number" href="#SimpleSolvers.value!-Union{Tuple{T}, Tuple{NonlinearSystem{T, TF, TJ, Tx, Tf, Tj} where {TF&lt;:Union{Function, Type}, TJ&lt;:Jacobian{T}, Tx&lt;:AbstractVector{T}, Tf&lt;:AbstractVector{T}, Tj&lt;:AbstractMatrix{T}}, AbstractVector{T}, Any}} where T&lt;:Number"><code>SimpleSolvers.value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value!(nls::NonlinearSystem, x)</code></pre><p>Check if <code>x</code> is not equal to <code>f_argument(nls)</code> and then apply <a href="#SimpleSolvers.value!!-Tuple{SimpleSolvers.AbstractUnivariateObjective, Number}"><code>value!!</code></a>. Else simply return <code>value(nls)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SimpleSolvers.jl/blob/5af67af86a2e68b473e59fb6a5218c332426090b/src/base/systems.jl#LL198-L202">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="objectives/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 3 July 2025 15:58">Thursday 3 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
